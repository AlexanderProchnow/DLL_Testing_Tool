
    <!DOCTYPE html>
    <html>
    <head>
    <style>
    .collapsible {
      background-color: #777;
      color: white;
      cursor: pointer;
      padding: 18px;
      width: 100%;
      border: none;
      text-align: left;
      outline: none;
      font-size: 15px;
    }

    .active, .collapsible:hover {
      background-color: #555;
    }

    .content {
      padding: 0 18px;
      display: none;
      overflow: hidden;
      background-color: #f1f1f1;
    }
    </style>
    </head>
    <body>

_____________________________________scipy\sparse\csc.py_________________________________________
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>File_Path</th>
      <th>Line_Number</th>
      <th>Found_in_Function</th>
      <th>Function_Definition_Line_Number</th>
      <th>Assert_Statement_Type</th>
      <th>Oracle_Argument_ Position</th>
      <th>Differential_Function_Line_Number</th>
      <th>Differential_Test_Function</th>
      <th>Extracted_Function_File_Location</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1268</th>
      <td>\sparse\tests\test_basic.py</td>
      <td>320</td>
      <td>test_transpose_csc</td>
      <td>315</td>
      <td>assertTrue</td>
      <td>2</td>
      <td>316</td>
      <td>scipy.sparse.csc_matrix</td>
      <td>scipy\sparse\csc.py</td>
    </tr>
    <tr>
      <th>1270</th>
      <td>\sparse\tests\test_basic.py</td>
      <td>321</td>
      <td>test_transpose_csc</td>
      <td>315</td>
      <td>assertTrue</td>
      <td>2</td>
      <td>316</td>
      <td>scipy.sparse.csc_matrix</td>
      <td>scipy\sparse\csc.py</td>
    </tr>
    <tr>
      <th>1273</th>
      <td>\sparse\tests\test_basic.py</td>
      <td>323</td>
      <td>test_transpose_csc</td>
      <td>315</td>
      <td>assertTrue</td>
      <td>2</td>
      <td>316</td>
      <td>scipy.sparse.csc_matrix</td>
      <td>scipy\sparse\csc.py</td>
    </tr>
    <tr>
      <th>1276</th>
      <td>\sparse\tests\test_basic.py</td>
      <td>324</td>
      <td>test_transpose_csc</td>
      <td>315</td>
      <td>assertTrue</td>
      <td>2</td>
      <td>316</td>
      <td>scipy.sparse.csc_matrix</td>
      <td>scipy\sparse\csc.py</td>
    </tr>
  </tbody>
</table>
 <br>Commit id closest to current version: 69170135bd5e5b1e9b4d712ca9a4307283780f14

 <br>Commit message: DOC: Added docstrings to issparse/isspmatrix(_...) methods and added examples to scipy.sparse methods (#7208)<br><br>DOC: sparse: added docstrings and examples to sparse routines<br><br>
<br>Commit id closest to desired version: 6d1d840376220c424b9990ed74874b588ce26d74

 <br>Commit message: MAINT: use 'yield from <expr>' (PEP 380) (#14030)<br><br><br>
<br><button type="button" class="collapsible">Git Diff</button>
<div class="content">
<p>diff --git a/scipy/sparse/csc.py b/scipy/sparse/csc.py
<br>index ed83ce085..451b5e53f 100644
<br><span style="color:red">- -- a/scipy/sparse/csc.py</span>
<br><span style="color:green">+++ b/scipy/sparse/csc.py</span>
<br>@@ -1,6 +1,4 @@
<br>&nbsp"""Compressed Sparse Column matrix format"""
<br><span style="color:red">- from __future__ import division, print_function, absolute_import</span>
<br><span style="color:red">- </span>
<br>&nbsp__docformat__ = "restructuredtext en"
<br>&nbsp
<br>&nbsp__all__ = ['csc_matrix', 'isspmatrix_csc']
<br>@@ -9,14 +7,13 @@ __all__ = ['csc_matrix', 'isspmatrix_csc']
<br>&nbspimport numpy as np
<br>&nbsp
<br>&nbspfrom .base import spmatrix
<br><span style="color:red">- from ._sparsetools import csc_tocsr</span>
<br><span style="color:red">- from . import _sparsetools</span>
<br><span style="color:red">- from .sputils import upcast, isintlike, IndexMixin, get_index_dtype</span>
<br><span style="color:green">+from ._sparsetools import csc_tocsr, expandptr</span>
<br><span style="color:green">+from .sputils import upcast, get_index_dtype</span>
<br>&nbsp
<br>&nbspfrom .compressed import _cs_matrix
<br>&nbsp
<br>&nbsp
<br><span style="color:red">- class csc_matrix(_cs_matrix, IndexMixin):</span>
<br><span style="color:green">+class csc_matrix(_cs_matrix):</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp &nbsp &nbsp &nbsp &nbspCompressed Sparse Column matrix
<br>&nbsp
<br>@@ -53,7 +50,7 @@ class csc_matrix(_cs_matrix, IndexMixin):
<br>&nbsp &nbsp &nbsp &nbsp &nbspndim : int
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspNumber of dimensions (this is always 2)
<br>&nbsp &nbsp &nbsp &nbsp &nbspnnz
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspNumber of nonzero elements</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspNumber of stored values, including explicit zeros</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspdata
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspData array of the matrix
<br>&nbsp &nbsp &nbsp &nbsp &nbspindices
<br>@@ -123,8 +120,7 @@ class csc_matrix(_cs_matrix, IndexMixin):
<br>&nbsp &nbsp &nbsp &nbsp &nbsptranspose.__doc__ = spmatrix.transpose.__doc__
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef __iter__(self):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspfor r in self.tocsr():</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspyield r</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspyield from self.tocsr()</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef tocsc(self, copy=False):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif copy:
<br>@@ -157,18 +153,6 @@ class csc_matrix(_cs_matrix, IndexMixin):
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsptocsr.__doc__ = spmatrix.tocsr.__doc__
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspdef __getitem__(self, key):</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# Use CSR to implement fancy indexing.</span>
<br><span style="color:red">- </span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprow, col = self._unpack_index(key)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# Things that return submatrices. row or col is a int or slice.</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif (isinstance(row, slice) or isinstance(col, slice) or</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspisintlike(row) or isintlike(col)):</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn self.T[col, row].T</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# Things that return a sequence of values.</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelse:</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn self.T[col, row]</span>
<br><span style="color:red">- </span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef nonzero(self):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# CSC can't use _cs_matrix's .nonzero method because it
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# returns the indices sorted for self transposed.
<br>@@ -177,7 +161,7 @@ class csc_matrix(_cs_matrix, IndexMixin):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmajor_dim, minor_dim = self._swap(self.shape)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspminor_indices = self.indices
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmajor_indices = np.empty(len(minor_indices), dtype=self.indices.dtype)
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp_sparsetools.expandptr(major_dim, self.indptr, major_indices)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspexpandptr(major_dim, self.indptr, major_indices)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprow, col = self._swap((major_indices, minor_indices))
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# Remove explicit zeros
<br>@@ -198,9 +182,13 @@ class csc_matrix(_cs_matrix, IndexMixin):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Returns a copy of row i of the matrix, as a (1 x n)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspCSR matrix (row vector).
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# we convert to CSR to maintain compatibility with old impl.</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# in spmatrix.getrow()</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn self._get_submatrix(i, slice(None)).tocsr()</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspM, N = self.shape</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspi = int(i)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif i < 0:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspi += M</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif i < 0 or i >= M:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise IndexError('index (%d) out of range' % i)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn self._get_submatrix(minor=i).tocsr()</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef getcol(self, i):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Returns a copy of column i of the matrix, as a (m x 1)
<br>@@ -212,12 +200,29 @@ class csc_matrix(_cs_matrix, IndexMixin):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspi += N
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif i < 0 or i >= N:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise IndexError('index (%d) out of range' % i)
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspidx = slice(*self.indptr[i:i+2])</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdata = self.data[idx].copy()</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspindices = self.indices[idx].copy()</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspindptr = np.array([0, len(indices)], dtype=self.indptr.dtype)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn csc_matrix((data, indices, indptr), shape=(M, 1),</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdtype=self.dtype, copy=False)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn self._get_submatrix(major=i, copy=True)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdef _get_intXarray(self, row, col):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn self._major_index_fancy(col)._get_submatrix(minor=row)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdef _get_intXslice(self, row, col):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif col.step in (1, None):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn self._get_submatrix(major=col, minor=row, copy=True)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn self._major_slice(col)._get_submatrix(minor=row)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdef _get_sliceXint(self, row, col):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif row.step in (1, None):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn self._get_submatrix(major=col, minor=row, copy=True)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn self._get_submatrix(major=col)._minor_slice(row)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdef _get_sliceXarray(self, row, col):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn self._major_index_fancy(col)._minor_slice(row)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdef _get_arrayXint(self, row, col):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn self._get_submatrix(major=col)._minor_index_fancy(row)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdef _get_arrayXslice(self, row, col):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn self._major_slice(col)._minor_index_fancy(row)</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp# these functions are used by the parent class (_cs_matrix)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp# to remove redudancy between csc_matrix and csr_matrix
<br></p>
</div>
<br><br><br>_____________________________________scipy\linalg\decomp_cholesky.py_________________________________________
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>File_Path</th>
      <th>Line_Number</th>
      <th>Found_in_Function</th>
      <th>Function_Definition_Line_Number</th>
      <th>Assert_Statement_Type</th>
      <th>Oracle_Argument_ Position</th>
      <th>Differential_Function_Line_Number</th>
      <th>Differential_Test_Function</th>
      <th>Extracted_Function_File_Location</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>3775</th>
      <td>\tensor\tests\test_slinalg.py</td>
      <td>250</td>
      <td>test_solve_correctness</td>
      <td>220</td>
      <td>allclose</td>
      <td>1</td>
      <td>249</td>
      <td>scipy.linalg.cholesky</td>
      <td>scipy\linalg\decomp_cholesky.py</td>
    </tr>
    <tr>
      <th>3780</th>
      <td>\tensor\tests\test_slinalg.py</td>
      <td>250</td>
      <td>test_solve_correctness</td>
      <td>220</td>
      <td>allclose</td>
      <td>2</td>
      <td>249</td>
      <td>scipy.linalg.cholesky</td>
      <td>scipy\linalg\decomp_cholesky.py</td>
    </tr>
    <tr>
      <th>3785</th>
      <td>\tensor\tests\test_slinalg.py</td>
      <td>255</td>
      <td>test_solve_correctness</td>
      <td>220</td>
      <td>allclose</td>
      <td>1</td>
      <td>254</td>
      <td>scipy.linalg.cholesky</td>
      <td>scipy\linalg\decomp_cholesky.py</td>
    </tr>
    <tr>
      <th>3790</th>
      <td>\tensor\tests\test_slinalg.py</td>
      <td>255</td>
      <td>test_solve_correctness</td>
      <td>220</td>
      <td>allclose</td>
      <td>2</td>
      <td>254</td>
      <td>scipy.linalg.cholesky</td>
      <td>scipy\linalg\decomp_cholesky.py</td>
    </tr>
  </tbody>
</table>
 <br>Commit id closest to current version: 954fe8f669cce9b7c5d1f4f9486e55059db3de53

 <br>Commit message: PEP8: Fixed a few over indented lines<br><br>
<br>Commit id closest to desired version: 8beb2c37f497aea9be869626b50e2d246dbba866

 <br>Commit message: DOC: sparse/linalg: improve consistency and clarity of arpack docs (#12338)<br><br>* DOC: fix misleading, stale comment<br>* DOC: add helpful note in eigsh docstring<br>* DOC: impose greater consistency of language<br>* DOC: fix misspelling<br>
<br><button type="button" class="collapsible">Git Diff</button>
<div class="content">
<p>diff --git a/scipy/linalg/decomp_cholesky.py b/scipy/linalg/decomp_cholesky.py
<br>index 5126a64f8..796f36fd2 100644
<br><span style="color:red">- -- a/scipy/linalg/decomp_cholesky.py</span>
<br><span style="color:green">+++ b/scipy/linalg/decomp_cholesky.py</span>
<br>@@ -1,7 +1,5 @@
<br>&nbsp"""Cholesky decomposition functions."""
<br>&nbsp
<br><span style="color:red">- from __future__ import division, print_function, absolute_import</span>
<br><span style="color:red">- </span>
<br>&nbspfrom numpy import asarray_chkfinite, asarray, atleast_2d
<br>&nbsp
<br>&nbsp# Local imports
<br>@@ -21,7 +19,7 @@ def _cholesky(a, lower=False, overwrite_a=False, clean=True,
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp# Dimension check
<br>&nbsp &nbsp &nbsp &nbsp &nbspif a1.ndim != 2:
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError('Input array needs to be 2 dimensional but received '</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError('Input array needs to be 2D but received '</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp'a {}d-array.'.format(a1.ndim))
<br>&nbsp &nbsp &nbsp &nbsp &nbsp# Squareness check
<br>&nbsp &nbsp &nbsp &nbsp &nbspif a1.shape[0] != a1.shape[1]:
<br>@@ -56,7 +54,7 @@ def cholesky(a, lower=False, overwrite_a=False, check_finite=True):
<br>&nbsp &nbsp &nbsp &nbsp &nbspa : (M, M) array_like
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspMatrix to be decomposed
<br>&nbsp &nbsp &nbsp &nbsp &nbsplower : bool, optional
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspWhether to compute the upper or lower triangular Cholesky</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspWhether to compute the upper- or lower-triangular Cholesky</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspfactorization.  Default is upper-triangular.
<br>&nbsp &nbsp &nbsp &nbsp &nbspoverwrite_a : bool, optional
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspWhether to overwrite data in `a` (may improve performance).
<br>@@ -76,13 +74,13 @@ def cholesky(a, lower=False, overwrite_a=False, check_finite=True):
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspExamples
<br>&nbsp &nbsp &nbsp &nbsp &nbsp--------
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp>>> from scipy import array, linalg, dot</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp>>> a = array([[1,-2j],[2j,5]])</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp>>> L = linalg.cholesky(a, lower=True)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> from scipy.linalg import cholesky</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> a = np.array([[1,-2j],[2j,5]])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> L = cholesky(a, lower=True)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp>>> L
<br>&nbsp &nbsp &nbsp &nbsp &nbsparray([[ 1.+0.j,  0.+0.j],
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[ 0.+2.j,  1.+0.j]])
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp>>> dot(L, L.T.conj())</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> L @ L.T.conj()</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsparray([[ 1.+0.j,  0.-2.j],
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[ 0.+2.j,  5.+0.j]])
<br>&nbsp
<br>@@ -137,6 +135,19 @@ def cho_factor(a, lower=False, overwrite_a=False, check_finite=True):
<br>&nbsp &nbsp &nbsp &nbsp &nbspcho_solve : Solve a linear set equations using the Cholesky factorization
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspof a matrix.
<br>&nbsp
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspExamples</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp--------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> from scipy.linalg import cho_factor</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> A = np.array([[9, 3, 1, 5], [3, 7, 5, 1], [1, 5, 9, 2], [5, 1, 2, 6]])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> c, low = cho_factor(A)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> c</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsparray([[3.        , 1.        , 0.33333333, 1.66666667],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[3.        , 2.44948974, 1.90515869, -0.27216553],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[1.        , 5.        , 2.29330749, 0.8559528 ],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[5.        , 1.        , 2.        , 1.55418563]])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> np.allclose(np.triu(c).T @ np. triu(c) - A, np.zeros((4, 4)))</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspTrue</span>
<br><span style="color:green">+</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp &nbsp &nbsp &nbsp &nbspc, lower = _cholesky(a, lower=lower, overwrite_a=overwrite_a, clean=False,
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcheck_finite=check_finite)
<br>@@ -168,6 +179,15 @@ def cho_solve(c_and_lower, b, overwrite_b=False, check_finite=True):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp--------
<br>&nbsp &nbsp &nbsp &nbsp &nbspcho_factor : Cholesky factorization of a matrix
<br>&nbsp
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspExamples</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp--------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> from scipy.linalg import cho_factor, cho_solve</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> A = np.array([[9, 3, 1, 5], [3, 7, 5, 1], [1, 5, 9, 2], [5, 1, 2, 6]])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> c, low = cho_factor(A)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> x = cho_solve((c, low), [1, 1, 1, 1])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> np.allclose(A @ x - [1, 1, 1, 1], np.zeros(4))</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspTrue</span>
<br><span style="color:green">+</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp &nbsp &nbsp &nbsp &nbsp(c, lower) = c_and_lower
<br>&nbsp &nbsp &nbsp &nbsp &nbspif check_finite:
<br>@@ -179,14 +199,15 @@ def cho_solve(c_and_lower, b, overwrite_b=False, check_finite=True):
<br>&nbsp &nbsp &nbsp &nbsp &nbspif c.ndim != 2 or c.shape[0] != c.shape[1]:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("The factored matrix c is not square.")
<br>&nbsp &nbsp &nbsp &nbsp &nbspif c.shape[1] != b1.shape[0]:
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("incompatible dimensions.")</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("incompatible dimensions ({} and {})"</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp.format(c.shape, b1.shape))</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspoverwrite_b = overwrite_b or _datacopied(b1, b)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsppotrs, = get_lapack_funcs(('potrs',), (c, b1))
<br>&nbsp &nbsp &nbsp &nbsp &nbspx, info = potrs(c, b1, lower=lower, overwrite_b=overwrite_b)
<br>&nbsp &nbsp &nbsp &nbsp &nbspif info != 0:
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError('illegal value in %d-th argument of internal potrs'</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError('illegal value in %dth argument of internal potrs'</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp% -info)
<br>&nbsp &nbsp &nbsp &nbsp &nbspreturn x
<br>&nbsp
<br>@@ -195,7 +216,7 @@ def cholesky_banded(ab, overwrite_ab=False, lower=False, check_finite=True):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp &nbsp &nbsp &nbsp &nbspCholesky decompose a banded Hermitian positive-definite matrix
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspThe matrix a is stored in ab either in lower diagonal or upper</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspThe matrix a is stored in ab either in lower-diagonal or upper-</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspdiagonal ordered form::
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspab[u + i - j, j] == a[i,j]        (if upper form; i <= j)
<br>@@ -231,6 +252,23 @@ def cholesky_banded(ab, overwrite_ab=False, lower=False, check_finite=True):
<br>&nbsp &nbsp &nbsp &nbsp &nbspc : (u + 1, M) ndarray
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspCholesky factorization of a, in the same banded format as ab
<br>&nbsp
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspSee also</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp--------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspcho_solve_banded : Solve a linear set equations, given the Cholesky factorization</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspof a banded Hermitian.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspExamples</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp--------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> from scipy.linalg import cholesky_banded</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> from numpy import allclose, zeros, diag</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> Ab = np.array([[0, 0, 1j, 2, 3j], [0, -1, -2, 3, 4], [9, 8, 7, 6, 9]])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> A = np.diag(Ab[0,2:], k=2) + np.diag(Ab[1,1:], k=1)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> A = A + A.conj().T + np.diag(Ab[2, :])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> c = cholesky_banded(Ab)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> C = np.diag(c[0, 2:], k=2) + np.diag(c[1, 1:], k=1) + np.diag(c[2, :])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> np.allclose(C.conj().T @ C - A, np.zeros((5, 5)))</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspTrue</span>
<br><span style="color:green">+</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp &nbsp &nbsp &nbsp &nbspif check_finite:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspab = asarray_chkfinite(ab)
<br>@@ -248,14 +286,16 @@ def cholesky_banded(ab, overwrite_ab=False, lower=False, check_finite=True):
<br>&nbsp
<br>&nbsp
<br>&nbspdef cho_solve_banded(cb_and_lower, b, overwrite_b=False, check_finite=True):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp"""Solve the linear equations A x = b, given the Cholesky factorization of A.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspSolve the linear equations ``A x = b``, given the Cholesky factorization of</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspthe banded Hermitian ``A``.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp----------
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp(cb, lower) : tuple, (array, bool)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp(cb, lower) : tuple, (ndarray, bool)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp`cb` is the Cholesky factorization of A, as given by cholesky_banded.
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp`lower` must be the same value that was given to cholesky_banded.
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspb : array</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspb : array_like</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspRight-hand side
<br>&nbsp &nbsp &nbsp &nbsp &nbspoverwrite_b : bool, optional
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf True, the function will overwrite the values in `b`.
<br>@@ -278,6 +318,17 @@ def cho_solve_banded(cb_and_lower, b, overwrite_b=False, check_finite=True):
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp.. versionadded:: 0.8.0
<br>&nbsp
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspExamples</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp--------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> from scipy.linalg import cholesky_banded, cho_solve_banded</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> Ab = np.array([[0, 0, 1j, 2, 3j], [0, -1, -2, 3, 4], [9, 8, 7, 6, 9]])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> A = np.diag(Ab[0,2:], k=2) + np.diag(Ab[1,1:], k=1)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> A = A + A.conj().T + np.diag(Ab[2, :])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> c = cholesky_banded(Ab)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> x = cho_solve_banded((c, False), np.ones(5))</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> np.allclose(A @ x - np.ones(5), np.zeros(5))</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspTrue</span>
<br><span style="color:green">+</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp &nbsp &nbsp &nbsp &nbsp(cb, lower) = cb_and_lower
<br>&nbsp &nbsp &nbsp &nbsp &nbspif check_finite:
<br>@@ -294,8 +345,8 @@ def cho_solve_banded(cb_and_lower, b, overwrite_b=False, check_finite=True):
<br>&nbsp &nbsp &nbsp &nbsp &nbsppbtrs, = get_lapack_funcs(('pbtrs',), (cb, b))
<br>&nbsp &nbsp &nbsp &nbsp &nbspx, info = pbtrs(cb, b, lower=lower, overwrite_b=overwrite_b)
<br>&nbsp &nbsp &nbsp &nbsp &nbspif info > 0:
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise LinAlgError("%d-th leading minor not positive definite" % info)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise LinAlgError("%dth leading minor not positive definite" % info)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspif info < 0:
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError('illegal value in %d-th argument of internal pbtrs'</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError('illegal value in %dth argument of internal pbtrs'</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp% -info)
<br>&nbsp &nbsp &nbsp &nbsp &nbspreturn x
<br></p>
</div>
<br><br><br>_____________________________________scipy\linalg\special_matrices.py_________________________________________
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>File_Path</th>
      <th>Line_Number</th>
      <th>Found_in_Function</th>
      <th>Function_Definition_Line_Number</th>
      <th>Assert_Statement_Type</th>
      <th>Oracle_Argument_ Position</th>
      <th>Differential_Function_Line_Number</th>
      <th>Differential_Test_Function</th>
      <th>Extracted_Function_File_Location</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>3799</th>
      <td>\tensor\tests\test_slinalg.py</td>
      <td>397</td>
      <td>test_perform</td>
      <td>374</td>
      <td>assert_allclose</td>
      <td>2</td>
      <td>396</td>
      <td>scipy.linalg.kron</td>
      <td>scipy\linalg\special_matrices.py</td>
    </tr>
  </tbody>
</table>
 <br>Commit id closest to current version: d246bf1f49eb0e321458dcbf3fb41c5c8ec6306d

 <br>Commit message: fix some alerts found with lgtm (#7511)<br><br>* fix some alerts found with lgtm<br><br>* address @perimosocordiae comment<br><br>* respect style format<br><br>* remove redundant comparisons<br><br>
<br>Commit id closest to desired version: 09a001e2bdfa3cf604dd5f15f2a20bd48274fa35

 <br>Commit message: ENH: linalg: Add the function convolution_matrix. (#12135)<br><br>* ENH: linalg: Add the function convolution_matrix.<br><br>This addition to the collection of special matrices creates<br>a matrix whose action is the same as that of the function<br>numpy.convolve.<br><br>* DOC: A PEP8 typo and tutorial pages update<br><br>* MAINT: Assorted cleanup and revisions for convolution_matrix<br><br>* Copy-edit the docstring and add more examples.<br>* Remove a very slow (and basically redundant) test.<br>* A couple other minor code tweaks.<br><br>* BUG: linalg: Fix convolution_matrix so it handles length 1 inputs.<br><br>Also rewrite the test suite for convolution_matrix as a class<br>with methods, and use pytest to parametrize one of the tests.<br>The input sizes over which the test iterates are now [1, 2, 9].<br><br>* MAINT: linalg: A few refinements for convolution_matrix<br><br>* Replace '1-d' with 'one-dimensional' in an error message.<br>* Add more tests of bad arguments to TestConvolutionMatrix, and<br>  tweak a couple docstrings.<br>* Use pytest.raises with the match parameter to make the argument<br>  validation tests more specific.<br><br>Co-authored-by: Mark Borgerding <markb@3db-labs.com><br>Co-authored-by: Ilhan Polat <ilhanpolat@gmail.com><br>
<br><button type="button" class="collapsible">Git Diff</button>
<div class="content">
<p>diff --git a/scipy/linalg/special_matrices.py b/scipy/linalg/special_matrices.py
<br>index 90788c55d..c862b58d7 100644
<br><span style="color:red">- -- a/scipy/linalg/special_matrices.py</span>
<br><span style="color:green">+++ b/scipy/linalg/special_matrices.py</span>
<br>@@ -1,28 +1,25 @@
<br><span style="color:red">- from __future__ import division, print_function, absolute_import</span>
<br><span style="color:red">- </span>
<br>&nbspimport math
<br>&nbspimport numpy as np
<br><span style="color:red">- from scipy._lib.six import xrange</span>
<br><span style="color:red">- from scipy._lib.six import string_types</span>
<br><span style="color:red">- </span>
<br><span style="color:green">+from numpy.lib.stride_tricks import as_strided</span>
<br>&nbsp
<br>&nbsp__all__ = ['tri', 'tril', 'triu', 'toeplitz', 'circulant', 'hankel',
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp'hadamard', 'leslie', 'kron', 'block_diag', 'companion',
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp'helmert', 'hilbert', 'invhilbert', 'pascal', 'invpascal', 'dft']</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp'helmert', 'hilbert', 'invhilbert', 'pascal', 'invpascal', 'dft',</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp'fiedler', 'fiedler_companion', 'convolution_matrix']</span>
<br>&nbsp
<br>&nbsp
<br><span style="color:red">- #-----------------------------------------------------------------------------</span>
<br><span style="color:red">- # matrix construction functions</span>
<br><span style="color:red">- #-----------------------------------------------------------------------------</span>
<br><span style="color:green">+# -----------------------------------------------------------------------------</span>
<br><span style="color:green">+#  matrix construction functions</span>
<br><span style="color:green">+# -----------------------------------------------------------------------------</span>
<br>&nbsp
<br>&nbsp#
<br><span style="color:red">- # *Note*: tri{,u,l} is implemented in numpy, but an important bug was fixed in</span>
<br><span style="color:green">+# *Note*: tri{,u,l} is implemented in NumPy, but an important bug was fixed in</span>
<br>&nbsp# 2.0.0.dev-1af2f3, the following tri{,u,l} definitions are here for backwards
<br>&nbsp# compatibility.
<br>&nbsp
<br>&nbspdef tri(N, M=None, k=0, dtype=None):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspConstruct (N, M) matrix filled with ones at and below the k-th diagonal.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspConstruct (N, M) matrix filled with ones at and below the kth diagonal.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspThe matrix has A[i,j] == 1 for i <= j + k
<br>&nbsp
<br>@@ -60,12 +57,12 @@ def tri(N, M=None, k=0, dtype=None):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp &nbsp &nbsp &nbsp &nbspif M is None:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspM = N
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspif isinstance(M, string_types):</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp#pearu: any objections to remove this feature?</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspif isinstance(M, str):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# pearu: any objections to remove this feature?</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp#       As tri(N,'d') is equivalent to tri(N,dtype='d')
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdtype = M
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspM = N
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspm = np.greater_equal(np.subtract.outer(np.arange(N), np.arange(M)), -k)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspm = np.greater_equal.outer(np.arange(k, N+k), np.arange(M))</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspif dtype is None:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn m
<br>&nbsp &nbsp &nbsp &nbsp &nbspelse:
<br>@@ -74,7 +71,7 @@ def tri(N, M=None, k=0, dtype=None):
<br>&nbsp
<br>&nbspdef tril(m, k=0):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspMake a copy of a matrix with elements above the k-th diagonal zeroed.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspMake a copy of a matrix with elements above the kth diagonal zeroed.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -107,7 +104,7 @@ def tril(m, k=0):
<br>&nbsp
<br>&nbspdef triu(m, k=0):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspMake a copy of a matrix with elements below the k-th diagonal zeroed.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspMake a copy of a matrix with elements below the kth diagonal zeroed.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -121,7 +118,7 @@ def triu(m, k=0):
<br>&nbsp &nbsp &nbsp &nbsp &nbspReturns
<br>&nbsp &nbsp &nbsp &nbsp &nbsp-------
<br>&nbsp &nbsp &nbsp &nbsp &nbsptriu : ndarray
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspReturn matrix with zeroed elements below the k-th diagonal and has</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspReturn matrix with zeroed elements below the kth diagonal and has</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsame shape and type as `m`.
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspExamples
<br>@@ -144,7 +141,7 @@ def toeplitz(c, r=None):
<br>&nbsp &nbsp &nbsp &nbsp &nbspConstruct a Toeplitz matrix.
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspThe Toeplitz matrix has constant diagonals, with c as its first column
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspand r as its first row.  If r is not given, ``r == conjugate(c)`` is</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspand r as its first row. If r is not given, ``r == conjugate(c)`` is</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspassumed.
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>@@ -173,7 +170,7 @@ def toeplitz(c, r=None):
<br>&nbsp &nbsp &nbsp &nbsp &nbspNotes
<br>&nbsp &nbsp &nbsp &nbsp &nbsp-----
<br>&nbsp &nbsp &nbsp &nbsp &nbspThe behavior when `c` or `r` is a scalar, or when `c` is complex and
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp`r` is None, was changed in version 0.8.0.  The behavior in previous</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp`r` is None, was changed in version 0.8.0. The behavior in previous</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspversions was undocumented and is no longer supported.
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspExamples
<br>@@ -194,14 +191,12 @@ def toeplitz(c, r=None):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspr = c.conjugate()
<br>&nbsp &nbsp &nbsp &nbsp &nbspelse:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspr = np.asarray(r).ravel()
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp# Form a 1D array of values to be used in the matrix, containing a reversed</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp# copy of r[1:], followed by c.</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspvals = np.concatenate((r[-1:0:-1], c))</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspa, b = np.ogrid[0:len(c), len(r) - 1:-1:-1]</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspindx = a + b</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp# `indx` is a 2D array of indices into the 1D array `vals`, arranged so</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp# that `vals[indx]` is the Toeplitz matrix.</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspreturn vals[indx]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp# Form a 1-D array containing a reversed c followed by r[1:] that could be</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp# strided to give us toeplitz matrix.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspvals = np.concatenate((c[::-1], r[1:]))</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspout_shp = len(c), len(r)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspn = vals.strides[0]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspreturn as_strided(vals[len(c)-1:], shape=out_shp, strides=(-n, n)).copy()</span>
<br>&nbsp
<br>&nbsp
<br>&nbspdef circulant(c):
<br>@@ -238,11 +233,11 @@ def circulant(c):
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp &nbsp &nbsp &nbsp &nbspc = np.asarray(c).ravel()
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspa, b = np.ogrid[0:len(c), 0:-len(c):-1]</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspindx = a + b</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp# `indx` is a 2D array of indices into `c`, arranged so that `c[indx]` is</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp# the circulant matrix.</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspreturn c[indx]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp# Form an extended array that could be strided to give circulant version</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspc_ext = np.concatenate((c[::-1], c[:0:-1]))</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspL = len(c)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspn = c_ext.strides[0]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspreturn as_strided(c_ext[L-1:], shape=(L, L), strides=(-n, n)).copy()</span>
<br>&nbsp
<br>&nbsp
<br>&nbspdef hankel(c, r=None):
<br>@@ -250,18 +245,18 @@ def hankel(c, r=None):
<br>&nbsp &nbsp &nbsp &nbsp &nbspConstruct a Hankel matrix.
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspThe Hankel matrix has constant anti-diagonals, with `c` as its
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspfirst column and `r` as its last row.  If `r` is not given, then</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspfirst column and `r` as its last row. If `r` is not given, then</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp`r = zeros_like(c)` is assumed.
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>&nbsp &nbsp &nbsp &nbsp &nbspc : array_like
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspFirst column of the matrix.  Whatever the actual shape of `c`, it</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspFirst column of the matrix. Whatever the actual shape of `c`, it</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspwill be converted to a 1-D array.
<br>&nbsp &nbsp &nbsp &nbsp &nbspr : array_like, optional
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspLast row of the matrix. If None, ``r = zeros_like(c)`` is assumed.
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspr[0] is ignored; the last row of the returned matrix is
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp``[c[-1], r[1:]]``.  Whatever the actual shape of `r`, it will be</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp``[c[-1], r[1:]]``. Whatever the actual shape of `r`, it will be</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspconverted to a 1-D array.
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspReturns
<br>@@ -293,27 +288,26 @@ def hankel(c, r=None):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspr = np.zeros_like(c)
<br>&nbsp &nbsp &nbsp &nbsp &nbspelse:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspr = np.asarray(r).ravel()
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp# Form a 1D array of values to be used in the matrix, containing `c`</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp# Form a 1-D array of values to be used in the matrix, containing `c`</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp# followed by r[1:].
<br>&nbsp &nbsp &nbsp &nbsp &nbspvals = np.concatenate((c, r[1:]))
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspa, b = np.ogrid[0:len(c), 0:len(r)]</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspindx = a + b</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp# `indx` is a 2D array of indices into the 1D array `vals`, arranged so</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp# that `vals[indx]` is the Hankel matrix.</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspreturn vals[indx]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp# Stride on concatenated array to get hankel matrix</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspout_shp = len(c), len(r)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspn = vals.strides[0]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspreturn as_strided(vals, shape=out_shp, strides=(n, n)).copy()</span>
<br>&nbsp
<br>&nbsp
<br>&nbspdef hadamard(n, dtype=int):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspConstruct a Hadamard matrix.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspConstruct an Hadamard matrix.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspConstructs an n-by-n Hadamard matrix, using Sylvester's
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspconstruction.  `n` must be a power of 2.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspconstruction. `n` must be a power of 2.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>&nbsp &nbsp &nbsp &nbsp &nbspn : int
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThe order of the matrix.  `n` must be a power of 2.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThe order of the matrix. `n` must be a power of 2.</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspdtype : dtype, optional
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThe data type of the array to be constructed.
<br>&nbsp
<br>@@ -365,7 +359,8 @@ def leslie(f, s):
<br>&nbsp &nbsp &nbsp &nbsp &nbspCreate a Leslie matrix.
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspGiven the length n array of fecundity coefficients `f` and the length
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspn-1 array of survival coefficents `s`, return the associated Leslie matrix.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspn-1 array of survival coefficients `s`, return the associated Leslie</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspmatrix.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -414,9 +409,9 @@ def leslie(f, s):
<br>&nbsp &nbsp &nbsp &nbsp &nbspf = np.atleast_1d(f)
<br>&nbsp &nbsp &nbsp &nbsp &nbsps = np.atleast_1d(s)
<br>&nbsp &nbsp &nbsp &nbsp &nbspif f.ndim != 1:
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("Incorrect shape for f.  f must be one-dimensional")</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("Incorrect shape for f.  f must be 1D")</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspif s.ndim != 1:
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("Incorrect shape for s.  s must be one-dimensional")</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("Incorrect shape for s.  s must be 1D")</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspif f.size != s.size + 1:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("Incorrect lengths for f and s.  The length"
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp" of s must be one less than the length of f.")
<br>@@ -492,7 +487,7 @@ def block_diag(*arrs):
<br>&nbsp &nbsp &nbsp &nbsp &nbspReturns
<br>&nbsp &nbsp &nbsp &nbsp &nbsp-------
<br>&nbsp &nbsp &nbsp &nbsp &nbspD : ndarray
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspArray with `A`, `B`, `C`, ... on the diagonal.  `D` has the</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspArray with `A`, `B`, `C`, ... on the diagonal. `D` has the</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsame dtype as `A`.
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspNotes
<br>@@ -564,7 +559,7 @@ def companion(a):
<br>&nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>&nbsp &nbsp &nbsp &nbsp &nbspa : (N,) array_like
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp1-D array of polynomial coefficients.  The length of `a` must be</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp1-D array of polynomial coefficients. The length of `a` must be</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspat least two, and ``a[0]`` must not be zero.
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspReturns
<br>@@ -620,7 +615,7 @@ def companion(a):
<br>&nbsp
<br>&nbspdef helmert(n, full=False):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspCreate a Helmert matrix of order `n`.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspCreate an Helmert matrix of order `n`.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspThis has applications in statistics, compositional or simplicial analysis,
<br>&nbsp &nbsp &nbsp &nbsp &nbspand in Aitchison geometry.
<br>@@ -705,9 +700,9 @@ def invhilbert(n, exact=False):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp &nbsp &nbsp &nbsp &nbspCompute the inverse of the Hilbert matrix of order `n`.
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspThe entries in the inverse of a Hilbert matrix are integers.  When `n`</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspThe entries in the inverse of a Hilbert matrix are integers. When `n`</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspis greater than 14, some entries in the inverse exceed the upper limit
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspof 64 bit integers.  The `exact` argument provides two options for</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspof 64 bit integers. The `exact` argument provides two options for</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspdealing with these large integers.
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>@@ -717,9 +712,9 @@ def invhilbert(n, exact=False):
<br>&nbsp &nbsp &nbsp &nbsp &nbspexact : bool, optional
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf False, the data type of the array that is returned is np.float64,
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspand the array is an approximation of the inverse.
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf True, the array is the exact integer inverse array.  To represent</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf True, the array is the exact integer inverse array. To represent</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspthe exact inverse when n > 14, the returned array is an object array
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspof long integers.  For n <= 14, the exact inverse is returned as an</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspof long integers. For n <= 14, the exact inverse is returned as an</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsparray with data type np.int64.
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspReturns
<br>@@ -727,7 +722,7 @@ def invhilbert(n, exact=False):
<br>&nbsp &nbsp &nbsp &nbsp &nbspinvh : (n, n) ndarray
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThe data type of the array is np.float64 if `exact` is False.
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf `exact` is True, the data type is either np.int64 (for n <= 14)
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspor object (for n > 14).  In the latter case, the objects in the</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspor object (for n > 14). In the latter case, the objects in the</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsparray will be long integers.
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspSee Also
<br>@@ -754,7 +749,7 @@ def invhilbert(n, exact=False):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp>>> invhilbert(16)[7,7]
<br>&nbsp &nbsp &nbsp &nbsp &nbsp4.2475099528537506e+19
<br>&nbsp &nbsp &nbsp &nbsp &nbsp>>> invhilbert(16, exact=True)[7,7]
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp42475099528537378560L</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp42475099528537378560</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp &nbsp &nbsp &nbsp &nbspfrom scipy.special import comb
<br>@@ -766,8 +761,8 @@ def invhilbert(n, exact=False):
<br>&nbsp &nbsp &nbsp &nbsp &nbspelse:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdtype = np.float64
<br>&nbsp &nbsp &nbsp &nbsp &nbspinvh = np.empty((n, n), dtype=dtype)
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspfor i in xrange(n):</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspfor j in xrange(0, i + 1):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspfor i in range(n):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspfor j in range(0, i + 1):</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsps = i + j
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspinvh[i, j] = ((-1) ** s * (s + 1) *
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcomb(n + i, n - j - 1, exact) *
<br>@@ -797,7 +792,7 @@ def pascal(n, kind='symmetric', exact=True):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf `exact` is True, the result is either an array of type
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspnumpy.uint64 (if n < 35) or an object array of Python long integers.
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf `exact` is False, the coefficients in the matrix are computed using
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp`scipy.special.comb` with `exact=False`.  The result will be a floating</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp`scipy.special.comb` with `exact=False`. The result will be a floating</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsppoint array, and the values in the array will not be the exact
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcoefficients, but this version is much faster than `exact=True`.
<br>&nbsp
<br>@@ -812,7 +807,7 @@ def pascal(n, kind='symmetric', exact=True):
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspNotes
<br>&nbsp &nbsp &nbsp &nbsp &nbsp-----
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspSee http://en.wikipedia.org/wiki/Pascal_matrix for more information</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspSee https://en.wikipedia.org/wiki/Pascal_matrix for more information</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspabout Pascal matrices.
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp.. versionadded:: 0.11.0
<br>@@ -831,10 +826,10 @@ def pascal(n, kind='symmetric', exact=True):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[1, 2, 1, 0],
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[1, 3, 3, 1]], dtype=uint64)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp>>> pascal(50)[-1, -1]
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp25477612258980856902730428600L</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp25477612258980856902730428600</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp>>> from scipy.special import comb
<br>&nbsp &nbsp &nbsp &nbsp &nbsp>>> comb(98, 49, exact=True)
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp25477612258980856902730428600L</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp25477612258980856902730428600</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp
<br>@@ -881,9 +876,9 @@ def invpascal(n, kind='symmetric', exact=True):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspDefault is 'symmetric'.
<br>&nbsp &nbsp &nbsp &nbsp &nbspexact : bool, optional
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf `exact` is True, the result is either an array of type
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp`numpy.int64` (if `n` <= 35) or an object array of Python integers.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp``numpy.int64`` (if `n` <= 35) or an object array of Python integers.</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf `exact` is False, the coefficients in the matrix are computed using
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp`scipy.special.comb` with `exact=False`.  The result will be a floating</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp`scipy.special.comb` with `exact=False`. The result will be a floating</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsppoint array, and for large `n`, the values in the array will not be the
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspexact coefficients.
<br>&nbsp
<br>@@ -903,7 +898,7 @@ def invpascal(n, kind='symmetric', exact=True):
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspReferences
<br>&nbsp &nbsp &nbsp &nbsp &nbsp----------
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp.. [1] "Pascal matrix",  http://en.wikipedia.org/wiki/Pascal_matrix</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp.. [1] "Pascal matrix", https://en.wikipedia.org/wiki/Pascal_matrix</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp.. [2] Cohen, A. M., "The inverse of a Pascal matrix", Mathematical
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspGazette, 59(408), pp. 111-112, 1975.
<br>&nbsp
<br>@@ -979,7 +974,7 @@ def dft(n, scale=None):
<br>&nbsp &nbsp &nbsp &nbsp &nbspDiscrete Fourier transform matrix.
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspCreate the matrix that computes the discrete Fourier transform of a
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspsequence [1]_.  The n-th primitive root of unity used to generate the</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspsequence [1]_. The nth primitive root of unity used to generate the</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspmatrix is exp(-2*pi*i/n), where i = sqrt(-1).
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>@@ -1002,30 +997,34 @@ def dft(n, scale=None):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp-----
<br>&nbsp &nbsp &nbsp &nbsp &nbspWhen `scale` is None, multiplying a vector by the matrix returned by
<br>&nbsp &nbsp &nbsp &nbsp &nbsp`dft` is mathematically equivalent to (but much less efficient than)
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspthe calculation performed by `scipy.fftpack.fft`.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspthe calculation performed by `scipy.fft.fft`.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp.. versionadded:: 0.14.0
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspReferences
<br>&nbsp &nbsp &nbsp &nbsp &nbsp----------
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp.. [1] "DFT matrix", http://en.wikipedia.org/wiki/DFT_matrix</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp.. [1] "DFT matrix", https://en.wikipedia.org/wiki/DFT_matrix</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspExamples
<br>&nbsp &nbsp &nbsp &nbsp &nbsp--------
<br>&nbsp &nbsp &nbsp &nbsp &nbsp>>> from scipy.linalg import dft
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp>>> np.set_printoptions(precision=5, suppress=True)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp>>> x = np.array([1, 2, 3, 0, 3, 2, 1, 0])</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp>>> m = dft(8)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp>>> m.dot(x)   # Compute the DFT of x</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsparray([ 12.+0.j,  -2.-2.j,   0.-4.j,  -2.+2.j,   4.+0.j,  -2.-2.j,</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp-0.+4.j,  -2.+2.j])</span>
<br><span style="color:red">- </span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspVerify that ``m.dot(x)`` is the same as ``fft(x)``.</span>
<br><span style="color:red">- </span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp>>> from scipy.fftpack import fft</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp>>> fft(x)     # Same result as m.dot(x)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsparray([ 12.+0.j,  -2.-2.j,   0.-4.j,  -2.+2.j,   4.+0.j,  -2.-2.j,</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp0.+4.j,  -2.+2.j])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> np.set_printoptions(precision=2, suppress=True)  # for compact output</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> m = dft(5)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> m</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsparray([[ 1.  +0.j  ,  1.  +0.j  ,  1.  +0.j  ,  1.  +0.j  ,  1.  +0.j  ],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[ 1.  +0.j  ,  0.31-0.95j, -0.81-0.59j, -0.81+0.59j,  0.31+0.95j],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[ 1.  +0.j  , -0.81-0.59j,  0.31+0.95j,  0.31-0.95j, -0.81+0.59j],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[ 1.  +0.j  , -0.81+0.59j,  0.31-0.95j,  0.31+0.95j, -0.81-0.59j],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[ 1.  +0.j  ,  0.31+0.95j, -0.81+0.59j, -0.81-0.59j,  0.31-0.95j]])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> x = np.array([1, 2, 3, 0, 3])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> m @ x  # Compute the DFT of x</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsparray([ 9.  +0.j  ,  0.12-0.81j, -2.12+3.44j, -2.12-3.44j,  0.12+0.81j])</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspVerify that ``m @ x`` is the same as ``fft(x)``.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> from scipy.fft import fft</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> fft(x)     # Same result as m @ x</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsparray([ 9.  +0.j  ,  0.12-0.81j, -2.12+3.44j, -2.12-3.44j,  0.12+0.81j])</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp &nbsp &nbsp &nbsp &nbspif scale not in [None, 'sqrtn', 'n']:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("scale must be None, 'sqrtn', or 'n'; "
<br>@@ -1038,3 +1037,338 @@ def dft(n, scale=None):
<br>&nbsp &nbsp &nbsp &nbsp &nbspelif scale == 'n':
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspm /= n
<br>&nbsp &nbsp &nbsp &nbsp &nbspreturn m
<br><span style="color:green">+</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+def fiedler(a):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp"""Returns a symmetric Fiedler matrix</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspGiven an sequence of numbers `a`, Fiedler matrices have the structure</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp``F[i, j] = np.abs(a[i] - a[j])``, and hence zero diagonals and nonnegative</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspentries. A Fiedler matrix has a dominant positive eigenvalue and other</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspeigenvalues are negative. Although not valid generally, for certain inputs,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspthe inverse and the determinant can be derived explicitly as given in [1]_.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspParameters</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp----------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspa : (n,) array_like</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcoefficient array</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspReturns</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp-------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspF : (n, n) ndarray</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspSee Also</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp--------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspcirculant, toeplitz</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspNotes</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp-----</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp.. versionadded:: 1.3.0</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspReferences</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp----------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp.. [1] J. Todd, "Basic Numerical Mathematics: Vol.2 : Numerical Algebra",</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp1977, Birkhauser, :doi:`10.1007/978-3-0348-7286-7`</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspExamples</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp--------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> from scipy.linalg import det, inv, fiedler</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> a = [1, 4, 12, 45, 77]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> n = len(a)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> A = fiedler(a)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> A</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsparray([[ 0,  3, 11, 44, 76],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[ 3,  0,  8, 41, 73],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[11,  8,  0, 33, 65],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[44, 41, 33,  0, 32],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[76, 73, 65, 32,  0]])</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspThe explicit formulas for determinant and inverse seem to hold only for</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspmonotonically increasing/decreasing arrays. Note the tridiagonal structure</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspand the corners.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> Ai = inv(A)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> Ai[np.abs(Ai) < 1e-12] = 0.  # cleanup the numerical noise for display</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> Ai</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsparray([[-0.16008772,  0.16666667,  0.        ,  0.        ,  0.00657895],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[ 0.16666667, -0.22916667,  0.0625    ,  0.        ,  0.        ],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[ 0.        ,  0.0625    , -0.07765152,  0.01515152,  0.        ],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[ 0.        ,  0.        ,  0.01515152, -0.03077652,  0.015625  ],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[ 0.00657895,  0.        ,  0.        ,  0.015625  , -0.00904605]])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> det(A)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp15409151.999999998</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> (-1)**(n-1) * 2**(n-2) * np.diff(a).prod() * (a[-1] - a[0])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp15409152</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspa = np.atleast_1d(a)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspif a.ndim != 1:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("Input 'a' must be a 1D array.")</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspif a.size == 0:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn np.array([], dtype=float)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspelif a.size == 1:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn np.array([[0.]])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspelse:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn np.abs(a[:, None] - a)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+def fiedler_companion(a):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp""" Returns a Fiedler companion matrix</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspGiven a polynomial coefficient array ``a``, this function forms a</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsppentadiagonal matrix with a special structure whose eigenvalues coincides</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspwith the roots of ``a``.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspParameters</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp----------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspa : (N,) array_like</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp1-D array of polynomial coefficients in descending order with a nonzero</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspleading coefficient. For ``N < 2``, an empty array is returned.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspReturns</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp-------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspc : (N-1, N-1) ndarray</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspResulting companion matrix</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspNotes</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp-----</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspSimilar to `companion` the leading coefficient should be nonzero. In the case</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspthe leading coefficient is not 1, other coefficients are rescaled before</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspthe array generation. To avoid numerical issues, it is best to provide a</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspmonic polynomial.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp.. versionadded:: 1.3.0</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspSee Also</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp--------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspcompanion</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspReferences</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp----------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp.. [1] M. Fiedler, " A note on companion matrices", Linear Algebra and its</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspApplications, 2003, :doi:`10.1016/S0024-3795(03)00548-2`</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspExamples</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp--------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> from scipy.linalg import fiedler_companion, eigvals</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> p = np.poly(np.arange(1, 9, 2))  # [1., -16., 86., -176., 105.]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> fc = fiedler_companion(p)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> fc</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsparray([[  16.,  -86.,    1.,    0.],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[   1.,    0.,    0.,    0.],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[   0.,  176.,    0., -105.],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[   0.,    1.,    0.,    0.]])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> eigvals(fc)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsparray([7.+0.j, 5.+0.j, 3.+0.j, 1.+0.j])</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspa = np.atleast_1d(a)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspif a.ndim != 1:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("Input 'a' must be a 1-D array.")</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspif a.size <= 2:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif a.size == 2:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn np.array([[-(a/a[0])[-1]]])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn np.array([], dtype=a.dtype)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspif a[0] == 0.:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError('Leading coefficient is zero.')</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspa = a/a[0]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspn = a.size - 1</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspc = np.zeros((n, n), dtype=a.dtype)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp# subdiagonals</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspc[range(3, n, 2), range(1, n-2, 2)] = 1.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspc[range(2, n, 2), range(1, n-1, 2)] = -a[3::2]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp# superdiagonals</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspc[range(0, n-2, 2), range(2, n, 2)] = 1.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspc[range(0, n-1, 2), range(1, n, 2)] = -a[2::2]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspc[[0, 1], 0] = [-a[1], 1]</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspreturn c</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+def convolution_matrix(a, n, mode='full'):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspConstruct a convolution matrix.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspConstructs the Toeplitz matrix representing one-dimensional</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspconvolution [1]_.  See the notes below for details.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspParameters</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp----------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspa : (m,) array_like</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThe 1-D array to convolve.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspn : int</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThe number of columns in the resulting matrix.  It gives the length</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspof the input to be convolved with `a`.  This is analogous to the</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsplength of `v` in ``numpy.convolve(a, v)``.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspmode : str</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThis is analogous to `mode` in ``numpy.convolve(v, a, mode)``.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIt must be one of ('full', 'valid', 'same').</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspSee below for how `mode` determines the shape of the result.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspReturns</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp-------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspA : (k, n) ndarray</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThe convolution matrix whose row count `k` depends on `mode`::</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp=======  =========================</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmode    k</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp=======  =========================</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp'full'   m + n -1</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp'same'   max(m, n)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp'valid'  max(m, n) - min(m, n) + 1</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp=======  =========================</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspSee Also</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp--------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsptoeplitz : Toeplitz matrix</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspNotes</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp-----</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspThe code::</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspA = convolution_matrix(a, n, mode)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspcreates a Toeplitz matrix `A` such that ``A @ v`` is equivalent to</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspusing ``convolve(a, v, mode)``.  The returned array always has `n`</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspcolumns.  The number of rows depends on the specified `mode`, as</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspexplained above.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspIn the default 'full' mode, the entries of `A` are given by::</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspA[i, j] == (a[i-j] if (0 <= (i-j) < m) else 0)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspwhere ``m = len(a)``.  Suppose, for example, the input array is</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp``[x, y, z]``.  The convolution matrix has the form::</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[x, 0, 0, ..., 0, 0]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[y, x, 0, ..., 0, 0]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[z, y, x, ..., 0, 0]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp...</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[0, 0, 0, ..., x, 0]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[0, 0, 0, ..., y, x]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[0, 0, 0, ..., z, y]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[0, 0, 0, ..., 0, z]</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspIn 'valid' mode, the entries of `A` are given by::</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspA[i, j] == (a[i-j+m-1] if (0 <= (i-j+m-1) < m) else 0)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspThis corresponds to a matrix whose rows are the subset of those from</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspthe 'full' case where all the coefficients in `a` are contained in the</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsprow.  For input ``[x, y, z]``, this array looks like::</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[z, y, x, 0, 0, ..., 0, 0, 0]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[0, z, y, x, 0, ..., 0, 0, 0]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[0, 0, z, y, x, ..., 0, 0, 0]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp...</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[0, 0, 0, 0, 0, ..., x, 0, 0]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[0, 0, 0, 0, 0, ..., y, x, 0]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[0, 0, 0, 0, 0, ..., z, y, x]</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspIn the 'same' mode, the entries of `A` are given by::</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspd = (m - 1) // 2</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspA[i, j] == (a[i-j+d] if (0 <= (i-j+d) < m) else 0)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspThe typical application of the 'same' mode is when one has a signal of</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsplength `n` (with `n` greater than ``len(a)``), and the desired output</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspis a filtered signal that is still of length `n`.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspFor input ``[x, y, z]``, this array looks like::</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[y, x, 0, 0, ..., 0, 0, 0]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[z, y, x, 0, ..., 0, 0, 0]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[0, z, y, x, ..., 0, 0, 0]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[0, 0, z, y, ..., 0, 0, 0]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp...</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[0, 0, 0, 0, ..., y, x, 0]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[0, 0, 0, 0, ..., z, y, x]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[0, 0, 0, 0, ..., 0, z, y]</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp.. versionadded:: 1.5.0</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspReferences</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp----------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp.. [1] "Convolution", https://en.wikipedia.org/wiki/Convolution</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspExamples</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp--------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> from scipy.linalg import convolution_matrix</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> A = convolution_matrix([-1, 4, -2], 5, mode='same')</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> A</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsparray([[ 4, -1,  0,  0,  0],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[-2,  4, -1,  0,  0],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[ 0, -2,  4, -1,  0],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[ 0,  0, -2,  4, -1],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[ 0,  0,  0, -2,  4]])</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspCompare multiplication by `A` with the use of `numpy.convolve`.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> x = np.array([1, 2, 0, -3, 0.5])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> A @ x</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsparray([  2. ,   6. ,  -1. , -12.5,   8. ])</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspVerify that ``A @ x`` produced the same result as applying the</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspconvolution function.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> np.convolve([-1, 4, -2], x, mode='same')</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsparray([  2. ,   6. ,  -1. , -12.5,   8. ])</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspFor comparison to the case ``mode='same'`` shown above, here are the</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspmatrices produced by ``mode='full'`` and ``mode='valid'`` for the</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspsame coefficients and size.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> convolution_matrix([-1, 4, -2], 5, mode='full')</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsparray([[-1,  0,  0,  0,  0],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[ 4, -1,  0,  0,  0],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[-2,  4, -1,  0,  0],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[ 0, -2,  4, -1,  0],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[ 0,  0, -2,  4, -1],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[ 0,  0,  0, -2,  4],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[ 0,  0,  0,  0, -2]])</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> convolution_matrix([-1, 4, -2], 5, mode='valid')</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsparray([[-2,  4, -1,  0,  0],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[ 0, -2,  4, -1,  0],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[ 0,  0, -2,  4, -1]])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspif n <= 0:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError('n must be a positive integer.')</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspa = np.asarray(a)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspif a.ndim != 1:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError('convolution_matrix expects a one-dimensional '</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp'array as input')</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspif a.size == 0:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError('len(a) must be at least 1.')</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspif mode not in ('full', 'valid', 'same'):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError(</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"'mode' argument must be one of ('full', 'valid', 'same')")</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp# create zero padded versions of the array</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspaz = np.pad(a, (0, n-1), 'constant')</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspraz = np.pad(a[::-1], (0, n-1), 'constant')</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspif mode == 'same':</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsptrim = min(n, len(a)) - 1</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsptb = trim//2</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspte = trim - tb</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcol0 = az[tb:len(az)-te]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprow0 = raz[-n-tb:len(raz)-tb]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspelif mode == 'valid':</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsptb = min(n, len(a)) - 1</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspte = tb</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcol0 = az[tb:len(az)-te]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprow0 = raz[-n-tb:len(raz)-tb]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspelse:  # 'full'</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcol0 = az</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprow0 = raz[-n:]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspreturn toeplitz(col0, row0)</span>
<br></p>
</div>
<br><br><br>
<br>
<script>
var coll = document.getElementsByClassName("collapsible");
var i;

for (i = 0; i < coll.length; i++) {
  coll[i].addEventListener("click", function() {
    this.classList.toggle("active");
    var content = this.nextElementSibling;
    if (content.style.display === "block") {
      content.style.display = "none";
    } else {
      content.style.display = "block";
    }
  });
}
</script>
</body>
</html>