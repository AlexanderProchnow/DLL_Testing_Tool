
    <!DOCTYPE html>
    <html>
    <head>
    <style>
    .collapsible {
      background-color: #777;
      color: white;
      cursor: pointer;
      padding: 18px;
      width: 100%;
      border: none;
      text-align: left;
      outline: none;
      font-size: 15px;
    }

    .active, .collapsible:hover {
      background-color: #555;
    }

    .content {
      padding: 0 18px;
      display: none;
      overflow: hidden;
      background-color: #f1f1f1;
    }
    </style>
    </head>
    <body>


 <br>Commit id closest to current version: eaa2fdef699ba0b81a75434f6483891f11cc116f
<br>Date: 30-Dec-2017

 <br>Commit message: BUG: optimize: fix bug related with function call calculation for Brent algorithm<br><br>
<br>Commit id closest to desired version: bf0806b0c5a09e1e0b6bea89f01aa5659e256cec
<br>Date: 10-Sep-2021

 <br>Commit message: ENH: optimize std in scipy.stats.binned_statistic (#14629)<br><br><br>
<br>_____________________________________scipy/sparse/construct.py_________________________________________
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>File_Path</th>
      <th>Line_Number</th>
      <th>Found_in_Function</th>
      <th>Function_Definition_Line_Number</th>
      <th>Assert_Statement_Type</th>
      <th>Oracle_Argument_ Position</th>
      <th>Differential_Function_Line_Number</th>
      <th>Differential_Test_Function</th>
      <th>Extracted_Function_File_Location</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>12828</th>
      <td>keras\backend_test.py</td>
      <td>350</td>
      <td>test_sparse_variable</td>
      <td>347</td>
      <td>assertTrue</td>
      <td>1</td>
      <td>348</td>
      <td>scipy.sparse.eye</td>
      <td>scipy/sparse/construct.py</td>
    </tr>
  </tbody>
</table>
<br><button type="button" class="collapsible">Git Diff</button>
<div class="content">
<p>diff --git a/scipy/sparse/construct.py b/scipy/sparse/construct.py
<br>index b6d788795..f4c93d562 100644
<br><span style="color:red">- -- a/scipy/sparse/construct.py</span>
<br><span style="color:green">+++ b/scipy/sparse/construct.py</span>
<br>@@ -1,17 +1,16 @@
<br>&nbsp"""Functions to construct sparse matrices
<br>&nbsp"""
<br><span style="color:red">- from __future__ import division, print_function, absolute_import</span>
<br>&nbsp
<br>&nbsp__docformat__ = "restructuredtext en"
<br>&nbsp
<br>&nbsp__all__ = ['spdiags', 'eye', 'identity', 'kron', 'kronsum',
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp'hstack', 'vstack', 'bmat', 'rand', 'random', 'diags', 'block_diag']
<br>&nbsp
<br><span style="color:red">- </span>
<br><span style="color:green">+import numbers</span>
<br><span style="color:green">+from functools import partial</span>
<br>&nbspimport numpy as np
<br>&nbsp
<br><span style="color:red">- from scipy._lib.six import xrange</span>
<br><span style="color:red">- </span>
<br><span style="color:green">+from scipy._lib._util import check_random_state, rng_integers</span>
<br>&nbspfrom .sputils import upcast, get_index_dtype, isscalarlike
<br>&nbsp
<br>&nbspfrom .csr import csr_matrix
<br>@@ -39,7 +38,7 @@ def spdiags(data, diags, m, n, format=None):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspshape of the result
<br>&nbsp &nbsp &nbsp &nbsp &nbspformat : str, optional
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspFormat of the result. By default (format=None) an appropriate sparse
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmatrix format is returned.  This choice is subject to change.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmatrix format is returned. This choice is subject to change.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspSee Also
<br>&nbsp &nbsp &nbsp &nbsp &nbsp--------
<br>@@ -73,14 +72,14 @@ def diags(diagonals, offsets=0, shape=None, format=None, dtype=None):
<br>&nbsp &nbsp &nbsp &nbsp &nbspoffsets : sequence of int or an int, optional
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspDiagonals to set:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp- k = 0  the main diagonal (default)
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp- k > 0  the k-th upper diagonal</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp- k < 0  the k-th lower diagonal</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp- k > 0  the kth upper diagonal</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp- k < 0  the kth lower diagonal</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspshape : tuple of int, optional
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspShape of the result. If omitted, a square matrix large enough
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspto contain the diagonals is returned.
<br>&nbsp &nbsp &nbsp &nbsp &nbspformat : {"dia", "csr", "csc", "lil", ...}, optional
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspMatrix format of the result.  By default (format=None) an</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspappropriate sparse matrix format is returned.  This choice is</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspMatrix format of the result. By default (format=None) an</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspappropriate sparse matrix format is returned. This choice is</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsubject to change.
<br>&nbsp &nbsp &nbsp &nbsp &nbspdtype : dtype, optional
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspData type of the matrix.
<br>@@ -176,12 +175,12 @@ def diags(diagonals, offsets=0, shape=None, format=None, dtype=None):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("Offset %d (index %d) out of bounds" % (offset, j))
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsptry:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdata_arr[j, k:k+length] = diagonal[...,:length]
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspexcept ValueError:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspexcept ValueError as e:</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif len(diagonal) != length and len(diagonal) != 1:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError(
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"Diagonal length (index %d: %d at offset %d) does not "
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"agree with matrix size (%d, %d)." % (
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspj, len(diagonal), offset, m, n))</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspj, len(diagonal), offset, m, n)) from e</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspreturn dia_matrix((data_arr, offsets), shape=(m, n)).asformat(format)
<br>@@ -200,7 +199,7 @@ def identity(n, dtype='d', format=None):
<br>&nbsp &nbsp &nbsp &nbsp &nbspdtype : dtype, optional
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspData type of the matrix
<br>&nbsp &nbsp &nbsp &nbsp &nbspformat : str, optional
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspSparse format of the result, e.g. format="csr", etc.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspSparse format of the result, e.g., format="csr", etc.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspExamples
<br>&nbsp &nbsp &nbsp &nbsp &nbsp--------
<br>@@ -220,7 +219,7 @@ def identity(n, dtype='d', format=None):
<br>&nbspdef eye(m, n=None, k=0, dtype=float, format=None):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""Sparse matrix with ones on diagonal
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspReturns a sparse (m x n) matrix where the k-th diagonal</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspReturns a sparse (m x n) matrix where the kth diagonal</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspis all ones and everything else is zeros.
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>@@ -234,7 +233,7 @@ def eye(m, n=None, k=0, dtype=float, format=None):
<br>&nbsp &nbsp &nbsp &nbsp &nbspdtype : dtype, optional
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspData type of the matrix.
<br>&nbsp &nbsp &nbsp &nbsp &nbspformat : str, optional
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspSparse format of the result, e.g. format="csr", etc.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspSparse format of the result, e.g., format="csr", etc.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspExamples
<br>&nbsp &nbsp &nbsp &nbsp &nbsp--------
<br>@@ -317,7 +316,7 @@ def kron(A, B, format=None):
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif A.nnz == 0 or B.nnz == 0:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# kronecker product is the zero matrix
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn coo_matrix(output_shape)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn coo_matrix(output_shape).asformat(format)</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspB = B.toarray()
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdata = A.data.repeat(B.size).reshape(-1,B.shape[0],B.shape[1])
<br>@@ -331,13 +330,17 @@ def kron(A, B, format=None):
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif A.nnz == 0 or B.nnz == 0:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# kronecker product is the zero matrix
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn coo_matrix(output_shape)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn coo_matrix(output_shape).asformat(format)</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# expand entries of a into blocks
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprow = A.row.repeat(B.nnz)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcol = A.col.repeat(B.nnz)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdata = A.data.repeat(B.nnz)
<br>&nbsp
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif max(A.shape[0]*B.shape[0], A.shape[1]*B.shape[1]) > np.iinfo('int32').max:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprow = row.astype(np.int64)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcol = col.astype(np.int64)</span>
<br><span style="color:green">+</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprow *= B.shape[0]
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcol *= B.shape[1]
<br>&nbsp
<br>@@ -360,7 +363,7 @@ def kronsum(A, B, format=None):
<br>&nbsp &nbsp &nbsp &nbsp &nbspKronecker sum of two sparse matrices is a sum of two Kronecker
<br>&nbsp &nbsp &nbsp &nbsp &nbspproducts kron(I_n,A) + kron(B,I_m) where A has shape (m,m)
<br>&nbsp &nbsp &nbsp &nbsp &nbspand B has shape (n,n) and I_m and I_n are identity matrices
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspof shape (m,m) and (n,n) respectively.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspof shape (m,m) and (n,n), respectively.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -440,11 +443,11 @@ def hstack(blocks, format=None, dtype=None):
<br>&nbsp &nbsp &nbsp &nbsp &nbspblocks
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsequence of sparse matrices with compatible shapes
<br>&nbsp &nbsp &nbsp &nbsp &nbspformat : str
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsparse format of the result (e.g. "csr")</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsparse format of the result (e.g., "csr")</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspby default an appropriate sparse matrix format is returned.
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThis choice is subject to change.
<br>&nbsp &nbsp &nbsp &nbsp &nbspdtype : dtype, optional
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThe data-type of the output matrix.  If not given, the dtype is</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThe data-type of the output matrix. If not given, the dtype is</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdetermined from that of `blocks`.
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspSee Also
<br>@@ -473,11 +476,11 @@ def vstack(blocks, format=None, dtype=None):
<br>&nbsp &nbsp &nbsp &nbsp &nbspblocks
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsequence of sparse matrices with compatible shapes
<br>&nbsp &nbsp &nbsp &nbsp &nbspformat : str, optional
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsparse format of the result (e.g. "csr")</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsparse format of the result (e.g., "csr")</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspby default an appropriate sparse matrix format is returned.
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThis choice is subject to change.
<br>&nbsp &nbsp &nbsp &nbsp &nbspdtype : dtype, optional
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThe data-type of the output matrix.  If not given, the dtype is</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThe data-type of the output matrix. If not given, the dtype is</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdetermined from that of `blocks`.
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspSee Also
<br>@@ -508,11 +511,11 @@ def bmat(blocks, format=None, dtype=None):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspGrid of sparse matrices with compatible shapes.
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspAn entry of None implies an all-zero matrix.
<br>&nbsp &nbsp &nbsp &nbsp &nbspformat : {'bsr', 'coo', 'csc', 'csr', 'dia', 'dok', 'lil'}, optional
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThe sparse format of the result (e.g. "csr").  By default an</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThe sparse format of the result (e.g. "csr"). By default an</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspappropriate sparse matrix format is returned.
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThis choice is subject to change.
<br>&nbsp &nbsp &nbsp &nbsp &nbspdtype : dtype, optional
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThe data-type of the output matrix.  If not given, the dtype is</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThe data-type of the output matrix. If not given, the dtype is</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdetermined from that of `blocks`.
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspReturns
<br>@@ -631,10 +634,10 @@ def block_diag(mats, format=None, dtype=None):
<br>&nbsp &nbsp &nbsp &nbsp &nbspmats : sequence of matrices
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspInput matrices.
<br>&nbsp &nbsp &nbsp &nbsp &nbspformat : str, optional
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThe sparse format of the result (e.g. "csr").  If not given, the matrix</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThe sparse format of the result (e.g., "csr"). If not given, the matrix</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspis returned in "coo" format.
<br>&nbsp &nbsp &nbsp &nbsp &nbspdtype : dtype specifier, optional
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThe data-type of the output matrix.  If not given, the dtype is</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThe data-type of the output matrix. If not given, the dtype is</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdetermined from that of `blocks`.
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspReturns
<br>@@ -664,16 +667,33 @@ def block_diag(mats, format=None, dtype=None):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[0, 0, 0, 7]])
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspnmat = len(mats)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsprows = []</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspfor ia, a in enumerate(mats):</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprow = [None]*nmat</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsprow = []</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspcol = []</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdata = []</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspr_idx = 0</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspc_idx = 0</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspfor a in mats:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif isinstance(a, (list, numbers.Number)):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspa = coo_matrix(a)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspnrows, ncols = a.shape</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif issparse(a):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprow[ia] = a</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspa = a.tocoo()</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprow.append(a.row + r_idx)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcol.append(a.col + c_idx)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdata.append(a.data)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelse:
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprow[ia] = coo_matrix(a)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprows.append(row)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspreturn bmat(rows, format=format, dtype=dtype)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspa_row, a_col = np.divmod(np.arange(nrows*ncols), ncols)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprow.append(a_row + r_idx)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcol.append(a_col + c_idx)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdata.append(a.ravel())</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspr_idx += nrows</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspc_idx += ncols</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsprow = np.concatenate(row)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspcol = np.concatenate(col)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdata = np.concatenate(data)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspreturn coo_matrix((data, (row, col)),</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspshape=(r_idx, c_idx),</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdtype=dtype).asformat(format)</span>
<br>&nbsp
<br>&nbsp
<br>&nbspdef random(m, n, density=0.01, format='coo', dtype=None,
<br>@@ -692,17 +712,24 @@ def random(m, n, density=0.01, format='coo', dtype=None,
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsparse matrix format.
<br>&nbsp &nbsp &nbsp &nbsp &nbspdtype : dtype, optional
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsptype of the returned matrix values.
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsprandom_state : {numpy.random.RandomState, int}, optional</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspRandom number generator or random seed. If not given, the singleton</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspnumpy.random will be used.  This random state will be used</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsprandom_state : {None, int, `numpy.random.Generator`,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp`numpy.random.RandomState`}, optional</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf `seed` is None (or `np.random`), the `numpy.random.RandomState`</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsingleton is used.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf `seed` is an int, a new ``RandomState`` instance is used,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspseeded with `seed`.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf `seed` is already a ``Generator`` or ``RandomState`` instance then</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspthat instance is used.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThis random state will be used</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspfor sampling the sparsity structure, but not necessarily for sampling
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspthe values of the structurally nonzero entries of the matrix.
<br>&nbsp &nbsp &nbsp &nbsp &nbspdata_rvs : callable, optional
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspSamples a requested number of random values.
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThis function should take a single argument specifying the length
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspof the ndarray that it will return.  The structurally nonzero entries</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspof the ndarray that it will return. The structurally nonzero entries</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspof the sparse random matrix will be taken from the array sampled
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspby this function.  By default, uniform [0, 1) random values will be</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspby this function. By default, uniform [0, 1) random values will be</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsampled using the same random state as is used for sampling
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspthe sparsity structure.
<br>&nbsp
<br>@@ -710,31 +737,40 @@ def random(m, n, density=0.01, format='coo', dtype=None,
<br>&nbsp &nbsp &nbsp &nbsp &nbsp-------
<br>&nbsp &nbsp &nbsp &nbsp &nbspres : sparse matrix
<br>&nbsp
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspNotes</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp-----</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspOnly float types are supported for now.</span>
<br><span style="color:green">+</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspExamples
<br>&nbsp &nbsp &nbsp &nbsp &nbsp--------
<br>&nbsp &nbsp &nbsp &nbsp &nbsp>>> from scipy.sparse import random
<br>&nbsp &nbsp &nbsp &nbsp &nbsp>>> from scipy import stats
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp>>> class CustomRandomState(object):</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp...     def randint(self, k):</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp...         i = np.random.randint(k)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp...         return i - i % 2</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp>>> rs = CustomRandomState()</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> from numpy.random import default_rng</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> rng = default_rng()</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp>>> rvs = stats.poisson(25, loc=10).rvs
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp>>> S = random(3, 4, density=0.25, random_state=rs, data_rvs=rvs)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> S = random(3, 4, density=0.25, random_state=rng, data_rvs=rvs)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp>>> S.A
<br>&nbsp &nbsp &nbsp &nbsp &nbsparray([[ 36.,   0.,  33.,   0.],   # random
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[  0.,   0.,   0.,   0.],
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[  0.,   0.,  36.,   0.]])
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspNotes</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp-----</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspOnly float types are supported for now.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> from scipy.sparse import random</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> from scipy.stats import rv_continuous</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> class CustomDistribution(rv_continuous):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp...     def _rvs(self,  size=None, random_state=None):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp...         return random_state.standard_normal(size)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> X = CustomDistribution(seed=rng)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> Y = X()  # get a frozen version of the distribution</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> S = random(3, 4, density=0.25, random_state=rng, data_rvs=Y.rvs)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> S.A</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsparray([[ 0.        ,  0.        ,  0.        ,  0.        ],   # random</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[ 0.13569738,  1.9467163 , -0.81205367,  0.        ],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[ 0.        ,  0.        ,  0.        ,  0.        ]])</span>
<br><span style="color:green">+</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp &nbsp &nbsp &nbsp &nbspif density < 0 or density > 1:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("density expected to be 0 <= density <= 1")
<br>&nbsp &nbsp &nbsp &nbsp &nbspdtype = np.dtype(dtype)
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspif dtype.char not in 'fdg':</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise NotImplementedError("type %s not supported" % dtype)</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspmn = m * n
<br>&nbsp
<br>@@ -750,32 +786,32 @@ greater than %d - this is not supported on this machine
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError(msg % np.iinfo(tp).max)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp# Number of non zero values
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspk = int(density * m * n)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspk = int(round(density * m * n))</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsprandom_state = check_random_state(random_state)</span>
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspif random_state is None:</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprandom_state = np.random</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspelif isinstance(random_state, (int, np.integer)):</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprandom_state = np.random.RandomState(random_state)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspif data_rvs is None:
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdata_rvs = random_state.rand</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif np.issubdtype(dtype, np.integer):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdef data_rvs(n):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn rng_integers(random_state,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspnp.iinfo(dtype).min,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspnp.iinfo(dtype).max,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspn,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdtype=dtype)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelif np.issubdtype(dtype, np.complexfloating):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdef data_rvs(n):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn (random_state.uniform(size=n) +</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprandom_state.uniform(size=n) * 1j)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelse:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdata_rvs = partial(random_state.uniform, 0., 1.)</span>
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp# Use the algorithm from python's random.sample for k < mn/3.</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspif mn < 3*k:</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspind = random_state.choice(mn, size=k, replace=False)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspelse:</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspind = np.empty(k, dtype=tp)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspselected = set()</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspfor i in xrange(k):</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspj = random_state.randint(mn)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspwhile j in selected:</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspj = random_state.randint(mn)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspselected.add(j)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspind[i] = j</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspind = random_state.choice(mn, size=k, replace=False)</span>
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspj = np.floor(ind * 1. / m).astype(tp)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspi = (ind - j * m).astype(tp)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspvals = data_rvs(k).astype(dtype)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspreturn coo_matrix((vals, (i, j)), shape=(m, n)).asformat(format)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspj = np.floor(ind * 1. / m).astype(tp, copy=False)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspi = (ind - j * m).astype(tp, copy=False)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspvals = data_rvs(k).astype(dtype, copy=False)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspreturn coo_matrix((vals, (i, j)), shape=(m, n)).asformat(format,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcopy=False)</span>
<br>&nbsp
<br>&nbsp
<br>&nbspdef rand(m, n, density=0.01, format="coo", dtype=None, random_state=None):
<br>@@ -793,9 +829,15 @@ def rand(m, n, density=0.01, format="coo", dtype=None, random_state=None):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsparse matrix format.
<br>&nbsp &nbsp &nbsp &nbsp &nbspdtype : dtype, optional
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsptype of the returned matrix values.
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsprandom_state : {numpy.random.RandomState, int}, optional</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspRandom number generator or random seed. If not given, the singleton</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspnumpy.random will be used.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsprandom_state : {None, int, `numpy.random.Generator`,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp`numpy.random.RandomState`}, optional</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf `seed` is None (or `np.random`), the `numpy.random.RandomState`</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsingleton is used.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf `seed` is an int, a new ``RandomState`` instance is used,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspseeded with `seed`.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf `seed` is already a ``Generator`` or ``RandomState`` instance then</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspthat instance is used.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspReturns
<br>&nbsp &nbsp &nbsp &nbsp &nbsp-------
<br>@@ -818,8 +860,9 @@ def rand(m, n, density=0.01, format="coo", dtype=None, random_state=None):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp<3x4 sparse matrix of type '<class 'numpy.float64'>'
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspwith 3 stored elements in Compressed Sparse Row format>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp>>> matrix.todense()
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspmatrix([[ 0.        ,  0.59685016,  0.779691  ,  0.        ],</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[ 0.        ,  0.        ,  0.        ,  0.44583275],</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[ 0.        ,  0.        ,  0.        ,  0.        ]])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspmatrix([[0.05641158, 0.        , 0.        , 0.65088847],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[0.        , 0.        , 0.        , 0.14286682],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[0.        , 0.        , 0.        , 0.        ]])</span>
<br><span style="color:green">+</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp &nbsp &nbsp &nbsp &nbspreturn random(m, n, density, format, dtype, random_state)
<br></p>
</div>
<br><br><br>_____________________________________scipy/sparse/coo.py_________________________________________
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>File_Path</th>
      <th>Line_Number</th>
      <th>Found_in_Function</th>
      <th>Function_Definition_Line_Number</th>
      <th>Assert_Statement_Type</th>
      <th>Oracle_Argument_ Position</th>
      <th>Differential_Function_Line_Number</th>
      <th>Differential_Test_Function</th>
      <th>Extracted_Function_File_Location</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>22359</th>
      <td>keras\utils\composite_tensor_support_test.py</td>
      <td>386</td>
      <td>test_sparse_scipy_predict_inputs_via_input_layer_args</td>
      <td>374</td>
      <td>assertAllEqual</td>
      <td>2</td>
      <td>382</td>
      <td>scipy.sparse.coo_matrix</td>
      <td>scipy/sparse/coo.py</td>
    </tr>
    <tr>
      <th>22363</th>
      <td>keras\utils\composite_tensor_support_test.py</td>
      <td>392</td>
      <td>test_sparse_scipy_predict_inputs_via_input_layer_args</td>
      <td>374</td>
      <td>assertAllEqual</td>
      <td>2</td>
      <td>388</td>
      <td>scipy.sparse.coo_matrix</td>
      <td>scipy/sparse/coo.py</td>
    </tr>
  </tbody>
</table>
<br><button type="button" class="collapsible">Git Diff</button>
<div class="content">
<p>diff --git a/scipy/sparse/coo.py b/scipy/sparse/coo.py
<br>index 07bd7bca9..9f6568ce9 100644
<br><span style="color:red">- -- a/scipy/sparse/coo.py</span>
<br><span style="color:green">+++ b/scipy/sparse/coo.py</span>
<br>@@ -1,5 +1,4 @@
<br>&nbsp""" A sparse matrix in COOrdinate or 'triplet' format"""
<br><span style="color:red">- from __future__ import division, print_function, absolute_import</span>
<br>&nbsp
<br>&nbsp__docformat__ = "restructuredtext en"
<br>&nbsp
<br>@@ -9,14 +8,15 @@ from warnings import warn
<br>&nbsp
<br>&nbspimport numpy as np
<br>&nbsp
<br><span style="color:red">- from scipy._lib.six import zip as izip</span>
<br>&nbsp
<br>&nbspfrom ._sparsetools import coo_tocsr, coo_todense, coo_matvec
<br>&nbspfrom .base import isspmatrix, SparseEfficiencyWarning, spmatrix
<br>&nbspfrom .data import _data_matrix, _minmax_mixin
<br>&nbspfrom .sputils import (upcast, upcast_char, to_native, isshape, getdtype,
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspget_index_dtype, downcast_intp_index, check_shape,</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcheck_reshape_kwargs)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspgetdata, get_index_dtype, downcast_intp_index,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcheck_shape, check_reshape_kwargs, matrix)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+import operator</span>
<br>&nbsp
<br>&nbsp
<br>&nbspclass coo_matrix(_data_matrix, _minmax_mixin):
<br>@@ -54,7 +54,7 @@ class coo_matrix(_data_matrix, _minmax_mixin):
<br>&nbsp &nbsp &nbsp &nbsp &nbspndim : int
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspNumber of dimensions (this is always 2)
<br>&nbsp &nbsp &nbsp &nbsp &nbspnnz
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspNumber of nonzero elements</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspNumber of stored values, including explicit zeros</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspdata
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspCOO format data array of the matrix
<br>&nbsp &nbsp &nbsp &nbsp &nbsprow
<br>@@ -88,7 +88,7 @@ class coo_matrix(_data_matrix, _minmax_mixin):
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspExamples
<br>&nbsp &nbsp &nbsp &nbsp &nbsp--------
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp</span>
<br><span style="color:green">+</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp>>> # Constructing an empty matrix
<br>&nbsp &nbsp &nbsp &nbsp &nbsp>>> from scipy.sparse import coo_matrix
<br>&nbsp &nbsp &nbsp &nbsp &nbsp>>> coo_matrix((3, 4), dtype=np.int8).toarray()
<br>@@ -131,22 +131,23 @@ class coo_matrix(_data_matrix, _minmax_mixin):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspM, N = arg1
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._shape = check_shape((M, N))
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspidx_dtype = get_index_dtype(maxval=max(M, N))
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdata_dtype = getdtype(dtype, default=float)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.row = np.array([], dtype=idx_dtype)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.col = np.array([], dtype=idx_dtype)
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.data = np.array([], getdtype(dtype, default=float))</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.data = np.array([], dtype=data_dtype)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.has_canonical_format = True
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelse:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsptry:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspobj, (row, col) = arg1
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspexcept (TypeError, ValueError):</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise TypeError('invalid input format')</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspexcept (TypeError, ValueError) as e:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise TypeError('invalid input format') from e</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif shape is None:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif len(row) == 0 or len(col) == 0:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError('cannot infer dimensions from zero '
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp'sized index arrays')
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspM = np.max(row) + 1</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspN = np.max(col) + 1</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspM = operator.index(np.max(row)) + 1</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspN = operator.index(np.max(col)) + 1</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._shape = check_shape((M, N))
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelse:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# Use 2 steps to ensure shape has length 2.
<br>@@ -156,9 +157,8 @@ class coo_matrix(_data_matrix, _minmax_mixin):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspidx_dtype = get_index_dtype(maxval=max(self.shape))
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.row = np.array(row, copy=copy, dtype=idx_dtype)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.col = np.array(col, copy=copy, dtype=idx_dtype)
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.data = np.array(obj, copy=copy)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.data = getdata(obj, copy=copy, dtype=dtype)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.has_canonical_format = False
<br><span style="color:red">- </span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelse:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif isspmatrix(arg1):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif isspmatrix_coo(arg1) and copy:
<br>@@ -179,8 +179,12 @@ class coo_matrix(_data_matrix, _minmax_mixin):
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif M.ndim != 2:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise TypeError('expected dimension <= 2 array or matrix')
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelse:</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._shape = check_shape(M.shape)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._shape = check_shape(M.shape)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif shape is not None:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif check_shape(shape) != self._shape:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError('inconsistent shapes: %s != %s' %</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp(shape, self._shape))</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.row, self.col = M.nonzero()
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.data = M[self.row, self.col]
<br>@@ -205,10 +209,17 @@ class coo_matrix(_data_matrix, _minmax_mixin):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspnrows, ncols = self.shape
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif order == 'C':
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspflat_indices = ncols * self.row + self.col</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# Upcast to avoid overflows: the coo_matrix constructor</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# below will downcast the results to a smaller dtype, if</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# possible.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdtype = get_index_dtype(maxval=(ncols * max(0, nrows - 1) + max(0, ncols - 1)))</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspflat_indices = np.multiply(ncols, self.row, dtype=dtype) + self.col</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspnew_row, new_col = divmod(flat_indices, shape[1])
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelif order == 'F':
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspflat_indices = self.row + nrows * self.col</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdtype = get_index_dtype(maxval=(nrows * max(0, ncols - 1) + max(0, nrows - 1)))</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspflat_indices = np.multiply(nrows, self.col, dtype=dtype) + self.row</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspnew_col, new_row = divmod(flat_indices, shape[0])
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelse:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("'order' must be 'C' or 'F'")
<br>@@ -436,7 +447,7 @@ class coo_matrix(_data_matrix, _minmax_mixin):
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.sum_duplicates()
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdok = dok_matrix((self.shape), dtype=self.dtype)
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdok._update(izip(izip(self.row,self.col),self.data))</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdok._update(zip(zip(self.row,self.col),self.data))</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn dok
<br>&nbsp
<br>@@ -445,7 +456,7 @@ class coo_matrix(_data_matrix, _minmax_mixin):
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef diagonal(self, k=0):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprows, cols = self.shape
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif k <= -rows or k >= cols:
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("k exceeds matrix dimensions")</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn np.empty(0, dtype=self.data.dtype)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdiag = np.zeros(min(rows + min(k, 0), cols - max(k, 0)),
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdtype=self.dtype)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdiag_mask = (self.row + k) == self.col
<br>@@ -556,14 +567,15 @@ class coo_matrix(_data_matrix, _minmax_mixin):
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef _add_dense(self, other):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif other.shape != self.shape:
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError('Incompatible shapes.')</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError('Incompatible shapes ({} and {})'</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp.format(self.shape, other.shape))</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdtype = upcast_char(self.dtype.char, other.dtype.char)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspresult = np.array(other, dtype=dtype, copy=True)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspfortran = int(result.flags.f_contiguous)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspM, N = self.shape
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcoo_todense(M, N, self.nnz, self.row, self.col, self.data,
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspresult.ravel('A'), fortran)
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn np.matrix(result, copy=False)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn matrix(result, copy=False)</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef _mul_vector(self, other):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp#output array
<br></p>
</div>
<br><br><br>_____________________________________scipy/linalg/decomp.py_________________________________________
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>File_Path</th>
      <th>Line_Number</th>
      <th>Found_in_Function</th>
      <th>Function_Definition_Line_Number</th>
      <th>Assert_Statement_Type</th>
      <th>Oracle_Argument_ Position</th>
      <th>Differential_Function_Line_Number</th>
      <th>Differential_Test_Function</th>
      <th>Extracted_Function_File_Location</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>26949</th>
      <td>kernel_tests\linalg_ops_test.py</td>
      <td>576</td>
      <td>run_test</td>
      <td>562</td>
      <td>assertAllClose</td>
      <td>1</td>
      <td>571</td>
      <td>scipy.linalg.eigh_tridiagonal</td>
      <td>scipy/linalg/decomp.py</td>
    </tr>
  </tbody>
</table>
<br><button type="button" class="collapsible">Git Diff</button>
<div class="content">
<p>diff --git a/scipy/linalg/decomp.py b/scipy/linalg/decomp.py
<br>index 35e020cfc..9e3f79917 100644
<br><span style="color:red">- -- a/scipy/linalg/decomp.py</span>
<br><span style="color:green">+++ b/scipy/linalg/decomp.py</span>
<br>@@ -1,3 +1,4 @@
<br><span style="color:green">+# -*- coding: utf-8 -*-</span>
<br>&nbsp#
<br>&nbsp# Author: Pearu Peterson, March 2002
<br>&nbsp#
<br>@@ -8,23 +9,20 @@
<br>&nbsp# additions by Andrew D Straw, May 2007
<br>&nbsp# additions by Tiziano Zito, November 2008
<br>&nbsp#
<br><span style="color:red">- # April 2010: Functions for LU, QR, SVD, Schur and Cholesky decompositions were</span>
<br><span style="color:red">- # moved to their own files.  Still in this file are functions for eigenstuff</span>
<br><span style="color:red">- # and for the Hessenberg form.</span>
<br><span style="color:red">- </span>
<br><span style="color:red">- from __future__ import division, print_function, absolute_import</span>
<br><span style="color:green">+# April 2010: Functions for LU, QR, SVD, Schur, and Cholesky decompositions</span>
<br><span style="color:green">+# were moved to their own files. Still in this file are functions for</span>
<br><span style="color:green">+# eigenstuff and for the Hessenberg form.</span>
<br>&nbsp
<br>&nbsp__all__ = ['eig', 'eigvals', 'eigh', 'eigvalsh',
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp'eig_banded', 'eigvals_banded',
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp'eigh_tridiagonal', 'eigvalsh_tridiagonal', 'hessenberg']</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp'eigh_tridiagonal', 'eigvalsh_tridiagonal', 'hessenberg', 'cdf2rdf']</span>
<br>&nbsp
<br>&nbspimport numpy
<br>&nbspfrom numpy import (array, isfinite, inexact, nonzero, iscomplexobj, cast,
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspflatnonzero, conj, asarray, argsort, empty)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspflatnonzero, conj, asarray, argsort, empty,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspiscomplex, zeros, einsum, eye, inf)</span>
<br>&nbsp# Local imports
<br><span style="color:red">- from scipy._lib.six import xrange</span>
<br>&nbspfrom scipy._lib._util import _asarray_validated
<br><span style="color:red">- from scipy._lib.six import string_types</span>
<br>&nbspfrom .misc import LinAlgError, _datacopied, norm
<br>&nbspfrom .lapack import get_lapack_funcs, _compute_lwork
<br>&nbsp
<br>@@ -62,7 +60,7 @@ def _make_eigvals(alpha, beta, homogeneous_eigvals):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspbeta_nonzero = ~beta_zero
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspw[beta_nonzero] = alpha[beta_nonzero]/beta[beta_nonzero]
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# Use numpy.inf for complex values too since
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# 1/numpy.inf = 0, i.e. it correctly behaves as projective</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# 1/numpy.inf = 0, i.e., it correctly behaves as projective</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# infinity.
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspw[~alpha_zero & beta_zero] = numpy.inf
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif numpy.all(alpha.imag == 0):
<br>@@ -77,7 +75,7 @@ def _geneig(a1, b1, left, right, overwrite_a, overwrite_b,
<br>&nbsp &nbsp &nbsp &nbsp &nbspggev, = get_lapack_funcs(('ggev',), (a1, b1))
<br>&nbsp &nbsp &nbsp &nbsp &nbspcvl, cvr = left, right
<br>&nbsp &nbsp &nbsp &nbsp &nbspres = ggev(a1, b1, lwork=-1)
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsplwork = res[-2][0].real.astype(numpy.int)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsplwork = res[-2][0].real.astype(numpy.int_)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspif ggev.typecode in 'cz':
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspalpha, beta, vl, vr, work, info = ggev(a1, b1, cvl, cvr, lwork,
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoverwrite_a, overwrite_b)
<br>@@ -99,7 +97,7 @@ def _geneig(a1, b1, left, right, overwrite_a, overwrite_b,
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspvr = _make_complex_eigvecs(w, vr, t)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp# the eigenvectors returned by the lapack function are NOT normalized
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspfor i in xrange(vr.shape[0]):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspfor i in range(vr.shape[0]):</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif right:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspvr[:, i] /= norm(vr[:, i])
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif left:
<br>@@ -180,6 +178,35 @@ def eig(a, b=None, left=False, right=True, overwrite_a=False,
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspband matrices
<br>&nbsp &nbsp &nbsp &nbsp &nbspeigh_tridiagonal : eigenvalues and right eiegenvectors for
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsymmetric/Hermitian tridiagonal matrices
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspExamples</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp--------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> from scipy import linalg</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> a = np.array([[0., -1.], [1., 0.]])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> linalg.eigvals(a)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsparray([0.+1.j, 0.-1.j])</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> b = np.array([[0., 1.], [1., 1.]])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> linalg.eigvals(a, b)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsparray([ 1.+0.j, -1.+0.j])</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> a = np.array([[3., 0., 0.], [0., 8., 0.], [0., 0., 7.]])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> linalg.eigvals(a, homogeneous_eigvals=True)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsparray([[3.+0.j, 8.+0.j, 7.+0.j],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[1.+0.j, 1.+0.j, 1.+0.j]])</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> a = np.array([[0., -1.], [1., 0.]])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> linalg.eigvals(a) == linalg.eig(a)[0]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsparray([ True,  True])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> linalg.eig(a, left=True, right=False)[1] # normalized left eigenvector</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsparray([[-0.70710678+0.j        , -0.70710678-0.j        ],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[-0.        +0.70710678j, -0.        -0.70710678j]])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> linalg.eig(a, left=False, right=True)[1] # normalized right eigenvector</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsparray([[0.70710678+0.j        , 0.70710678-0.j        ],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[0.        -0.70710678j, 0.        +0.70710678j]])</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp &nbsp &nbsp &nbsp &nbspa1 = _asarray_validated(a, check_finite=check_finite)
<br>&nbsp &nbsp &nbsp &nbsp &nbspif len(a1.shape) != 2 or a1.shape[0] != a1.shape[1]:
<br>@@ -239,17 +266,22 @@ def eig(a, b=None, left=False, right=True, overwrite_a=False,
<br>&nbsp
<br>&nbspdef eigh(a, b=None, lower=True, eigvals_only=False, overwrite_a=False,
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoverwrite_b=False, turbo=True, eigvals=None, type=1,
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcheck_finite=True):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcheck_finite=True, subset_by_index=None, subset_by_value=None,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdriver=None):</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspSolve an ordinary or generalized eigenvalue problem for a complex</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspSolve a standard or generalized eigenvalue problem for a complex</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspHermitian or real symmetric matrix.
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspFind eigenvalues w and optionally eigenvectors v of matrix `a`, where</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp`b` is positive definite::</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspFind eigenvalues array ``w`` and optionally eigenvectors array ``v`` of</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsparray ``a``, where ``b`` is positive definite such that for every</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspeigenvalue  (i-th entry of w) and its eigenvector ``vi`` (i-th column of</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp``v``) satisfies::</span>
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspa v[:,i] = w[i] b v[:,i]</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspv[i,:].conj() a v[:,i] = w[i]</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspv[i,:].conj() b v[:,i] = 1</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspa @ vi =  * b @ vi</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspvi.conj().T @ a @ vi = </span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspvi.conj().T @ b @ vi = 1</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspIn the standard problem, ``b`` is assumed to be the identity matrix.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -261,162 +293,276 @@ def eigh(a, b=None, lower=True, eigvals_only=False, overwrite_a=False,
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf omitted, identity matrix is assumed.
<br>&nbsp &nbsp &nbsp &nbsp &nbsplower : bool, optional
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspWhether the pertinent array data is taken from the lower or upper
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsptriangle of `a`. (Default: lower)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsptriangle of ``a`` and, if applicable, ``b``. (Default: lower)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspeigvals_only : bool, optional
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspWhether to calculate only eigenvalues and no eigenvectors.
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp(Default: both are calculated)
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspturbo : bool, optional</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspUse divide and conquer algorithm (faster but expensive in memory,</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsponly for generalized eigenvalue problem and if eigvals=None)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspeigvals : tuple (lo, hi), optional</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIndexes of the smallest and largest (in ascending order) eigenvalues</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspand corresponding eigenvectors to be returned: 0 <= lo <= hi <= M-1.</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf omitted, all eigenvalues and eigenvectors are returned.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspsubset_by_index : iterable, optional</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf provided, this two-element iterable defines the start and the end</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspindices of the desired eigenvalues (ascending order and 0-indexed).</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspTo return only the second smallest to fifth smallest eigenvalues,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp``[1, 4]`` is used. ``[n-3, n-1]`` returns the largest three. Only</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspavailable with "evr", "evx", and "gvx" drivers. The entries are</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdirectly converted to integers via ``int()``.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspsubset_by_value : iterable, optional</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf provided, this two-element iterable defines the half-open interval</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp``(a, b]`` that, if any, only the eigenvalues between these values</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspare returned. Only available with "evr", "evx", and "gvx" drivers. Use</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp``np.inf`` for the unconstrained ends.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdriver: str, optional</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspDefines which LAPACK driver should be used. Valid options are "ev",</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"evd", "evr", "evx" for standard problems and "gv", "gvd", "gvx" for</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspgeneralized (where b is not None) problems. See the Notes section.</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsptype : int, optional
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspSpecifies the problem type to be solved:</span>
<br><span style="color:red">- </span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsptype = 1: a   v[:,i] = w[i] b v[:,i]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspFor the generalized problems, this keyword specifies the problem type</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspto be solved for ``w`` and ``v`` (only takes 1, 2, 3 as possible</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspinputs)::</span>
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsptype = 2: a b v[:,i] = w[i]   v[:,i]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp1 =>     a @ v = w @ b @ v</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp2 => a @ b @ v = w @ v</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp3 => b @ a @ v = w @ v</span>
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsptype = 3: b a v[:,i] = w[i]   v[:,i]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThis keyword is ignored for standard problems.</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspoverwrite_a : bool, optional
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspWhether to overwrite data in `a` (may improve performance)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspWhether to overwrite data in ``a`` (may improve performance). Default</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspis False.</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspoverwrite_b : bool, optional
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspWhether to overwrite data in `b` (may improve performance)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspWhether to overwrite data in ``b`` (may improve performance). Default</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspis False.</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspcheck_finite : bool, optional
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspWhether to check that the input matrices contain only finite numbers.
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspDisabling may give a performance gain, but may result in problems
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp(crashes, non-termination) if the inputs do contain infinities or NaNs.
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspturbo : bool, optional</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp*Deprecated since v1.5.0, use ``driver=gvd`` keyword instead*.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspUse divide and conquer algorithm (faster but expensive in memory, only</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspfor generalized eigenvalue problem and if full set of eigenvalues are</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprequested.). Has no significant effect if eigenvectors are not</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprequested.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspeigvals : tuple (lo, hi), optional</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp*Deprecated since v1.5.0, use ``subset_by_index`` keyword instead*.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIndexes of the smallest and largest (in ascending order) eigenvalues</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspand corresponding eigenvectors to be returned: 0 <= lo <= hi <= M-1.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf omitted, all eigenvalues and eigenvectors are returned.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspReturns
<br>&nbsp &nbsp &nbsp &nbsp &nbsp-------
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspw : (N,) float ndarray</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspw : (N,) ndarray</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThe N (1<=N<=M) selected eigenvalues, in ascending order, each
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprepeated according to its multiplicity.
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspv : (M, N) complex ndarray</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp(if eigvals_only == False)</span>
<br><span style="color:red">- </span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThe normalized selected eigenvector corresponding to the</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspeigenvalue w[i] is the column v[:,i].</span>
<br><span style="color:red">- </span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspNormalization:</span>
<br><span style="color:red">- </span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsptype 1 and 3: v.conj() a      v  = w</span>
<br><span style="color:red">- </span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsptype 2: inv(v).conj() a  inv(v) = w</span>
<br><span style="color:red">- </span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsptype = 1 or 2: v.conj() b      v  = I</span>
<br><span style="color:red">- </span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsptype = 3: v.conj() inv(b) v  = I</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspv : (M, N) ndarray</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp(if ``eigvals_only == False``)</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspRaises
<br>&nbsp &nbsp &nbsp &nbsp &nbsp------
<br>&nbsp &nbsp &nbsp &nbsp &nbspLinAlgError
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf eigenvalue computation does not converge,</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspan error occurred, or b matrix is not definite positive. Note that</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif input matrices are not symmetric or hermitian, no error is reported</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspbut results will be wrong.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf eigenvalue computation does not converge, an error occurred, or</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspb matrix is not definite positive. Note that if input matrices are</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspnot symmetric or Hermitian, no error will be reported but results will</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspbe wrong.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspSee Also
<br>&nbsp &nbsp &nbsp &nbsp &nbsp--------
<br>&nbsp &nbsp &nbsp &nbsp &nbspeigvalsh : eigenvalues of symmetric or Hermitian arrays
<br>&nbsp &nbsp &nbsp &nbsp &nbspeig : eigenvalues and right eigenvectors for non-symmetric arrays
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspeigh : eigenvalues and right eigenvectors for symmetric/Hermitian arrays</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspeigh_tridiagonal : eigenvalues and right eiegenvectors for
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsymmetric/Hermitian tridiagonal matrices
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspNotes</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp-----</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspThis function does not check the input array for being Hermitian/symmetric</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspin order to allow for representing arrays with only their upper/lower</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsptriangular parts. Also, note that even though not taken into account,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspfiniteness check applies to the whole array and unaffected by "lower"</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspkeyword.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspThis function uses LAPACK drivers for computations in all possible keyword</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspcombinations, prefixed with ``sy`` if arrays are real and ``he`` if</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspcomplex, e.g., a float array with "evr" driver is solved via</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp"syevr", complex arrays with "gvx" driver problem is solved via "hegvx"</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspetc.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspAs a brief summary, the slowest and the most robust driver is the</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspclassical ``<sy/he>ev`` which uses symmetric QR. ``<sy/he>evr`` is seen as</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspthe optimal choice for the most general cases. However, there are certain</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspoccasions that ``<sy/he>evd`` computes faster at the expense of more</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspmemory usage. ``<sy/he>evx``, while still being faster than ``<sy/he>ev``,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspoften performs worse than the rest except when very few eigenvalues are</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsprequested for large arrays though there is still no performance guarantee.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspFor the generalized problem, normalization with respect to the given</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsptype argument::</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsptype 1 and 3 :      v.conj().T @ a @ v = w</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsptype 2       : inv(v).conj().T @ a @ inv(v) = w</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsptype 1 or 2  :      v.conj().T @ b @ v  = I</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsptype 3       : v.conj().T @ inv(b) @ v  = I</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspExamples</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp--------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> from scipy.linalg import eigh</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> A = np.array([[6, 3, 1, 5], [3, 0, 5, 1], [1, 5, 6, 2], [5, 1, 2, 2]])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> w, v = eigh(A)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> np.allclose(A @ v - v @ np.diag(w), np.zeros((4, 4)))</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspTrue</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspRequest only the eigenvalues</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> w = eigh(A, eigvals_only=True)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspRequest eigenvalues that are less than 10.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> A = np.array([[34, -4, -10, -7, 2],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp...               [-4, 7, 2, 12, 0],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp...               [-10, 2, 44, 2, -19],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp...               [-7, 12, 2, 79, -34],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp...               [2, 0, -19, -34, 29]])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> eigh(A, eigvals_only=True, subset_by_value=[-np.inf, 10])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsparray([6.69199443e-07, 9.11938152e+00])</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspRequest the largest second eigenvalue and its eigenvector</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> w, v = eigh(A, subset_by_index=[1, 1])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> w</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsparray([9.11938152])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> v.shape  # only a single column is returned</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp(5, 1)</span>
<br><span style="color:green">+</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp# set lower</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspuplo = 'L' if lower else 'U'</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp# Set job for Fortran routines</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp_job = 'N' if eigvals_only else 'V'</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdrv_str = [None, "ev", "evd", "evr", "evx", "gv", "gvd", "gvx"]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspif driver not in drv_str:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError('"{}" is unknown. Possible values are "None", "{}".'</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp''.format(driver, '", "'.join(drv_str[1:])))</span>
<br><span style="color:green">+</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspa1 = _asarray_validated(a, check_finite=check_finite)
<br>&nbsp &nbsp &nbsp &nbsp &nbspif len(a1.shape) != 2 or a1.shape[0] != a1.shape[1]:
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError('expected square matrix')</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError('expected square "a" matrix')</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspoverwrite_a = overwrite_a or (_datacopied(a1, a))
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspif iscomplexobj(a1):</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcplx = True</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspelse:</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcplx = False</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspcplx = True if iscomplexobj(a1) else False</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspn = a1.shape[0]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdrv_args = {'overwrite_a': overwrite_a}</span>
<br><span style="color:green">+</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspif b is not None:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspb1 = _asarray_validated(b, check_finite=check_finite)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoverwrite_b = overwrite_b or _datacopied(b1, b)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif len(b1.shape) != 2 or b1.shape[0] != b1.shape[1]:
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError('expected square matrix')</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError('expected square "b" matrix')</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif b1.shape != a1.shape:
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("wrong b dimensions %s, should "</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"be %s" % (str(b1.shape), str(a1.shape)))</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif iscomplexobj(b1):</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcplx = True</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelse:</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcplx = cplx or False</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspelse:</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspb1 = None</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("wrong b dimensions {}, should "</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"be {}".format(b1.shape, a1.shape))</span>
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp# Set job for fortran routines</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp_job = (eigvals_only and 'N') or 'V'</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif type not in [1, 2, 3]:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError('"type" keyword only accepts 1, 2, and 3.')</span>
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp# port eigenvalue range from python to fortran convention</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspif eigvals is not None:</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsplo, hi = eigvals</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif lo < 0 or hi >= a1.shape[0]:</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError('The eigenvalue range specified is not valid.\n'</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp'Valid range is [%s,%s]' % (0, a1.shape[0]-1))</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsplo += 1</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsphi += 1</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspeigvals = (lo, hi)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcplx = True if iscomplexobj(b1) else (cplx or False)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdrv_args.update({'overwrite_b': overwrite_b, 'itype': type})</span>
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp# set lower</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspif lower:</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspuplo = 'L'</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspelse:</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspuplo = 'U'</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp# backwards-compatibility handling</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspsubset_by_index = subset_by_index if (eigvals is None) else eigvals</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspsubset = (subset_by_index is not None) or (subset_by_value is not None)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp# Both subsets can't be given</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspif subset_by_index and subset_by_value:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError('Either index or value subset can be requested.')</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp# Take turbo into account if all conditions are met otherwise ignore</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspif turbo and b is not None:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdriver = 'gvx' if subset else 'gvd'</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp# Check indices if given</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspif subset_by_index:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsplo, hi = [int(x) for x in subset_by_index]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif not (0 <= lo <= hi < n):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError('Requested eigenvalue indices are not valid. '</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp'Valid range is [0, {}] and start <= end, but '</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp'start={}, end={} is given'.format(n-1, lo, hi))</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# fortran is 1-indexed</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdrv_args.update({'range': 'I', 'il': lo + 1, 'iu': hi + 1})</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspif subset_by_value:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsplo, hi = subset_by_value</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif not (-inf <= lo < hi <= inf):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError('Requested eigenvalue bounds are not valid. '</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp'Valid range is (-inf, inf) and low < high, but '</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp'low={}, high={} is given'.format(lo, hi))</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdrv_args.update({'range': 'V', 'vl': lo, 'vu': hi})</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp# fix prefix for lapack routines
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspif cplx:</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsppfx = 'he'</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsppfx = 'he' if cplx else 'sy'</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp# decide on the driver if not given</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp# first early exit on incompatible choice</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspif driver:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif b is None and (driver in ["gv", "gvd", "gvx"]):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError('{} requires input b array to be supplied '</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp'for generalized eigenvalue problems.'</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp''.format(driver))</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif (b is not None) and (driver in ['ev', 'evd', 'evr', 'evx']):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError('"{}" does not accept input b array '</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp'for standard eigenvalue problems.'</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp''.format(driver))</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif subset and (driver in ["ev", "evd", "gv", "gvd"]):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError('"{}" cannot compute subsets of eigenvalues'</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp''.format(driver))</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp# Default driver is evr and gvd</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspelse:
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsppfx = 'sy'</span>
<br><span style="color:red">- </span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp#  Standard Eigenvalue Problem</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp#  Use '*evr' routines</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp# FIXME: implement calculation of optimal lwork</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp#        for all lapack routines</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspif b1 is None:</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdriver = pfx+'evr'</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp(evr,) = get_lapack_funcs((driver,), (a1,))</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif eigvals is None:</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspw, v, info = evr(a1, uplo=uplo, jobz=_job, range="A", il=1,</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspiu=a1.shape[0], overwrite_a=overwrite_a)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdriver = "evr" if b is None else ("gvx" if subset else "gvd")</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsplwork_spec = {</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp'syevd': ['lwork', 'liwork'],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp'syevr': ['lwork', 'liwork'],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp'heevd': ['lwork', 'liwork', 'lrwork'],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp'heevr': ['lwork', 'lrwork', 'liwork'],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp}</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspif b is None:  # Standard problem</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdrv, drvlw = get_lapack_funcs((pfx + driver, pfx+driver+'_lwork'),</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[a1])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspclw_args = {'n': n, 'lower': lower}</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif driver == 'evd':</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspclw_args.update({'compute_v': 0 if _job == "N" else 1})</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsplw = _compute_lwork(drvlw, **clw_args)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# Multiple lwork vars</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif isinstance(lw, tuple):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsplwork_args = dict(zip(lwork_spec[pfx+driver], lw))</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelse:
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp(lo, hi) = eigvals</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspw_tot, v, info = evr(a1, uplo=uplo, jobz=_job, range="I",</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspil=lo, iu=hi, overwrite_a=overwrite_a)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspw = w_tot[0:hi-lo+1]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsplwork_args = {'lwork': lw}</span>
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp# Generalized Eigenvalue Problem</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspelse:</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# Use '*gvx' routines if range is specified</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif eigvals is not None:</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdriver = pfx+'gvx'</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp(gvx,) = get_lapack_funcs((driver,), (a1, b1))</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp(lo, hi) = eigvals</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspw_tot, v, ifail, info = gvx(a1, b1, uplo=uplo, iu=hi,</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspitype=type, jobz=_job, il=lo,</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoverwrite_a=overwrite_a,</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoverwrite_b=overwrite_b)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspw = w_tot[0:hi-lo+1]</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# Use '*gvd' routine if turbo is on and no eigvals are specified</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelif turbo:</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdriver = pfx+'gvd'</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp(gvd,) = get_lapack_funcs((driver,), (a1, b1))</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspv, w, info = gvd(a1, b1, uplo=uplo, itype=type, jobz=_job,</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoverwrite_a=overwrite_a,</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoverwrite_b=overwrite_b)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# Use '*gv' routine if turbo is off and no eigvals are specified</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdrv_args.update({'lower': lower, 'compute_v': 0 if _job == "N" else 1})</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspw, v, *other_args, info = drv(a=a1, **drv_args, **lwork_args)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspelse:  # Generalized problem</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# 'gvd' doesn't have lwork query</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif driver == "gvd":</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdrv = get_lapack_funcs(pfx + "gvd", [a1, b1])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsplwork_args = {}</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelse:
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdriver = pfx+'gv'</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp(gv,) = get_lapack_funcs((driver,), (a1, b1))</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspv, w, info = gv(a1, b1, uplo=uplo, itype=type, jobz=_job,</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoverwrite_a=overwrite_a,</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoverwrite_b=overwrite_b)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdrv, drvlw = get_lapack_funcs((pfx + driver, pfx+driver+'_lwork'),</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[a1, b1])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# generalized drivers use uplo instead of lower</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsplw = _compute_lwork(drvlw, n, uplo=uplo)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsplwork_args = {'lwork': lw}</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdrv_args.update({'uplo': uplo, 'jobz': _job})</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspw, v, *other_args, info = drv(a=a1, b=b1, **drv_args, **lwork_args)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp# m is always the first extra argument</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspw = w[:other_args[0]] if subset else w</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspv = v[:, :other_args[0]] if (subset and not eigvals_only) else v</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp# Check if we had a  successful exit
<br>&nbsp &nbsp &nbsp &nbsp &nbspif info == 0:
<br>@@ -424,28 +570,38 @@ def eigh(a, b=None, lower=True, eigvals_only=False, overwrite_a=False,
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn w
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelse:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn w, v
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp_check_info(info, driver, positive=False)  # triage more specifically</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspif info > 0 and b1 is None:</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise LinAlgError("unrecoverable internal error.")</span>
<br><span style="color:red">- </span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp# The algorithm failed to converge.</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspelif 0 < info <= b1.shape[0]:</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif eigvals is not None:</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise LinAlgError("the eigenvectors %s failed to"</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp" converge." % nonzero(ifail)-1)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspelse:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif info < -1:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise LinAlgError('Illegal value in argument {} of internal {}'</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp''.format(-info, drv.typecode + pfx + driver))</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelif info > n:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise LinAlgError('The leading minor of order {} of B is not '</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp'positive definite. The factorization of B '</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp'could not be completed and no eigenvalues '</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp'or eigenvectors were computed.'.format(info-n))</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelse:
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise LinAlgError("internal fortran routine failed to converge: "</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"%i off-diagonal elements of an "</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"intermediate tridiagonal form did not converge"</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp" to zero." % info)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdrv_err = {'ev': 'The algorithm failed to converge; {} '</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp'off-diagonal elements of an intermediate '</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp'tridiagonal form did not converge to zero.',</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp'evx': '{} eigenvectors failed to converge.',</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp'evd': 'The algorithm failed to compute an eigenvalue '</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp'while working on the submatrix lying in rows '</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp'and columns {0}/{1} through mod({0},{1}).',</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp'evr': 'Internal Error.'</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp}</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif driver in ['ev', 'gv']:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmsg = drv_err['ev'].format(info)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelif driver in ['evx', 'gvx']:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmsg = drv_err['evx'].format(info)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelif driver in ['evd', 'gvd']:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif eigvals_only:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmsg = drv_err['ev'].format(info)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelse:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmsg = drv_err['evd'].format(info, n+1)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelse:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmsg = drv_err['evr']</span>
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp# This occurs when b is not positive definite</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspelse:</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise LinAlgError("the leading minor of order %i"</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp" of 'b' is not positive definite. The"</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp" factorization of 'b' could not be completed"</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp" and no eigenvalues or eigenvectors were"</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp" computed." % (info-b1.shape[0]))</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise LinAlgError(msg)</span>
<br>&nbsp
<br>&nbsp
<br>&nbsp_conv_dict = {0: 0, 1: 1, 2: 2,
<br>@@ -455,12 +611,12 @@ _conv_dict = {0: 0, 1: 1, 2: 2,
<br>&nbsp
<br>&nbspdef _check_select(select, select_range, max_ev, max_len):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""Check that select is valid, convert to Fortran style."""
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspif isinstance(select, string_types):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspif isinstance(select, str):</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspselect = select.lower()
<br>&nbsp &nbsp &nbsp &nbsp &nbsptry:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspselect = _conv_dict[select]
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspexcept KeyError:</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError('invalid argument for select')</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspexcept KeyError as e:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError('invalid argument for select') from e</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspvl, vu = 0., 1.
<br>&nbsp &nbsp &nbsp &nbsp &nbspil = iu = 1
<br>&nbsp &nbsp &nbsp &nbsp &nbspif select != 0:  # (non-all)
<br>@@ -473,9 +629,10 @@ def _check_select(select, select_range, max_ev, max_len):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif max_ev == 0:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmax_ev = max_len
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelse:  # 2 (index)
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif sr.dtype.char.lower() not in 'lih':</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif sr.dtype.char.lower() not in 'hilqp':</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError('when using select="i", select_range must '
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp'contain integers, got dtype %s' % sr.dtype)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp'contain integers, got dtype %s (%s)'</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp% (sr.dtype, sr.dtype.char))</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# translate Python (0 ... N-1) into Fortran (1 ... N) with + 1
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspil, iu = sr + 1
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif min(il, iu) < 1 or max(il, iu) > max_len:
<br>@@ -487,7 +644,7 @@ def _check_select(select, select_range, max_ev, max_len):
<br>&nbspdef eig_banded(a_band, lower=False, eigvals_only=False, overwrite_a_band=False,
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspselect='a', select_range=None, max_ev=0, check_finite=True):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspSolve real symmetric or complex hermitian band matrix eigenvalue problem.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspSolve real symmetric or complex Hermitian band matrix eigenvalue problem.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspFind eigenvalues w and optionally right eigenvectors v of a::
<br>&nbsp
<br>@@ -569,8 +726,27 @@ def eig_banded(a_band, lower=False, eigvals_only=False, overwrite_a_band=False,
<br>&nbsp &nbsp &nbsp &nbsp &nbspeigvals_banded : eigenvalues for symmetric/Hermitian band matrices
<br>&nbsp &nbsp &nbsp &nbsp &nbspeig : eigenvalues and right eigenvectors of general arrays.
<br>&nbsp &nbsp &nbsp &nbsp &nbspeigh : eigenvalues and right eigenvectors for symmetric/Hermitian arrays
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspeigh_tridiagonal : eigenvalues and right eiegenvectors for</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspeigh_tridiagonal : eigenvalues and right eigenvectors for</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsymmetric/Hermitian tridiagonal matrices
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspExamples</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp--------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> from scipy.linalg import eig_banded</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> A = np.array([[1, 5, 2, 0], [5, 2, 5, 2], [2, 5, 3, 5], [0, 2, 5, 4]])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> Ab = np.array([[1, 2, 3, 4], [5, 5, 5, 0], [2, 2, 0, 0]])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> w, v = eig_banded(Ab, lower=True)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> np.allclose(A @ v - v @ np.diag(w), np.zeros((4, 4)))</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspTrue</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> w = eig_banded(Ab, lower=True, eigvals_only=True)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> w</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsparray([-4.26200532, -2.22987175,  3.95222349, 12.53965359])</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspRequest only the eigenvalues between ``[-3, 4]``</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> w, v = eig_banded(Ab, lower=True, select='v', select_range=[-3, 4])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> w</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsparray([-2.22987175,  3.95222349])</span>
<br><span style="color:green">+</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp &nbsp &nbsp &nbsp &nbspif eigvals_only or overwrite_a_band:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspa1 = _asarray_validated(a_band, check_finite=check_finite)
<br>@@ -582,7 +758,7 @@ def eig_banded(a_band, lower=False, eigvals_only=False, overwrite_a_band=False,
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoverwrite_a_band = 1
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspif len(a1.shape) != 2:
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError('expected two-dimensional array')</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError('expected a 2-D array')</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspselect, vl, vu, il, iu, max_ev = _check_select(
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspselect, select_range, max_ev, a1.shape[1])
<br>&nbsp &nbsp &nbsp &nbsp &nbspdel select_range
<br>@@ -681,6 +857,23 @@ def eigvals(a, b=None, overwrite_a=False, check_finite=True,
<br>&nbsp &nbsp &nbsp &nbsp &nbspeigvals_banded : eigenvalues for symmetric/Hermitian band matrices
<br>&nbsp &nbsp &nbsp &nbsp &nbspeigvalsh_tridiagonal : eigenvalues of symmetric/Hermitian tridiagonal
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmatrices
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspExamples</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp--------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> from scipy import linalg</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> a = np.array([[0., -1.], [1., 0.]])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> linalg.eigvals(a)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsparray([0.+1.j, 0.-1.j])</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> b = np.array([[0., 1.], [1., 1.]])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> linalg.eigvals(a, b)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsparray([ 1.+0.j, -1.+0.j])</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> a = np.array([[3., 0., 0.], [0., 8., 0.], [0., 0., 7.]])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> linalg.eigvals(a, homogeneous_eigvals=True)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsparray([[3.+0.j, 8.+0.j, 7.+0.j],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[1.+0.j, 1.+0.j, 1.+0.j]])</span>
<br><span style="color:green">+</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp &nbsp &nbsp &nbsp &nbspreturn eig(a, b=b, left=0, right=0, overwrite_a=overwrite_a,
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcheck_finite=check_finite,
<br>@@ -689,66 +882,97 @@ def eigvals(a, b=None, overwrite_a=False, check_finite=True,
<br>&nbsp
<br>&nbspdef eigvalsh(a, b=None, lower=True, overwrite_a=False,
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoverwrite_b=False, turbo=True, eigvals=None, type=1,
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcheck_finite=True):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcheck_finite=True, subset_by_index=None, subset_by_value=None,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdriver=None):</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspSolve an ordinary or generalized eigenvalue problem for a complex</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspSolves a standard or generalized eigenvalue problem for a complex</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspHermitian or real symmetric matrix.
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspFind eigenvalues w of matrix a, where b is positive definite::</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspFind eigenvalues array ``w`` of array ``a``, where ``b`` is positive</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdefinite such that for every eigenvalue  (i-th entry of w) and its</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspeigenvector vi (i-th column of v) satisfies::</span>
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspa v[:,i] = w[i] b v[:,i]</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspv[i,:].conj() a v[:,i] = w[i]</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspv[i,:].conj() b v[:,i] = 1</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspa @ vi =  * b @ vi</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspvi.conj().T @ a @ vi = </span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspvi.conj().T @ b @ vi = 1</span>
<br>&nbsp
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspIn the standard problem, b is assumed to be the identity matrix.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>&nbsp &nbsp &nbsp &nbsp &nbspa : (M, M) array_like
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspA complex Hermitian or real symmetric matrix whose eigenvalues and</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspeigenvectors will be computed.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspA complex Hermitian or real symmetric matrix whose eigenvalues will</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspbe computed.</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspb : (M, M) array_like, optional
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspA complex Hermitian or real symmetric definite positive matrix in.
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf omitted, identity matrix is assumed.
<br>&nbsp &nbsp &nbsp &nbsp &nbsplower : bool, optional
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspWhether the pertinent array data is taken from the lower or upper
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsptriangle of `a`. (Default: lower)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspturbo : bool, optional</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspUse divide and conquer algorithm (faster but expensive in memory,</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsponly for generalized eigenvalue problem and if eigvals=None)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspeigvals : tuple (lo, hi), optional</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIndexes of the smallest and largest (in ascending order) eigenvalues</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspand corresponding eigenvectors to be returned: 0 <= lo < hi <= M-1.</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf omitted, all eigenvalues and eigenvectors are returned.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsptriangle of ``a`` and, if applicable, ``b``. (Default: lower)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspoverwrite_a : bool, optional</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspWhether to overwrite data in ``a`` (may improve performance). Default</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspis False.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspoverwrite_b : bool, optional</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspWhether to overwrite data in ``b`` (may improve performance). Default</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspis False.</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsptype : int, optional
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspSpecifies the problem type to be solved:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspFor the generalized problems, this keyword specifies the problem type</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspto be solved for ``w`` and ``v`` (only takes 1, 2, 3 as possible</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspinputs)::</span>
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsptype = 1: a   v[:,i] = w[i] b v[:,i]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp1 =>     a @ v = w @ b @ v</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp2 => a @ b @ v = w @ v</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp3 => b @ a @ v = w @ v</span>
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsptype = 2: a b v[:,i] = w[i]   v[:,i]</span>
<br><span style="color:red">- </span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsptype = 3: b a v[:,i] = w[i]   v[:,i]</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspoverwrite_a : bool, optional</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspWhether to overwrite data in `a` (may improve performance)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspoverwrite_b : bool, optional</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspWhether to overwrite data in `b` (may improve performance)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThis keyword is ignored for standard problems.</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspcheck_finite : bool, optional
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspWhether to check that the input matrices contain only finite numbers.
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspDisabling may give a performance gain, but may result in problems
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp(crashes, non-termination) if the inputs do contain infinities or NaNs.
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspsubset_by_index : iterable, optional</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf provided, this two-element iterable defines the start and the end</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspindices of the desired eigenvalues (ascending order and 0-indexed).</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspTo return only the second smallest to fifth smallest eigenvalues,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp``[1, 4]`` is used. ``[n-3, n-1]`` returns the largest three. Only</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspavailable with "evr", "evx", and "gvx" drivers. The entries are</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdirectly converted to integers via ``int()``.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspsubset_by_value : iterable, optional</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf provided, this two-element iterable defines the half-open interval</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp``(a, b]`` that, if any, only the eigenvalues between these values</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspare returned. Only available with "evr", "evx", and "gvx" drivers. Use</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp``np.inf`` for the unconstrained ends.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdriver: str, optional</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspDefines which LAPACK driver should be used. Valid options are "ev",</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"evd", "evr", "evx" for standard problems and "gv", "gvd", "gvx" for</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspgeneralized (where b is not None) problems. See the Notes section of</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp`scipy.linalg.eigh`.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspturbo : bool, optional</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp*Deprecated by ``driver=gvd`` option*. Has no significant effect for</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspeigenvalue computations since no eigenvectors are requested.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp.. deprecated:: 1.5.0</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspeigvals : tuple (lo, hi), optional</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp*Deprecated by ``subset_by_index`` keyword*. Indexes of the smallest</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspand largest (in ascending order) eigenvalues and corresponding</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspeigenvectors to be returned: 0 <= lo <= hi <= M-1. If omitted, all</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspeigenvalues and eigenvectors are returned.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp.. deprecated:: 1.5.0</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspReturns
<br>&nbsp &nbsp &nbsp &nbsp &nbsp-------
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspw : (N,) float ndarray</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThe N (1<=N<=M) selected eigenvalues, in ascending order, each</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspw : (N,) ndarray</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThe ``N`` (``1<=N<=M``) selected eigenvalues, in ascending order, each</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprepeated according to its multiplicity.
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspRaises
<br>&nbsp &nbsp &nbsp &nbsp &nbsp------
<br>&nbsp &nbsp &nbsp &nbsp &nbspLinAlgError
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf eigenvalue computation does not converge,</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspan error occurred, or b matrix is not definite positive. Note that</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif input matrices are not symmetric or hermitian, no error is reported</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspbut results will be wrong.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf eigenvalue computation does not converge, an error occurred, or</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspb matrix is not definite positive. Note that if input matrices are</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspnot symmetric or Hermitian, no error will be reported but results will</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspbe wrong.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspSee Also
<br>&nbsp &nbsp &nbsp &nbsp &nbsp--------
<br>@@ -757,17 +981,41 @@ def eigvalsh(a, b=None, lower=True, overwrite_a=False,
<br>&nbsp &nbsp &nbsp &nbsp &nbspeigvals_banded : eigenvalues for symmetric/Hermitian band matrices
<br>&nbsp &nbsp &nbsp &nbsp &nbspeigvalsh_tridiagonal : eigenvalues of symmetric/Hermitian tridiagonal
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmatrices
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspNotes</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp-----</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspThis function does not check the input array for being Hermitian/symmetric</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspin order to allow for representing arrays with only their upper/lower</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsptriangular parts.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspThis function serves as a one-liner shorthand for `scipy.linalg.eigh` with</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspthe option ``eigvals_only=True`` to get the eigenvalues and not the</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspeigenvectors. Here it is kept as a legacy convenience. It might be</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspbeneficial to use the main function to have full control and to be a bit</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspmore pythonic.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspExamples</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp--------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspFor more examples see `scipy.linalg.eigh`.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> from scipy.linalg import eigvalsh</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> A = np.array([[6, 3, 1, 5], [3, 0, 5, 1], [1, 5, 6, 2], [5, 1, 2, 2]])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> w = eigvalsh(A)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> w</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsparray([-3.74637491, -0.76263923,  6.08502336, 12.42399079])</span>
<br><span style="color:green">+</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp &nbsp &nbsp &nbsp &nbspreturn eigh(a, b=b, lower=lower, eigvals_only=True,
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoverwrite_a=overwrite_a, overwrite_b=overwrite_b,
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspturbo=turbo, eigvals=eigvals, type=type,
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcheck_finite=check_finite)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcheck_finite=check_finite, subset_by_index=subset_by_index,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsubset_by_value=subset_by_value, driver=driver)</span>
<br>&nbsp
<br>&nbsp
<br>&nbspdef eigvals_banded(a_band, lower=False, overwrite_a_band=False,
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspselect='a', select_range=None, check_finite=True):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspSolve real symmetric or complex hermitian band matrix eigenvalue problem.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspSolve real symmetric or complex Hermitian band matrix eigenvalue problem.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspFind eigenvalues w of a::
<br>&nbsp
<br>@@ -841,6 +1089,15 @@ def eigvals_banded(a_band, lower=False, overwrite_a_band=False,
<br>&nbsp &nbsp &nbsp &nbsp &nbspeigvals : eigenvalues of general arrays
<br>&nbsp &nbsp &nbsp &nbsp &nbspeigh : eigenvalues and right eigenvectors for symmetric/Hermitian arrays
<br>&nbsp &nbsp &nbsp &nbsp &nbspeig : eigenvalues and right eigenvectors for non-symmetric arrays
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspExamples</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp--------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> from scipy.linalg import eigvals_banded</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> A = np.array([[1, 5, 2, 0], [5, 2, 5, 2], [2, 5, 3, 5], [0, 2, 5, 4]])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> Ab = np.array([[1, 2, 3, 4], [5, 5, 5, 0], [2, 2, 0, 0]])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> w = eigvals_banded(Ab, lower=True)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> w</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsparray([-4.26200532, -2.22987175,  3.95222349, 12.53965359])</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp &nbsp &nbsp &nbsp &nbspreturn eig_banded(a_band, lower=lower, eigvals_only=1,
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoverwrite_a_band=overwrite_a_band, select=select,
<br>@@ -910,6 +1167,17 @@ def eigvalsh_tridiagonal(d, e, select='a', select_range=None,
<br>&nbsp &nbsp &nbsp &nbsp &nbsp--------
<br>&nbsp &nbsp &nbsp &nbsp &nbspeigh_tridiagonal : eigenvalues and right eiegenvectors for
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsymmetric/Hermitian tridiagonal matrices
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspExamples</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp--------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> from scipy.linalg import eigvalsh_tridiagonal, eigvalsh</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> d = 3*np.ones(4)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> e = -1*np.ones(3)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> w = eigvalsh_tridiagonal(d, e)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> A = np.diag(d) + np.diag(e, k=1) + np.diag(e, k=-1)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> w2 = eigvalsh(A)  # Verify with other eigenvalue routines</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> np.allclose(w - w2, np.zeros(4))</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspTrue</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp &nbsp &nbsp &nbsp &nbspreturn eigh_tridiagonal(
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspd, e, eigvals_only=True, select=select, select_range=select_range,
<br>@@ -993,12 +1261,22 @@ def eigh_tridiagonal(d, e, eigvals_only=False, select='a', select_range=None,
<br>&nbsp &nbsp &nbsp &nbsp &nbspNotes
<br>&nbsp &nbsp &nbsp &nbsp &nbsp-----
<br>&nbsp &nbsp &nbsp &nbsp &nbspThis function makes use of LAPACK ``S/DSTEMR`` routines.
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspExamples</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp--------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> from scipy.linalg import eigh_tridiagonal</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> d = 3*np.ones(4)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> e = -1*np.ones(3)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> w, v = eigh_tridiagonal(d, e)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> A = np.diag(d) + np.diag(e, k=1) + np.diag(e, k=-1)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> np.allclose(A @ v - v @ np.diag(w), np.zeros((4, 4)))</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspTrue</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp &nbsp &nbsp &nbsp &nbspd = _asarray_validated(d, check_finite=check_finite)
<br>&nbsp &nbsp &nbsp &nbsp &nbspe = _asarray_validated(e, check_finite=check_finite)
<br>&nbsp &nbsp &nbsp &nbsp &nbspfor check in (d, e):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif check.ndim != 1:
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError('expected one-dimensional array')</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError('expected a 1-D array')</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif check.dtype.char in 'GFD':  # complex
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise TypeError('Only real arrays currently supported')
<br>&nbsp &nbsp &nbsp &nbsp &nbspif d.size != e.size + 1:
<br>@@ -1006,7 +1284,7 @@ def eigh_tridiagonal(d, e, eigvals_only=False, select='a', select_range=None,
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp% (d.size, e.size))
<br>&nbsp &nbsp &nbsp &nbsp &nbspselect, vl, vu, il, iu, _ = _check_select(
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspselect, select_range, 0, d.size)
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspif not isinstance(lapack_driver, string_types):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspif not isinstance(lapack_driver, str):</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise TypeError('lapack_driver must be str')
<br>&nbsp &nbsp &nbsp &nbsp &nbspdrivers = ('auto', 'stemr', 'sterf', 'stebz', 'stev')
<br>&nbsp &nbsp &nbsp &nbsp &nbspif lapack_driver not in drivers:
<br>@@ -1034,7 +1312,7 @@ def eigh_tridiagonal(d, e, eigvals_only=False, select='a', select_range=None,
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspinternal_name = 'stebz'
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspstebz, = get_lapack_funcs((internal_name,), (d, e))
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# If getting eigenvectors, needs to be block-ordered (B) instead of
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# matirx-ordered (E), and we will reorder later</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# matrix-ordered (E), and we will reorder later</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsporder = 'E' if eigvals_only else 'B'
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspm, w, iblock, isplit, info = stebz(d, e, select, vl, vu, il, iu, tol,
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsporder)
<br>@@ -1109,6 +1387,18 @@ def hessenberg(a, calc_q=False, overwrite_a=False, check_finite=True):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspUnitary/orthogonal similarity transformation matrix ``A = Q H Q^H``.
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspOnly returned if ``calc_q=True``.
<br>&nbsp
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspExamples</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp--------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> from scipy.linalg import hessenberg</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> A = np.array([[2, 5, 8, 7], [5, 2, 2, 8], [7, 5, 6, 6], [5, 4, 4, 8]])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> H, Q = hessenberg(A, calc_q=True)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> H</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsparray([[  2.        , -11.65843866,   1.42005301,   0.25349066],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[ -9.94987437,  14.53535354,  -5.31022304,   2.43081618],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[  0.        ,  -1.83299243,   0.38969961,  -0.51527034],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[  0.        ,   0.        ,  -3.83189513,   1.07494686]])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> np.allclose(Q @ H @ Q.conj().T - A, np.zeros((4, 4)))</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspTrue</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp &nbsp &nbsp &nbsp &nbspa1 = _asarray_validated(a, check_finite=check_finite)
<br>&nbsp &nbsp &nbsp &nbsp &nbspif len(a1.shape) != 2 or (a1.shape[0] != a1.shape[1]):
<br>@@ -1118,7 +1408,7 @@ def hessenberg(a, calc_q=False, overwrite_a=False, check_finite=True):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp# if 2x2 or smaller: already in Hessenberg
<br>&nbsp &nbsp &nbsp &nbsp &nbspif a1.shape[0] <= 2:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif calc_q:
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn a1, numpy.eye(a1.shape[0])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn a1, eye(a1.shape[0])</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn a1
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspgehrd, gebal, gehrd_lwork = get_lapack_funcs(('gehrd', 'gebal',
<br>@@ -1142,3 +1432,152 @@ def hessenberg(a, calc_q=False, overwrite_a=False, check_finite=True):
<br>&nbsp &nbsp &nbsp &nbsp &nbspq, info = orghr(a=hq, tau=tau, lo=lo, hi=hi, lwork=lwork, overwrite_a=1)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp_check_info(info, 'orghr (hessenberg)', positive=False)
<br>&nbsp &nbsp &nbsp &nbsp &nbspreturn h, q
<br><span style="color:green">+</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+def cdf2rdf(w, v):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspConverts complex eigenvalues ``w`` and eigenvectors ``v`` to real</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspeigenvalues in a block diagonal form ``wr`` and the associated real</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspeigenvectors ``vr``, such that::</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspvr @ wr = X @ vr</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspcontinues to hold, where ``X`` is the original array for which ``w`` and</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp``v`` are the eigenvalues and eigenvectors.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp.. versionadded:: 1.1.0</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspParameters</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp----------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspw : (..., M) array_like</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspComplex or real eigenvalues, an array or stack of arrays</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspConjugate pairs must not be interleaved, else the wrong result</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspwill be produced. So ``[1+1j, 1, 1-1j]`` will give a correct result,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspbut ``[1+1j, 2+1j, 1-1j, 2-1j]`` will not.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspv : (..., M, M) array_like</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspComplex or real eigenvectors, a square array or stack of square arrays.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspReturns</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp-------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspwr : (..., M, M) ndarray</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspReal diagonal block form of eigenvalues</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspvr : (..., M, M) ndarray</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspReal eigenvectors associated with ``wr``</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspSee Also</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp--------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspeig : Eigenvalues and right eigenvectors for non-symmetric arrays</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsprsf2csf : Convert real Schur form to complex Schur form</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspNotes</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp-----</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp``w``, ``v`` must be the eigenstructure for some *real* matrix ``X``.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspFor example, obtained by ``w, v = scipy.linalg.eig(X)`` or</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp``w, v = numpy.linalg.eig(X)`` in which case ``X`` can also represent</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspstacked arrays.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp.. versionadded:: 1.1.0</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspExamples</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp--------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> X = np.array([[1, 2, 3], [0, 4, 5], [0, -5, 4]])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> X</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsparray([[ 1,  2,  3],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[ 0,  4,  5],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[ 0, -5,  4]])</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> from scipy import linalg</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> w, v = linalg.eig(X)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> w</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsparray([ 1.+0.j,  4.+5.j,  4.-5.j])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> v</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsparray([[ 1.00000+0.j     , -0.01906-0.40016j, -0.01906+0.40016j],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[ 0.00000+0.j     ,  0.00000-0.64788j,  0.00000+0.64788j],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[ 0.00000+0.j     ,  0.64788+0.j     ,  0.64788-0.j     ]])</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> wr, vr = linalg.cdf2rdf(w, v)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> wr</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsparray([[ 1.,  0.,  0.],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[ 0.,  4.,  5.],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[ 0., -5.,  4.]])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> vr</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsparray([[ 1.     ,  0.40016, -0.01906],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[ 0.     ,  0.64788,  0.     ],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[ 0.     ,  0.     ,  0.64788]])</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> vr @ wr</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsparray([[ 1.     ,  1.69593,  1.9246 ],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[ 0.     ,  2.59153,  3.23942],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[ 0.     , -3.23942,  2.59153]])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> X @ vr</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsparray([[ 1.     ,  1.69593,  1.9246 ],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[ 0.     ,  2.59153,  3.23942],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[ 0.     , -3.23942,  2.59153]])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspw, v = _asarray_validated(w), _asarray_validated(v)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp# check dimensions</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspif w.ndim < 1:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError('expected w to be at least 1D')</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspif v.ndim < 2:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError('expected v to be at least 2D')</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspif v.ndim != w.ndim + 1:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError('expected eigenvectors array to have exactly one '</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp'dimension more than eigenvalues array')</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp# check shapes</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspn = w.shape[-1]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspM = w.shape[:-1]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspif v.shape[-2] != v.shape[-1]:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError('expected v to be a square matrix or stacked square '</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp'matrices: v.shape[-2] = v.shape[-1]')</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspif v.shape[-1] != n:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError('expected the same number of eigenvalues as '</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp'eigenvectors')</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp# get indices for each first pair of complex eigenvalues</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspcomplex_mask = iscomplex(w)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspn_complex = complex_mask.sum(axis=-1)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp# check if all complex eigenvalues have conjugate pairs</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspif not (n_complex % 2 == 0).all():</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError('expected complex-conjugate pairs of eigenvalues')</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp# find complex indices</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspidx = nonzero(complex_mask)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspidx_stack = idx[:-1]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspidx_elem = idx[-1]</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp# filter them to conjugate indices, assuming pairs are not interleaved</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspj = idx_elem[0::2]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspk = idx_elem[1::2]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspstack_ind = ()</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspfor i in idx_stack:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# should never happen, assuming nonzero orders by the last axis</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspassert (i[0::2] == i[1::2]).all(),\</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"Conjugate pair spanned different arrays!"</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspstack_ind += (i[0::2],)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp# all eigenvalues to diagonal form</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspwr = zeros(M + (n, n), dtype=w.real.dtype)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdi = range(n)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspwr[..., di, di] = w.real</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp# complex eigenvalues to real block diagonal form</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspwr[stack_ind + (j, k)] = w[stack_ind + (j,)].imag</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspwr[stack_ind + (k, j)] = w[stack_ind + (k,)].imag</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp# compute real eigenvectors associated with real block diagonal eigenvalues</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspu = zeros(M + (n, n), dtype=numpy.cdouble)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspu[..., di, di] = 1.0</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspu[stack_ind + (j, j)] = 0.5j</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspu[stack_ind + (j, k)] = 0.5</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspu[stack_ind + (k, j)] = -0.5j</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspu[stack_ind + (k, k)] = 0.5</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp# multipy matrices v and u (equivalent to v @ u)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspvr = einsum('...ij,...jk->...ik', v, u).real</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspreturn wr, vr</span>
<br></p>
</div>
<br><br><br>_____________________________________scipy/stats/_distn_infrastructure.py_________________________________________
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>File_Path</th>
      <th>Line_Number</th>
      <th>Found_in_Function</th>
      <th>Function_Definition_Line_Number</th>
      <th>Assert_Statement_Type</th>
      <th>Oracle_Argument_ Position</th>
      <th>Differential_Function_Line_Number</th>
      <th>Differential_Test_Function</th>
      <th>Extracted_Function_File_Location</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>33035</th>
      <td>kernel_tests\distributions\beta_test.py</td>
      <td>195</td>
      <td>testBetaMean</td>
      <td>187</td>
      <td>assertAllClose</td>
      <td>1</td>
      <td>194</td>
      <td>stats.beta.mean</td>
      <td>scipy/stats/_distn_infrastructure.py</td>
    </tr>
    <tr>
      <th>33037</th>
      <td>kernel_tests\distributions\beta_test.py</td>
      <td>205</td>
      <td>testBetaVariance</td>
      <td>197</td>
      <td>assertAllClose</td>
      <td>1</td>
      <td>204</td>
      <td>stats.beta.var</td>
      <td>scipy/stats/_distn_infrastructure.py</td>
    </tr>
    <tr>
      <th>33057</th>
      <td>kernel_tests\distributions\beta_test.py</td>
      <td>255</td>
      <td>testBetaEntropy</td>
      <td>247</td>
      <td>assertAllClose</td>
      <td>1</td>
      <td>254</td>
      <td>stats.beta.entropy</td>
      <td>scipy/stats/_distn_infrastructure.py</td>
    </tr>
    <tr>
      <th>33367</th>
      <td>kernel_tests\distributions\exponential_test.py</td>
      <td>65</td>
      <td>testExponentialLogPDF</td>
      <td>49</td>
      <td>assertAllClose</td>
      <td>2</td>
      <td>64</td>
      <td>stats.expon.logpdf</td>
      <td>scipy/stats/_distn_infrastructure.py</td>
    </tr>
    <tr>
      <th>33369</th>
      <td>kernel_tests\distributions\exponential_test.py</td>
      <td>66</td>
      <td>testExponentialLogPDF</td>
      <td>49</td>
      <td>assertAllClose</td>
      <td>2</td>
      <td>64</td>
      <td>stats.expon.logpdf</td>
      <td>scipy/stats/_distn_infrastructure.py</td>
    </tr>
    <tr>
      <th>33374</th>
      <td>kernel_tests\distributions\exponential_test.py</td>
      <td>89</td>
      <td>testExponentialCDF</td>
      <td>75</td>
      <td>assertAllClose</td>
      <td>2</td>
      <td>88</td>
      <td>stats.expon.cdf</td>
      <td>scipy/stats/_distn_infrastructure.py</td>
    </tr>
    <tr>
      <th>33379</th>
      <td>kernel_tests\distributions\exponential_test.py</td>
      <td>105</td>
      <td>testExponentialLogSurvival</td>
      <td>91</td>
      <td>assertAllClose</td>
      <td>2</td>
      <td>104</td>
      <td>stats.expon.logsf</td>
      <td>scipy/stats/_distn_infrastructure.py</td>
    </tr>
    <tr>
      <th>33382</th>
      <td>kernel_tests\distributions\exponential_test.py</td>
      <td>114</td>
      <td>testExponentialMean</td>
      <td>107</td>
      <td>assertAllClose</td>
      <td>2</td>
      <td>113</td>
      <td>stats.expon.mean</td>
      <td>scipy/stats/_distn_infrastructure.py</td>
    </tr>
    <tr>
      <th>33384</th>
      <td>kernel_tests\distributions\exponential_test.py</td>
      <td>123</td>
      <td>testExponentialVariance</td>
      <td>116</td>
      <td>assertAllClose</td>
      <td>2</td>
      <td>122</td>
      <td>stats.expon.var</td>
      <td>scipy/stats/_distn_infrastructure.py</td>
    </tr>
    <tr>
      <th>33386</th>
      <td>kernel_tests\distributions\exponential_test.py</td>
      <td>133</td>
      <td>testExponentialEntropy</td>
      <td>126</td>
      <td>assertAllClose</td>
      <td>2</td>
      <td>132</td>
      <td>stats.expon.entropy</td>
      <td>scipy/stats/_distn_infrastructure.py</td>
    </tr>
    <tr>
      <th>33397</th>
      <td>kernel_tests\distributions\gamma_test.py</td>
      <td>77</td>
      <td>testGammaLogPDF</td>
      <td>62</td>
      <td>assertAllClose</td>
      <td>2</td>
      <td>76</td>
      <td>stats.gamma.logpdf</td>
      <td>scipy/stats/_distn_infrastructure.py</td>
    </tr>
    <tr>
      <th>33399</th>
      <td>kernel_tests\distributions\gamma_test.py</td>
      <td>78</td>
      <td>testGammaLogPDF</td>
      <td>62</td>
      <td>assertAllClose</td>
      <td>2</td>
      <td>76</td>
      <td>stats.gamma.logpdf</td>
      <td>scipy/stats/_distn_infrastructure.py</td>
    </tr>
    <tr>
      <th>33405</th>
      <td>kernel_tests\distributions\gamma_test.py</td>
      <td>105</td>
      <td>testGammaLogPDFMultidimensional</td>
      <td>88</td>
      <td>assertAllClose</td>
      <td>2</td>
      <td>104</td>
      <td>stats.gamma.logpdf</td>
      <td>scipy/stats/_distn_infrastructure.py</td>
    </tr>
    <tr>
      <th>33407</th>
      <td>kernel_tests\distributions\gamma_test.py</td>
      <td>106</td>
      <td>testGammaLogPDFMultidimensional</td>
      <td>88</td>
      <td>assertAllClose</td>
      <td>2</td>
      <td>104</td>
      <td>stats.gamma.logpdf</td>
      <td>scipy/stats/_distn_infrastructure.py</td>
    </tr>
    <tr>
      <th>33412</th>
      <td>kernel_tests\distributions\gamma_test.py</td>
      <td>126</td>
      <td>testGammaLogPDFMultidimensionalBroadcasting</td>
      <td>108</td>
      <td>assertAllClose</td>
      <td>2</td>
      <td>125</td>
      <td>stats.gamma.logpdf</td>
      <td>scipy/stats/_distn_infrastructure.py</td>
    </tr>
    <tr>
      <th>33414</th>
      <td>kernel_tests\distributions\gamma_test.py</td>
      <td>127</td>
      <td>testGammaLogPDFMultidimensionalBroadcasting</td>
      <td>108</td>
      <td>assertAllClose</td>
      <td>2</td>
      <td>125</td>
      <td>stats.gamma.logpdf</td>
      <td>scipy/stats/_distn_infrastructure.py</td>
    </tr>
    <tr>
      <th>33418</th>
      <td>kernel_tests\distributions\gamma_test.py</td>
      <td>143</td>
      <td>testGammaCDF</td>
      <td>129</td>
      <td>assertAllClose</td>
      <td>2</td>
      <td>142</td>
      <td>stats.gamma.cdf</td>
      <td>scipy/stats/_distn_infrastructure.py</td>
    </tr>
    <tr>
      <th>33421</th>
      <td>kernel_tests\distributions\gamma_test.py</td>
      <td>153</td>
      <td>testGammaMean</td>
      <td>145</td>
      <td>assertAllClose</td>
      <td>2</td>
      <td>152</td>
      <td>stats.gamma.mean</td>
      <td>scipy/stats/_distn_infrastructure.py</td>
    </tr>
    <tr>
      <th>33430</th>
      <td>kernel_tests\distributions\gamma_test.py</td>
      <td>191</td>
      <td>testGammaVariance</td>
      <td>183</td>
      <td>assertAllClose</td>
      <td>2</td>
      <td>190</td>
      <td>stats.gamma.var</td>
      <td>scipy/stats/_distn_infrastructure.py</td>
    </tr>
    <tr>
      <th>33433</th>
      <td>kernel_tests\distributions\gamma_test.py</td>
      <td>201</td>
      <td>testGammaStd</td>
      <td>193</td>
      <td>assertAllClose</td>
      <td>2</td>
      <td>200</td>
      <td>stats.gamma.std</td>
      <td>scipy/stats/_distn_infrastructure.py</td>
    </tr>
    <tr>
      <th>33436</th>
      <td>kernel_tests\distributions\gamma_test.py</td>
      <td>211</td>
      <td>testGammaEntropy</td>
      <td>203</td>
      <td>assertAllClose</td>
      <td>2</td>
      <td>210</td>
      <td>stats.gamma.entropy</td>
      <td>scipy/stats/_distn_infrastructure.py</td>
    </tr>
    <tr>
      <th>33466</th>
      <td>kernel_tests\distributions\laplace_test.py</td>
      <td>73</td>
      <td>testLaplaceLogPDF</td>
      <td>60</td>
      <td>assertAllClose</td>
      <td>2</td>
      <td>72</td>
      <td>stats.laplace.logpdf</td>
      <td>scipy/stats/_distn_infrastructure.py</td>
    </tr>
    <tr>
      <th>33471</th>
      <td>kernel_tests\distributions\laplace_test.py</td>
      <td>77</td>
      <td>testLaplaceLogPDF</td>
      <td>60</td>
      <td>assertAllClose</td>
      <td>2</td>
      <td>72</td>
      <td>stats.laplace.logpdf</td>
      <td>scipy/stats/_distn_infrastructure.py</td>
    </tr>
    <tr>
      <th>33476</th>
      <td>kernel_tests\distributions\laplace_test.py</td>
      <td>97</td>
      <td>testLaplaceLogPDFMultidimensional</td>
      <td>79</td>
      <td>assertAllClose</td>
      <td>2</td>
      <td>96</td>
      <td>stats.laplace.logpdf</td>
      <td>scipy/stats/_distn_infrastructure.py</td>
    </tr>
    <tr>
      <th>33478</th>
      <td>kernel_tests\distributions\laplace_test.py</td>
      <td>98</td>
      <td>testLaplaceLogPDFMultidimensional</td>
      <td>79</td>
      <td>assertAllClose</td>
      <td>2</td>
      <td>96</td>
      <td>stats.laplace.logpdf</td>
      <td>scipy/stats/_distn_infrastructure.py</td>
    </tr>
    <tr>
      <th>33483</th>
      <td>kernel_tests\distributions\laplace_test.py</td>
      <td>118</td>
      <td>testLaplaceLogPDFMultidimensionalBroadcasting</td>
      <td>100</td>
      <td>assertAllClose</td>
      <td>2</td>
      <td>117</td>
      <td>stats.laplace.logpdf</td>
      <td>scipy/stats/_distn_infrastructure.py</td>
    </tr>
    <tr>
      <th>33485</th>
      <td>kernel_tests\distributions\laplace_test.py</td>
      <td>119</td>
      <td>testLaplaceLogPDFMultidimensionalBroadcasting</td>
      <td>100</td>
      <td>assertAllClose</td>
      <td>2</td>
      <td>117</td>
      <td>stats.laplace.logpdf</td>
      <td>scipy/stats/_distn_infrastructure.py</td>
    </tr>
    <tr>
      <th>33489</th>
      <td>kernel_tests\distributions\laplace_test.py</td>
      <td>136</td>
      <td>testLaplaceCDF</td>
      <td>121</td>
      <td>assertAllClose</td>
      <td>2</td>
      <td>135</td>
      <td>stats.laplace.cdf</td>
      <td>scipy/stats/_distn_infrastructure.py</td>
    </tr>
    <tr>
      <th>33494</th>
      <td>kernel_tests\distributions\laplace_test.py</td>
      <td>153</td>
      <td>testLaplaceLogCDF</td>
      <td>138</td>
      <td>assertAllClose</td>
      <td>2</td>
      <td>152</td>
      <td>stats.laplace.logcdf</td>
      <td>scipy/stats/_distn_infrastructure.py</td>
    </tr>
    <tr>
      <th>33499</th>
      <td>kernel_tests\distributions\laplace_test.py</td>
      <td>170</td>
      <td>testLaplaceLogSurvivalFunction</td>
      <td>155</td>
      <td>assertAllClose</td>
      <td>2</td>
      <td>169</td>
      <td>stats.laplace.logsf</td>
      <td>scipy/stats/_distn_infrastructure.py</td>
    </tr>
    <tr>
      <th>33502</th>
      <td>kernel_tests\distributions\laplace_test.py</td>
      <td>180</td>
      <td>testLaplaceMean</td>
      <td>172</td>
      <td>assertAllClose</td>
      <td>2</td>
      <td>179</td>
      <td>stats.laplace.mean</td>
      <td>scipy/stats/_distn_infrastructure.py</td>
    </tr>
    <tr>
      <th>33507</th>
      <td>kernel_tests\distributions\laplace_test.py</td>
      <td>197</td>
      <td>testLaplaceVariance</td>
      <td>189</td>
      <td>assertAllClose</td>
      <td>2</td>
      <td>196</td>
      <td>stats.laplace.var</td>
      <td>scipy/stats/_distn_infrastructure.py</td>
    </tr>
    <tr>
      <th>33510</th>
      <td>kernel_tests\distributions\laplace_test.py</td>
      <td>207</td>
      <td>testLaplaceStd</td>
      <td>199</td>
      <td>assertAllClose</td>
      <td>2</td>
      <td>206</td>
      <td>stats.laplace.std</td>
      <td>scipy/stats/_distn_infrastructure.py</td>
    </tr>
    <tr>
      <th>33513</th>
      <td>kernel_tests\distributions\laplace_test.py</td>
      <td>217</td>
      <td>testLaplaceEntropy</td>
      <td>209</td>
      <td>assertAllClose</td>
      <td>2</td>
      <td>216</td>
      <td>stats.laplace.entropy</td>
      <td>scipy/stats/_distn_infrastructure.py</td>
    </tr>
    <tr>
      <th>33775</th>
      <td>kernel_tests\distributions\student_t_test.py</td>
      <td>75</td>
      <td>testStudentPDFAndLogPDF</td>
      <td>52</td>
      <td>assertAllClose</td>
      <td>1</td>
      <td>73</td>
      <td>stats.t.logpdf</td>
      <td>scipy/stats/_distn_infrastructure.py</td>
    </tr>
    <tr>
      <th>33777</th>
      <td>kernel_tests\distributions\student_t_test.py</td>
      <td>76</td>
      <td>testStudentPDFAndLogPDF</td>
      <td>52</td>
      <td>assertAllClose</td>
      <td>1</td>
      <td>74</td>
      <td>stats.t.pdf</td>
      <td>scipy/stats/_distn_infrastructure.py</td>
    </tr>
    <tr>
      <th>33779</th>
      <td>kernel_tests\distributions\student_t_test.py</td>
      <td>77</td>
      <td>testStudentPDFAndLogPDF</td>
      <td>52</td>
      <td>assertAllClose</td>
      <td>1</td>
      <td>74</td>
      <td>stats.t.pdf</td>
      <td>scipy/stats/_distn_infrastructure.py</td>
    </tr>
    <tr>
      <th>33780</th>
      <td>kernel_tests\distributions\student_t_test.py</td>
      <td>78</td>
      <td>testStudentPDFAndLogPDF</td>
      <td>52</td>
      <td>assertAllClose</td>
      <td>1</td>
      <td>73</td>
      <td>stats.t.logpdf</td>
      <td>scipy/stats/_distn_infrastructure.py</td>
    </tr>
    <tr>
      <th>33787</th>
      <td>kernel_tests\distributions\student_t_test.py</td>
      <td>102</td>
      <td>testStudentLogPDFMultidimensional</td>
      <td>80</td>
      <td>assertAllClose</td>
      <td>1</td>
      <td>100</td>
      <td>stats.t.logpdf</td>
      <td>scipy/stats/_distn_infrastructure.py</td>
    </tr>
    <tr>
      <th>33789</th>
      <td>kernel_tests\distributions\student_t_test.py</td>
      <td>103</td>
      <td>testStudentLogPDFMultidimensional</td>
      <td>80</td>
      <td>assertAllClose</td>
      <td>1</td>
      <td>101</td>
      <td>stats.t.pdf</td>
      <td>scipy/stats/_distn_infrastructure.py</td>
    </tr>
    <tr>
      <th>33791</th>
      <td>kernel_tests\distributions\student_t_test.py</td>
      <td>104</td>
      <td>testStudentLogPDFMultidimensional</td>
      <td>80</td>
      <td>assertAllClose</td>
      <td>1</td>
      <td>101</td>
      <td>stats.t.pdf</td>
      <td>scipy/stats/_distn_infrastructure.py</td>
    </tr>
    <tr>
      <th>33792</th>
      <td>kernel_tests\distributions\student_t_test.py</td>
      <td>105</td>
      <td>testStudentLogPDFMultidimensional</td>
      <td>80</td>
      <td>assertAllClose</td>
      <td>1</td>
      <td>100</td>
      <td>stats.t.logpdf</td>
      <td>scipy/stats/_distn_infrastructure.py</td>
    </tr>
    <tr>
      <th>33801</th>
      <td>kernel_tests\distributions\student_t_test.py</td>
      <td>129</td>
      <td>testStudentCDFAndLogCDF</td>
      <td>107</td>
      <td>assertAllClose</td>
      <td>1</td>
      <td>127</td>
      <td>stats.t.logcdf</td>
      <td>scipy/stats/_distn_infrastructure.py</td>
    </tr>
    <tr>
      <th>33803</th>
      <td>kernel_tests\distributions\student_t_test.py</td>
      <td>130</td>
      <td>testStudentCDFAndLogCDF</td>
      <td>107</td>
      <td>assertAllClose</td>
      <td>1</td>
      <td>128</td>
      <td>stats.t.cdf</td>
      <td>scipy/stats/_distn_infrastructure.py</td>
    </tr>
    <tr>
      <th>33805</th>
      <td>kernel_tests\distributions\student_t_test.py</td>
      <td>132</td>
      <td>testStudentCDFAndLogCDF</td>
      <td>107</td>
      <td>assertAllClose</td>
      <td>1</td>
      <td>128</td>
      <td>stats.t.cdf</td>
      <td>scipy/stats/_distn_infrastructure.py</td>
    </tr>
    <tr>
      <th>33806</th>
      <td>kernel_tests\distributions\student_t_test.py</td>
      <td>133</td>
      <td>testStudentCDFAndLogCDF</td>
      <td>107</td>
      <td>assertAllClose</td>
      <td>1</td>
      <td>127</td>
      <td>stats.t.logcdf</td>
      <td>scipy/stats/_distn_infrastructure.py</td>
    </tr>
    <tr>
      <th>33807</th>
      <td>kernel_tests\distributions\student_t_test.py</td>
      <td>156</td>
      <td>testStudentEntropy</td>
      <td>136</td>
      <td>assertAllClose</td>
      <td>1</td>
      <td>151</td>
      <td>stats.t.entropy</td>
      <td>scipy/stats/_distn_infrastructure.py</td>
    </tr>
  </tbody>
</table>
<br><button type="button" class="collapsible">Git Diff</button>
<div class="content">
<p>diff --git a/scipy/stats/_distn_infrastructure.py b/scipy/stats/_distn_infrastructure.py
<br>index 0e396b7f4..da3444878 100644
<br><span style="color:red">- -- a/scipy/stats/_distn_infrastructure.py</span>
<br><span style="color:green">+++ b/scipy/stats/_distn_infrastructure.py</span>
<br>@@ -2,25 +2,25 @@
<br>&nbsp# Author:  Travis Oliphant  2002-2011 with contributions from
<br>&nbsp#          SciPy Developers 2004-2011
<br>&nbsp#
<br><span style="color:red">- from __future__ import division, print_function, absolute_import</span>
<br><span style="color:red">- </span>
<br><span style="color:red">- from scipy._lib.six import string_types, exec_, PY3</span>
<br><span style="color:red">- from scipy._lib._util import getargspec_no_self as _getargspec</span>
<br><span style="color:green">+from scipy._lib._util import getfullargspec_no_self as _getfullargspec</span>
<br>&nbsp
<br>&nbspimport sys
<br>&nbspimport keyword
<br>&nbspimport re
<br>&nbspimport types
<br>&nbspimport warnings
<br><span style="color:green">+import inspect</span>
<br><span style="color:green">+from itertools import zip_longest</span>
<br>&nbsp
<br><span style="color:red">- from scipy.misc import doccer</span>
<br><span style="color:green">+from scipy._lib import doccer</span>
<br><span style="color:green">+from scipy._lib._util import _lazywhere</span>
<br>&nbspfrom ._distr_params import distcont, distdiscrete
<br><span style="color:red">- from scipy._lib._util import check_random_state, _lazywhere, _lazyselect</span>
<br><span style="color:red">- from scipy._lib._util import _valarray as valarray</span>
<br><span style="color:green">+from scipy._lib._util import check_random_state</span>
<br>&nbsp
<br><span style="color:red">- from scipy.special import (comb, chndtr, entr, rel_entr, kl_div, xlogy, ive)</span>
<br><span style="color:green">+from scipy.special import (comb, chndtr, entr, xlogy, ive)</span>
<br>&nbsp
<br><span style="color:red">- # for root finding for discrete distribution ppf, and max likelihood estimation</span>
<br><span style="color:green">+# for root finding for continuous distribution ppf, and max likelihood</span>
<br><span style="color:green">+# estimation</span>
<br>&nbspfrom scipy import optimize
<br>&nbsp
<br>&nbsp# for functions of continuous distributions (e.g. moments, entropy, cdf)
<br>@@ -29,23 +29,17 @@ from scipy import integrate
<br>&nbsp# to approximate the pdf of a continuous distribution given its cdf
<br>&nbspfrom scipy.misc import derivative
<br>&nbsp
<br><span style="color:red">- from numpy import (arange, putmask, ravel, take, ones, shape, ndarray,</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspproduct, reshape, zeros, floor, logical_and, log, sqrt, exp)</span>
<br><span style="color:green">+# for scipy.stats.entropy. Attempts to import just that function or file</span>
<br><span style="color:green">+# have cause import problems</span>
<br><span style="color:green">+from scipy import stats</span>
<br>&nbsp
<br><span style="color:red">- from numpy import (place, argsort, argmax, vectorize,</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspasarray, nan, inf, isinf, NINF, empty)</span>
<br><span style="color:green">+from numpy import (arange, putmask, ravel, ones, shape, ndarray, zeros, floor,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsplogical_and, log, sqrt, place, argmax, vectorize, asarray,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspnan, inf, isinf, NINF, empty)</span>
<br>&nbsp
<br>&nbspimport numpy as np
<br><span style="color:red">- </span>
<br>&nbspfrom ._constants import _XMAX
<br>&nbsp
<br><span style="color:red">- if PY3:</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspdef instancemethod(func, obj, cls):</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn types.MethodType(func, obj)</span>
<br><span style="color:red">- else:</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspinstancemethod = types.MethodType</span>
<br><span style="color:red">- </span>
<br><span style="color:red">- </span>
<br>&nbsp# These are the docstring parts used for substitution in specific
<br>&nbsp# distribution docstrings
<br>&nbsp
<br>@@ -54,92 +48,95 @@ docheaders = {'methods': """\nMethods\n-------\n""",
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp'examples': """\nExamples\n--------\n"""}
<br>&nbsp
<br>&nbsp_doc_rvs = """\
<br><span style="color:red">- ``rvs(%(shapes)s, loc=0, scale=1, size=1, random_state=None)``</span>
<br><span style="color:green">+rvs(%(shapes)s, loc=0, scale=1, size=1, random_state=None)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspRandom variates.
<br>&nbsp"""
<br>&nbsp_doc_pdf = """\
<br><span style="color:red">- ``pdf(x, %(shapes)s, loc=0, scale=1)``</span>
<br><span style="color:green">+pdf(x, %(shapes)s, loc=0, scale=1)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspProbability density function.
<br>&nbsp"""
<br>&nbsp_doc_logpdf = """\
<br><span style="color:red">- ``logpdf(x, %(shapes)s, loc=0, scale=1)``</span>
<br><span style="color:green">+logpdf(x, %(shapes)s, loc=0, scale=1)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspLog of the probability density function.
<br>&nbsp"""
<br>&nbsp_doc_pmf = """\
<br><span style="color:red">- ``pmf(k, %(shapes)s, loc=0, scale=1)``</span>
<br><span style="color:green">+pmf(k, %(shapes)s, loc=0, scale=1)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspProbability mass function.
<br>&nbsp"""
<br>&nbsp_doc_logpmf = """\
<br><span style="color:red">- ``logpmf(k, %(shapes)s, loc=0, scale=1)``</span>
<br><span style="color:green">+logpmf(k, %(shapes)s, loc=0, scale=1)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspLog of the probability mass function.
<br>&nbsp"""
<br>&nbsp_doc_cdf = """\
<br><span style="color:red">- ``cdf(x, %(shapes)s, loc=0, scale=1)``</span>
<br><span style="color:green">+cdf(x, %(shapes)s, loc=0, scale=1)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspCumulative distribution function.
<br>&nbsp"""
<br>&nbsp_doc_logcdf = """\
<br><span style="color:red">- ``logcdf(x, %(shapes)s, loc=0, scale=1)``</span>
<br><span style="color:green">+logcdf(x, %(shapes)s, loc=0, scale=1)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspLog of the cumulative distribution function.
<br>&nbsp"""
<br>&nbsp_doc_sf = """\
<br><span style="color:red">- ``sf(x, %(shapes)s, loc=0, scale=1)``</span>
<br><span style="color:green">+sf(x, %(shapes)s, loc=0, scale=1)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspSurvival function  (also defined as ``1 - cdf``, but `sf` is sometimes more accurate).
<br>&nbsp"""
<br>&nbsp_doc_logsf = """\
<br><span style="color:red">- ``logsf(x, %(shapes)s, loc=0, scale=1)``</span>
<br><span style="color:green">+logsf(x, %(shapes)s, loc=0, scale=1)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspLog of the survival function.
<br>&nbsp"""
<br>&nbsp_doc_ppf = """\
<br><span style="color:red">- ``ppf(q, %(shapes)s, loc=0, scale=1)``</span>
<br><span style="color:green">+ppf(q, %(shapes)s, loc=0, scale=1)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspPercent point function (inverse of ``cdf`` --- percentiles).
<br>&nbsp"""
<br>&nbsp_doc_isf = """\
<br><span style="color:red">- ``isf(q, %(shapes)s, loc=0, scale=1)``</span>
<br><span style="color:green">+isf(q, %(shapes)s, loc=0, scale=1)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspInverse survival function (inverse of ``sf``).
<br>&nbsp"""
<br>&nbsp_doc_moment = """\
<br><span style="color:red">- ``moment(n, %(shapes)s, loc=0, scale=1)``</span>
<br><span style="color:green">+moment(n, %(shapes)s, loc=0, scale=1)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspNon-central moment of order n
<br>&nbsp"""
<br>&nbsp_doc_stats = """\
<br><span style="color:red">- ``stats(%(shapes)s, loc=0, scale=1, moments='mv')``</span>
<br><span style="color:green">+stats(%(shapes)s, loc=0, scale=1, moments='mv')</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspMean('m'), variance('v'), skew('s'), and/or kurtosis('k').
<br>&nbsp"""
<br>&nbsp_doc_entropy = """\
<br><span style="color:red">- ``entropy(%(shapes)s, loc=0, scale=1)``</span>
<br><span style="color:green">+entropy(%(shapes)s, loc=0, scale=1)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp(Differential) entropy of the RV.
<br>&nbsp"""
<br>&nbsp_doc_fit = """\
<br><span style="color:red">- ``fit(data, %(shapes)s, loc=0, scale=1)``</span>
<br><span style="color:green">+fit(data)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspParameter estimates for generic data.
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspSee `scipy.stats.rv_continuous.fit <https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html#scipy.stats.rv_continuous.fit>`__ for detailed documentation of the</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspkeyword arguments.</span>
<br>&nbsp"""
<br>&nbsp_doc_expect = """\
<br><span style="color:red">- ``expect(func, args=(%(shapes_)s), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)``</span>
<br><span style="color:green">+expect(func, args=(%(shapes_)s), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspExpected value of a function (of one argument) with respect to the distribution.
<br>&nbsp"""
<br>&nbsp_doc_expect_discrete = """\
<br><span style="color:red">- ``expect(func, args=(%(shapes_)s), loc=0, lb=None, ub=None, conditional=False)``</span>
<br><span style="color:green">+expect(func, args=(%(shapes_)s), loc=0, lb=None, ub=None, conditional=False)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspExpected value of a function (of one argument) with respect to the distribution.
<br>&nbsp"""
<br>&nbsp_doc_median = """\
<br><span style="color:red">- ``median(%(shapes)s, loc=0, scale=1)``</span>
<br><span style="color:green">+median(%(shapes)s, loc=0, scale=1)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspMedian of the distribution.
<br>&nbsp"""
<br>&nbsp_doc_mean = """\
<br><span style="color:red">- ``mean(%(shapes)s, loc=0, scale=1)``</span>
<br><span style="color:green">+mean(%(shapes)s, loc=0, scale=1)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspMean of the distribution.
<br>&nbsp"""
<br>&nbsp_doc_var = """\
<br><span style="color:red">- ``var(%(shapes)s, loc=0, scale=1)``</span>
<br><span style="color:green">+var(%(shapes)s, loc=0, scale=1)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspVariance of the distribution.
<br>&nbsp"""
<br>&nbsp_doc_std = """\
<br><span style="color:red">- ``std(%(shapes)s, loc=0, scale=1)``</span>
<br><span style="color:green">+std(%(shapes)s, loc=0, scale=1)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspStandard deviation of the distribution.
<br>&nbsp"""
<br>&nbsp_doc_interval = """\
<br><span style="color:red">- ``interval(alpha, %(shapes)s, loc=0, scale=1)``</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspEndpoints of the range that contains alpha percent of the distribution</span>
<br><span style="color:green">+interval(alpha, %(shapes)s, loc=0, scale=1)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspEndpoints of the range that contains fraction alpha [0, 1] of the</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdistribution</span>
<br>&nbsp"""
<br>&nbsp_doc_allmethods = ''.join([docheaders['methods'], _doc_rvs, _doc_pdf,
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp_doc_logpdf, _doc_cdf, _doc_logcdf, _doc_sf,
<br>@@ -169,7 +166,7 @@ Examples
<br>&nbsp>>> import matplotlib.pyplot as plt
<br>&nbsp>>> fig, ax = plt.subplots(1, 1)
<br>&nbsp
<br><span style="color:red">- Calculate a few first moments:</span>
<br><span style="color:green">+Calculate the first four moments:</span>
<br>&nbsp
<br>&nbsp%(set_vals_stmt)s
<br>&nbsp>>> mean, var, skew, kurt = %(name)s.stats(%(shapes)s, moments='mvsk')
<br>@@ -202,7 +199,7 @@ Generate random numbers:
<br>&nbsp
<br>&nbspAnd compare the histogram:
<br>&nbsp
<br><span style="color:red">- >>> ax.hist(r, normed=True, histtype='stepfilled', alpha=0.2)</span>
<br><span style="color:green">+>>> ax.hist(r, density=True, histtype='stepfilled', alpha=0.2)</span>
<br>&nbsp>>> ax.legend(loc='best', frameon=False)
<br>&nbsp>>> plt.show()
<br>&nbsp
<br>@@ -213,7 +210,9 @@ The probability density above is defined in the "standardized" form. To shift
<br>&nbspand/or scale the distribution use the ``loc`` and ``scale`` parameters.
<br>&nbspSpecifically, ``%(name)s.pdf(x, %(shapes)s, loc, scale)`` is identically
<br>&nbspequivalent to ``%(name)s.pdf(y, %(shapes)s) / scale`` with
<br><span style="color:red">- ``y = (x - loc) / scale``.</span>
<br><span style="color:green">+``y = (x - loc) / scale``. Note that shifting the location of a distribution</span>
<br><span style="color:green">+does not make it a "noncentral" distribution; noncentral generalizations of</span>
<br><span style="color:green">+some distributions are available in separate classes.</span>
<br>&nbsp"""
<br>&nbsp
<br>&nbsp_doc_default = ''.join([_doc_default_longsummary,
<br>@@ -296,7 +295,7 @@ Examples
<br>&nbsp>>> import matplotlib.pyplot as plt
<br>&nbsp>>> fig, ax = plt.subplots(1, 1)
<br>&nbsp
<br><span style="color:red">- Calculate a few first moments:</span>
<br><span style="color:green">+Calculate the first four moments:</span>
<br>&nbsp
<br>&nbsp%(set_vals_stmt)s
<br>&nbsp>>> mean, var, skew, kurt = %(name)s.stats(%(shapes)s, moments='mvsk')
<br>@@ -356,11 +355,6 @@ docdict_discrete['default'] = _doc_default_disc
<br>&nbspfor obj in [s for s in dir() if s.startswith('_doc_')]:
<br>&nbsp &nbsp &nbsp &nbsp &nbspexec('del ' + obj)
<br>&nbspdel obj
<br><span style="color:red">- try:</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspdel s</span>
<br><span style="color:red">- except NameError:</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp# in Python 3, loop variables are not visible after the loop</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsppass</span>
<br>&nbsp
<br>&nbsp
<br>&nbspdef _moment(data, n, mu=None):
<br>@@ -413,9 +407,7 @@ def _skew(data):
<br>&nbsp
<br>&nbsp
<br>&nbspdef _kurtosis(data):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspkurtosis is fourth central moment / variance**2 - 3</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp"""kurtosis is fourth central moment / variance**2 - 3."""</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspdata = np.ravel(data)
<br>&nbsp &nbsp &nbsp &nbsp &nbspmu = data.mean()
<br>&nbsp &nbsp &nbsp &nbsp &nbspm2 = ((data - mu)**2).mean()
<br>@@ -423,8 +415,21 @@ def _kurtosis(data):
<br>&nbsp &nbsp &nbsp &nbsp &nbspreturn m4 / m2**2 - 3
<br>&nbsp
<br>&nbsp
<br><span style="color:green">+def _fit_determine_optimizer(optimizer):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspif not callable(optimizer) and isinstance(optimizer, str):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif not optimizer.startswith('fmin_'):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoptimizer = "fmin_"+optimizer</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif optimizer == 'fmin_':</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoptimizer = 'fmin'</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsptry:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoptimizer = getattr(optimize, optimizer)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspexcept AttributeError as e:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("%s is not a valid optimizer" % optimizer) from e</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspreturn optimizer</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+</span>
<br>&nbsp# Frozen RV class
<br><span style="color:red">- class rv_frozen(object):</span>
<br><span style="color:green">+class rv_frozen:</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef __init__(self, dist, *args, **kwds):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.args = args
<br>@@ -433,10 +438,8 @@ class rv_frozen(object):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# create a new instance
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.dist = dist.__class__(**dist._updated_ctor_param())
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# a, b may be set in _argcheck, depending on *args, **kwds. Ouch.</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspshapes, _, _ = self.dist._parse_args(*args, **kwds)
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.dist._argcheck(*shapes)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.a, self.b = self.dist.a, self.dist.b</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.a, self.b = self.dist._get_support(*shapes)</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp@property
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef random_state(self):
<br>@@ -519,34 +522,61 @@ class rv_frozen(object):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn self.dist.expect(func, a, loc, scale, lb, ub,
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspconditional, **kwds)
<br>&nbsp
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdef support(self):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn self.dist.support(*self.args, **self.kwds)</span>
<br><span style="color:green">+</span>
<br>&nbsp
<br><span style="color:red">- # This should be rewritten</span>
<br>&nbspdef argsreduce(cond, *args):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp"""Return the sequence of ravel(args[i]) where ravel(condition) is</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspTrue in 1D.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp"""Clean arguments to:</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp1. Ensure all arguments are iterable (arrays of dimension at least one</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp2. If cond != True and size > 1, ravel(args[i]) where ravel(condition) is</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspTrue, in 1D.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspReturn list of processed arguments.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspExamples
<br>&nbsp &nbsp &nbsp &nbsp &nbsp--------
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp>>> import numpy as np</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp>>> rand = np.random.random_sample</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp>>> A = rand((4, 5))</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> rng = np.random.default_rng()</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> A = rng.random((4, 5))</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp>>> B = 2
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp>>> C = rand((1, 5))</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> C = rng.random((1, 5))</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp>>> cond = np.ones(A.shape)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp>>> [A1, B1, C1] = argsreduce(cond, A, B, C)
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> A1.shape</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp(4, 5)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp>>> B1.shape
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp(20,)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp(1,)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> C1.shape</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp(1, 5)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp>>> cond[2,:] = 0
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp>>> [A2, B2, C2] = argsreduce(cond, A, B, C)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp>>> B2.shape</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> [A1, B1, C1] = argsreduce(cond, A, B, C)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> A1.shape</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp(15,)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> B1.shape</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp(1,)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> C1.shape</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp(15,)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp# some distributions assume arguments are iterable.</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspnewargs = np.atleast_1d(*args)
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp# np.atleast_1d returns an array if only one argument, or a list of arrays</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp# if more than one argument.</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspif not isinstance(newargs, list):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspnewargs = [newargs, ]
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspexpand_arr = (cond == cond)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspreturn [np.extract(cond, arr1 * expand_arr) for arr1 in newargs]</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspif np.all(cond):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# Nothing to do</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn newargs</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsps = cond.shape</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp# np.extract returns flattened arrays, which are not broadcastable together</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp# unless they are either the same size or size == 1.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspreturn [(arg if np.size(arg) == 1</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelse np.extract(cond, np.broadcast_to(arg, s)))</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspfor arg in newargs]</span>
<br>&nbsp
<br>&nbsp
<br>&nbspparse_arg_template = """
<br>@@ -562,50 +592,78 @@ def _parse_args_stats(self, %(shape_arg_str)s %(locscale_in)s, moments='mv'):
<br>&nbsp
<br>&nbsp
<br>&nbsp# Both the continuous and discrete distributions depend on ncx2.
<br><span style="color:red">- # I think the function name ncx2 is an abbreviation for noncentral chi squared.</span>
<br><span style="color:green">+# The function name ncx2 is an abbreviation for noncentral chi squared.</span>
<br>&nbsp
<br>&nbspdef _ncx2_log_pdf(x, df, nc):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp# We use (xs**2 + ns**2)/2 = (xs - ns)**2/2  + xs*ns, and include the factor</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp# of exp(-xs*ns) into the ive function to improve numerical stability</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp# at large values of xs. See also `rice.pdf`.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp# We use (xs**2 + ns**2)/2 = (xs - ns)**2/2  + xs*ns, and include the</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp# factor of exp(-xs*ns) into the ive function to improve numerical</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp# stability at large values of xs. See also `rice.pdf`.</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspdf2 = df/2.0 - 1.0
<br>&nbsp &nbsp &nbsp &nbsp &nbspxs, ns = np.sqrt(x), np.sqrt(nc)
<br>&nbsp &nbsp &nbsp &nbsp &nbspres = xlogy(df2/2.0, x/nc) - 0.5*(xs - ns)**2
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspres += np.log(ive(df2, xs*ns) / 2.0)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspreturn res</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspcorr = ive(df2, xs*ns) / 2.0</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp# Return res + np.log(corr) avoiding np.log(0)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspreturn _lazywhere(</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcorr > 0,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp(res, corr),</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspf=lambda r, c: r + np.log(c),</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspfillvalue=-np.inf)</span>
<br>&nbsp
<br>&nbsp
<br>&nbspdef _ncx2_pdf(x, df, nc):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspreturn np.exp(_ncx2_log_pdf(x, df, nc))</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp# Copy of _ncx2_log_pdf avoiding np.log(0) when corr = 0</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdf2 = df/2.0 - 1.0</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspxs, ns = np.sqrt(x), np.sqrt(nc)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspres = xlogy(df2/2.0, x/nc) - 0.5*(xs - ns)**2</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspcorr = ive(df2, xs*ns) / 2.0</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspreturn np.exp(res) * corr</span>
<br>&nbsp
<br>&nbsp
<br>&nbspdef _ncx2_cdf(x, df, nc):
<br>&nbsp &nbsp &nbsp &nbsp &nbspreturn chndtr(x, df, nc)
<br>&nbsp
<br>&nbsp
<br><span style="color:red">- class rv_generic(object):</span>
<br><span style="color:green">+class rv_generic:</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""Class which encapsulates common functionality between rv_discrete
<br>&nbsp &nbsp &nbsp &nbsp &nbspand rv_continuous.
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef __init__(self, seed=None):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsuper(rv_generic, self).__init__()</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsuper().__init__()</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# figure out if _stats signature has 'moments' keyword
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsign = _getargspec(self._stats)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._stats_has_moments = ((sign[2] is not None) or</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp('moments' in sign[0]))</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsig = _getfullargspec(self._stats)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._stats_has_moments = ((sig.varkw is not None) or</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp('moments' in sig.args) or</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp('moments' in sig.kwonlyargs))</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._random_state = check_random_state(seed)
<br>&nbsp
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# For historical reasons, `size` was made an attribute that was read</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# inside _rvs().  The code is being changed so that 'size'</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# is an argument</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# to self._rvs(). However some external (non-SciPy) distributions</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# have not</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# been updated.  Maintain backwards compatibility by checking if</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# the self._rvs() signature has the 'size' keyword, or a **kwarg,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# and if not set self._size inside self.rvs()</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# before calling self._rvs().</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspargspec = inspect.getfullargspec(self._rvs)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._rvs_uses_size_attribute = (argspec.varkw is None and</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp'size' not in argspec.args and</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp'size' not in argspec.kwonlyargs)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# Warn on first use only</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._rvs_size_warned = False</span>
<br><span style="color:green">+</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp@property
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef random_state(self):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp""" Get or set the RandomState object for generating random variates.</span>
<br><span style="color:red">- </span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThis can be either None or an existing RandomState object.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Get or set the generator object for generating random variates.</span>
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf None (or np.random), use the RandomState singleton used by np.random.</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf already a RandomState instance, use it.</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf an int, use a new RandomState instance seeded with seed.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf `seed` is None (or `np.random`), the `numpy.random.RandomState`</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsingleton is used.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf `seed` is an int, a new ``RandomState`` instance is used,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspseeded with `seed`.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf `seed` is already a ``Generator`` or ``RandomState`` instance then</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspthat instance is used.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn self._random_state
<br>@@ -614,22 +672,53 @@ class rv_generic(object):
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef random_state(self, seed):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._random_state = check_random_state(seed)
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspdef __getstate__(self):</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn self._updated_ctor_param(), self._random_state</span>
<br><span style="color:red">- </span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef __setstate__(self, state):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspctor_param, r = state</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.__init__(**ctor_param)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._random_state = r</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn self</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsptry:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.__dict__.update(state)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# attaches the dynamically created methods on each instance.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# if a subclass overrides rv_generic.__setstate__, or implements</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# it's own _attach_methods, then it must make sure that</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# _attach_argparser_methods is called.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._attach_methods()</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspexcept ValueError:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# reconstitute an old pickle scipy<1.6, that contains</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# (_ctor_param, random_state) as state</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._ctor_param = state[0]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._random_state = state[1]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.__init__()</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdef _attach_methods(self):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Attaches dynamically created methods to the rv_* instance.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThis method must be overridden by subclasses, and must itself call</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp_attach_argparser_methods. This method is called in __init__ in</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsubclasses, and in __setstate__</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise NotImplementedError</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdef _attach_argparser_methods(self):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspGenerates the argument-parsing functions dynamically and attaches</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspthem to the instance.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspShould be called from `_attach_methods`, typically in __init__ and</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspduring unpickling (__setstate__)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspns = {}</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspexec(self._parse_arg_template, ns)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# NB: attach to the instance, not class</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspfor name in ['_parse_args', '_parse_args_stats', '_parse_args_rvs']:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsetattr(self, name, types.MethodType(ns[name], self))</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef _construct_argparser(
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself, meths_to_inspect, locscale_in, locscale_out):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Construct the parser for the shape arguments.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Construct the parser string for the shape arguments.</span>
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspGenerates the argument-parsing functions dynamically and attaches</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspthem to the instance.</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIs supposed to be called in __init__ of a class for each distribution.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThis method should be called in __init__ of a class for each</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdistribution. It creates the `_parse_arg_template` attribute that is</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspthen used by `_attach_argparser_methods` to dynamically create and</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspattach the `_parse_args`, `_parse_args_stats`, `_parse_args_rvs`</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmethods to the instance.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf self.shapes is a non-empty string, interprets it as a
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcomma-separated list of shape parameters.
<br>@@ -641,7 +730,7 @@ class rv_generic(object):
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif self.shapes:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# sanitize the user-supplied shapes
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif not isinstance(self.shapes, string_types):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif not isinstance(self.shapes, str):</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise TypeError('shapes must be a string.')
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspshapes = self.shapes.replace(',', ' ').split()
<br>@@ -658,7 +747,7 @@ class rv_generic(object):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# are shapes.
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspshapes_list = []
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspfor meth in meths_to_inspect:
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspshapes_args = _getargspec(meth)   # NB: does not contain self</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspshapes_args = _getfullargspec(meth)  # NB does not contain self</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspargs = shapes_args.args[1:]       # peel off 'x', too
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif args:
<br>@@ -668,9 +757,12 @@ class rv_generic(object):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif shapes_args.varargs is not None:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise TypeError(
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp'*args are not allowed w/out explicit shapes')
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif shapes_args.keywords is not None:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif shapes_args.varkw is not None:</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise TypeError(
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp'**kwds are not allowed w/out explicit shapes')
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif shapes_args.kwonlyargs:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise TypeError(</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp'kwonly args are not allowed w/out explicit shapes')</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif shapes_args.defaults is not None:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise TypeError('defaults are not allowed for shapes')
<br>&nbsp
<br>@@ -690,13 +782,9 @@ class rv_generic(object):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsplocscale_in=locscale_in,
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsplocscale_out=locscale_out,
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp)
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspns = {}</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspexec_(parse_arg_template % dct, ns)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# NB: attach to the instance, not class</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspfor name in ['_parse_args', '_parse_args_stats', '_parse_args_rvs']:</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsetattr(self, name,</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspinstancemethod(ns[name], self, self.__class__)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# this string is used by _attach_argparser_methods</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._parse_arg_template = parse_arg_template % dct</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.shapes = ', '.join(shapes) if shapes else None
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif not hasattr(self, 'numargs'):
<br>@@ -732,13 +820,18 @@ class rv_generic(object):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif self.shapes is None:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# necessary because we use %(shapes)s in two forms (w w/o ", ")
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.__doc__ = self.__doc__.replace("%(shapes)s, ", "")
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.__doc__ = doccer.docformat(self.__doc__, tempdict)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsptry:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.__doc__ = doccer.docformat(self.__doc__, tempdict)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspexcept TypeError as e:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise Exception("Unable to construct docstring for "</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"distribution \"%s\": %s" %</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp(self.name, repr(e))) from e</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# correct for empty shapes
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.__doc__ = self.__doc__.replace('(, ', '(').replace(', )', ')')
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef _construct_default_doc(self, longname=None, extradoc=None,
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdocdict=None, discrete='continuous'):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdocdict=None, discrete='continuous'):</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Construct instance docstring from the default template."""
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif longname is None:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsplongname = 'A'
<br>@@ -778,12 +871,13 @@ class rv_generic(object):
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef _stats(self, *args, **kwds):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn None, None, None, None
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp#  Central moments</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp# Noncentral moments (also known as the moment about the origin).</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp# Expressed in LaTeX, munp would be $\mu'_{n}$, i.e. "mu-sub-n-prime".</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp# The primed mu is a widely used notation for the noncentral moment.</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef _munp(self, n, *args):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# Silence floating point warnings from integration.
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspolderr = np.seterr(all='ignore')</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspvals = self.generic_moment(n, *args)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspnp.seterr(**olderr)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspwith np.errstate(all='ignore'):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspvals = self.generic_moment(n, *args)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn vals
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef _argcheck_rvs(self, *args, **kwargs):
<br>@@ -849,7 +943,8 @@ class rv_generic(object):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspfor (bcdim, szdim) in zip(bcast_shape, size_)])
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif not ok:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("size does not match the broadcast shape of "
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"the parameters.")</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"the parameters. %s, %s, %s" % (size, size_,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspbcast_shape))</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspparam_bcast = all_bcast[:-2]
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsploc_bcast = all_bcast[-2]
<br>@@ -857,9 +952,9 @@ class rv_generic(object):
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn param_bcast, loc_bcast, scale_bcast, size_
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp## These are the methods you must define (standard form functions)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp## NB: generic _pdf, _logpdf, _cdf are different for</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp## rv_continuous and rv_discrete hence are defined in there</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp# These are the methods you must define (standard form functions)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp# NB: generic _pdf, _logpdf, _cdf are different for</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp# rv_continuous and rv_discrete hence are defined in there</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef _argcheck(self, *args):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Default check for correct values on args and keywords.
<br>&nbsp
<br>@@ -872,31 +967,59 @@ class rv_generic(object):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond = logical_and(cond, (asarray(arg) > 0))
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn cond
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspdef _support_mask(self, x):</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn (self.a <= x) & (x <= self.b)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdef _get_support(self, *args, **kwargs):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Return the support of the (unscaled, unshifted) distribution.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp*Must* be overridden by distributions which have support dependent</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspupon the shape parameters of the distribution.  Any such override</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp*must not* set or change any of the class members, as these members</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspare shared amongst all instances of the distribution.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsparg1, arg2, ... : array_like</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThe shape parameter(s) for the distribution (see docstring of the</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspinstance object for more information).</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspReturns</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp-------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspa, b : numeric (float, or int or +/-np.inf)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspend-points of the distribution's support for the specified</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspshape parameters.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn self.a, self.b</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdef _support_mask(self, x, *args):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspa, b = self._get_support(*args)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspwith np.errstate(invalid='ignore'):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn (a <= x) & (x <= b)</span>
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspdef _open_support_mask(self, x):</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn (self.a < x) & (x < self.b)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdef _open_support_mask(self, x, *args):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspa, b = self._get_support(*args)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspwith np.errstate(invalid='ignore'):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn (a < x) & (x < b)</span>
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspdef _rvs(self, *args):</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# This method must handle self._size being a tuple, and it must</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# properly broadcast *args and self._size.  self._size might be</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdef _rvs(self, *args, size=None, random_state=None):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# This method must handle size being a tuple, and it must</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# properly broadcast *args and size.  size might be</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# an empty tuple, which means a scalar random variate is to be
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# generated.
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp## Use basic inverse cdf algorithm for RV generation as default.</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspU = self._random_state.random_sample(self._size)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# Use basic inverse cdf algorithm for RV generation as default.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspU = random_state.uniform(size=size)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspY = self._ppf(U, *args)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn Y
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef _logcdf(self, x, *args):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn log(self._cdf(x, *args))</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspwith np.errstate(divide='ignore'):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn log(self._cdf(x, *args))</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef _sf(self, x, *args):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn 1.0-self._cdf(x, *args)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef _logsf(self, x, *args):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn log(self._sf(x, *args))</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspwith np.errstate(divide='ignore'):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn log(self._sf(x, *args))</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef _ppf(self, q, *args):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn self._ppfvec(q, *args)
<br>@@ -907,8 +1030,7 @@ class rv_generic(object):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp# These are actually called, and should not be overwritten if you
<br>&nbsp &nbsp &nbsp &nbsp &nbsp# want to keep error checking.
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef rvs(self, *args, **kwds):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspRandom variates of given type.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Random variates of given type.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -921,10 +1043,15 @@ class rv_generic(object):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspScale parameter (default=1).
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsize : int or tuple of ints, optional
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspDefining number of random variates (default is 1).
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprandom_state : None or int or ``np.random.RandomState`` instance, optional</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf int or RandomState, use it for drawing the random variates.</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf None, rely on ``self.random_state``.</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspDefault is None.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprandom_state : {None, int, `numpy.random.Generator`,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp`numpy.random.RandomState`}, optional</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf `seed` is None (or `np.random`), the `numpy.random.RandomState`</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsingleton is used.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf `seed` is an int, a new ``RandomState`` instance is used,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspseeded with `seed`.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf `seed` is already a ``Generator`` or ``RandomState`` instance</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspthen that instance is used.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspReturns
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp-------
<br>@@ -945,13 +1072,24 @@ class rv_generic(object):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# extra gymnastics needed for a custom random_state
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif rndm is not None:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprandom_state_saved = self._random_state
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._random_state = check_random_state(rndm)</span>
<br><span style="color:red">- </span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# `size` should just be an argument to _rvs(), but for, um,</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# historical reasons, it is made an attribute that is read</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# by _rvs().</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._size = size</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspvals = self._rvs(*args)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprandom_state = check_random_state(rndm)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelse:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprandom_state = self._random_state</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# Maintain backwards compatibility by setting self._size</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# for distributions that still need it.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif self._rvs_uses_size_attribute:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif not self._rvs_size_warned:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspwarnings.warn(</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspf'The signature of {self._rvs} does not contain '</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspf'a "size" keyword.  Such signatures are deprecated.',</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspnp.VisibleDeprecationWarning)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._rvs_size_warned = True</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._size = size</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._random_state = random_state</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspvals = self._rvs(*args)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelse:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspvals = self._rvs(*args, size=size, random_state=random_state)</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspvals = vals * scale + loc
<br>&nbsp
<br>@@ -969,8 +1107,7 @@ class rv_generic(object):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn vals
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef stats(self, *args, **kwds):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspSome statistics of the given RV.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Some statistics of the given RV.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -1001,7 +1138,7 @@ class rv_generic(object):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspargs = tuple(map(asarray, args))
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond = self._argcheck(*args) & (scale > 0) & (loc == loc)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoutput = []
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdefault = valarray(shape(cond), self.badvalue)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdefault = np.full(shape(cond), fill_value=self.badvalue)</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# Use only entries that are valid in calculation
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif np.any(cond):
<br>@@ -1034,10 +1171,9 @@ class rv_generic(object):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmu2p = self._munp(2, *goodargs)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif mu is None:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmu = self._munp(1, *goodargs)
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmu2 = mu2p - mu * mu</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif np.isinf(mu):</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# if mean is inf then var is also inf</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmu2 = np.inf</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# if mean is inf then var is also inf</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspwith np.errstate(invalid='ignore'):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmu2 = np.where(np.isfinite(mu), mu2p - mu**2, np.inf)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspout0 = default.copy()
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspplace(out0, cond, mu2 * scale * scale)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoutput.append(out0)
<br>@@ -1051,7 +1187,7 @@ class rv_generic(object):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmu2p = self._munp(2, *goodargs)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmu2 = mu2p - mu * mu
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspwith np.errstate(invalid='ignore'):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmu3 = mu3p - 3 * mu * mu2 - mu**3</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmu3 = (-mu*mu - 3*mu2)*mu + mu3p</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspg1 = mu3 / np.power(mu2, 1.5)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspout0 = default.copy()
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspplace(out0, cond, g1)
<br>@@ -1068,18 +1204,15 @@ class rv_generic(object):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif mu3 is None:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmu3p = self._munp(3, *goodargs)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspwith np.errstate(invalid='ignore'):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmu3 = mu3p - 3 * mu * mu2 - mu**3</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmu3 = (-mu * mu - 3 * mu2) * mu + mu3p</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspwith np.errstate(invalid='ignore'):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmu4 = mu4p - 4 * mu * mu3 - 6 * mu * mu * mu2 - mu**4</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmu4 = ((-mu**2 - 6*mu2) * mu - 4*mu3)*mu + mu4p</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspg2 = mu4 / mu2**2.0 - 3.0
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspout0 = default.copy()
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspplace(out0, cond, g2)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoutput.append(out0)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelse:  # no valid args
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoutput = []</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspfor _ in moments:</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspout0 = default.copy()</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoutput.append(out0)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoutput = [default.copy() for _ in moments]</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif len(output) == 1:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn output[0]
<br>@@ -1087,8 +1220,7 @@ class rv_generic(object):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn tuple(output)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef entropy(self, *args, **kwds):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspDifferential entropy of the RV.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Differential entropy of the RV.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -1111,17 +1243,19 @@ class rv_generic(object):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspargs, loc, scale = self._parse_args(*args, **kwds)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# NB: for discrete distributions scale=1 by construction in _parse_args
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsploc, scale = map(asarray, (loc, scale))</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspargs = tuple(map(asarray, args))
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond0 = self._argcheck(*args) & (scale > 0) & (loc == loc)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoutput = zeros(shape(cond0), 'd')
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspplace(output, (1-cond0), self.badvalue)
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspgoodargs = argsreduce(cond0, *args)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspplace(output, cond0, self.vecentropy(*goodargs) + log(scale))</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspgoodargs = argsreduce(cond0, scale, *args)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspgoodscale = goodargs[0]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspgoodargs = goodargs[1:]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspplace(output, cond0, self.vecentropy(*goodargs) + log(goodscale))</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn output
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef moment(self, n, *args, **kwds):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspn-th order non-central moment of distribution.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""n-th order non-central moment of distribution.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -1136,9 +1270,17 @@ class rv_generic(object):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspscale parameter (default=1)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspargs, loc, scale = self._parse_args(*args, **kwds)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif not (self._argcheck(*args) and (scale > 0)):</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn nan</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspshapes, loc, scale = self._parse_args(*args, **kwds)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspargs = np.broadcast_arrays(*(*shapes, loc, scale))</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp*shapes, loc, scale = args</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspi0 = np.logical_and(self._argcheck(*shapes), scale > 0)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspi1 = np.logical_and(i0, loc == 0)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspi2 = np.logical_and(i0, loc != 0)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspargs = argsreduce(i0, *shapes, loc, scale)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp*shapes, loc, scale = args</span>
<br><span style="color:green">+</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif (floor(n) != n):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("Moment must be an integer.")
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif (n < 0):
<br>@@ -1149,25 +1291,49 @@ class rv_generic(object):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmdict = {'moments': {1: 'm', 2: 'v', 3: 'vs', 4: 'vk'}[n]}
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelse:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmdict = {}
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmu, mu2, g1, g2 = self._stats(*args, **mdict)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspval = _moment_from_stats(n, mu, mu2, g1, g2, self._munp, args)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmu, mu2, g1, g2 = self._stats(*shapes, **mdict)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspval = np.empty(loc.shape)  # val needs to be indexed by loc</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspval[...] = _moment_from_stats(n, mu, mu2, g1, g2, self._munp, shapes)</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# Convert to transformed  X = L + S*Y
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# E[X^n] = E[(L+S*Y)^n] = L^n sum(comb(n, k)*(S/L)^k E[Y^k], k=0...n)
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif loc == 0:</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn scale**n * val</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelse:</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspresult = 0</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspfac = float(scale) / float(loc)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspresult = zeros(i0.shape)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspplace(result, ~i0, self.badvalue)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif i1.any():</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspres1 = scale[loc == 0]**n * val[loc == 0]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspplace(result, i1, res1)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif i2.any():</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmom = [mu, mu2, g1, g2]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsparrs = [i for i in mom if i is not None]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspidx = [i for i in range(4) if mom[i] is not None]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif any(idx):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsparrs = argsreduce(loc != 0, *arrs)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspj = 0</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspfor i in idx:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmom[i] = arrs[j]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspj += 1</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmu, mu2, g1, g2 = mom</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspargs = argsreduce(loc != 0, *shapes, loc, scale, val)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp*shapes, loc, scale, val = args</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspres2 = zeros(loc.shape, dtype='d')</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspfac = scale / loc</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspfor k in range(n):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspvalk = _moment_from_stats(k, mu, mu2, g1, g2, self._munp, args)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspresult += comb(n, k, exact=True)*(fac**k) * valk</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspresult += fac**n * val</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn result * loc**n</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspvalk = _moment_from_stats(k, mu, mu2, g1, g2, self._munp,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspshapes)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspres2 += comb(n, k, exact=True)*fac**k * valk</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspres2 += fac**n * val</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspres2 *= loc**n</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspplace(result, i2, res2)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif result.ndim == 0:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn result.item()</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn result</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef median(self, *args, **kwds):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspMedian of the distribution.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Median of the distribution.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -1186,15 +1352,14 @@ class rv_generic(object):
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspSee Also
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp--------
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspstats.distributions.rv_discrete.ppf</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprv_discrete.ppf</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspInverse of the CDF
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn self.ppf(0.5, *args, **kwds)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef mean(self, *args, **kwds):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspMean of the distribution.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Mean of the distribution.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -1219,8 +1384,7 @@ class rv_generic(object):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn res
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef var(self, *args, **kwds):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspVariance of the distribution.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Variance of the distribution.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -1245,8 +1409,7 @@ class rv_generic(object):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn res
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef std(self, *args, **kwds):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspStandard deviation of the distribution.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Standard deviation of the distribution.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -1269,8 +1432,7 @@ class rv_generic(object):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn res
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef interval(self, alpha, *args, **kwds):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspConfidence interval with equal areas around the median.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Confidence interval with equal areas around the median.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -1301,18 +1463,69 @@ class rv_generic(object):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspb = self.ppf(q2, *args, **kwds)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn a, b
<br>&nbsp
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdef support(self, *args, **kwargs):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Support of the distribution.</span>
<br>&nbsp
<br><span style="color:red">- ##  continuous random variables: implement maybe later</span>
<br><span style="color:red">- ##</span>
<br><span style="color:red">- ##  hf  --- Hazard Function (PDF / SF)</span>
<br><span style="color:red">- ##  chf  --- Cumulative hazard function (-log(SF))</span>
<br><span style="color:red">- ##  psf --- Probability sparsity function (reciprocal of the pdf) in</span>
<br><span style="color:red">- ##                units of percent-point-function (as a function of q).</span>
<br><span style="color:red">- ##                Also, the derivative of the percent-point function.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsparg1, arg2, ... : array_like</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThe shape parameter(s) for the distribution (see docstring of the</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspinstance object for more information).</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsploc : array_like, optional</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsplocation parameter, Default is 0.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspscale : array_like, optional</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspscale parameter, Default is 1.</span>
<br>&nbsp
<br><span style="color:red">- class rv_continuous(rv_generic):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspReturns</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp-------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspa, b : array_like</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspend-points of the distribution's support.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspargs, loc, scale = self._parse_args(*args, **kwargs)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsparrs = np.broadcast_arrays(*args, loc, scale)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspargs, loc, scale = arrs[:-2], arrs[-2], arrs[-1]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond = self._argcheck(*args) & (scale > 0)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp_a, _b = self._get_support(*args)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif cond.all():</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn _a * scale + loc, _b * scale + loc</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelif cond.ndim == 0:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn self.badvalue, self.badvalue</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# promote bounds to at least float to fill in the badvalue</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp_a, _b = np.asarray(_a).astype('d'), np.asarray(_b).astype('d')</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspout_a, out_b = _a * scale + loc, _b * scale + loc</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspplace(out_a, 1-cond, self.badvalue)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspplace(out_b, 1-cond, self.badvalue)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn out_a, out_b</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+def _get_fixed_fit_value(kwds, names):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspGiven names such as `['f0', 'fa', 'fix_a']`, check that there is</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspat most one non-None value in `kwds` associaed with those names.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspReturn that value, or None if none of the names occur in `kwds`.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspAs a side effect, all occurrences of those names in `kwds` are</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspremoved.</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspA generic continuous random variable class meant for subclassing.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspvals = [(name, kwds.pop(name)) for name in names if name in kwds]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspif len(vals) > 1:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprepeated = [name for name, val in vals]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("fit method got multiple keyword arguments to "</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"specify the same fixed parameter: " +</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp', '.join(repeated))</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspreturn vals[0][1] if vals else None</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+#  continuous random variables: implement maybe later</span>
<br><span style="color:green">+#</span>
<br><span style="color:green">+#  hf  --- Hazard Function (PDF / SF)</span>
<br><span style="color:green">+#  chf  --- Cumulative hazard function (-log(SF))</span>
<br><span style="color:green">+#  psf --- Probability sparsity function (reciprocal of the pdf) in</span>
<br><span style="color:green">+#                units of percent-point-function (as a function of q).</span>
<br><span style="color:green">+#                Also, the derivative of the percent-point function.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+class rv_continuous(rv_generic):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp"""A generic continuous random variable class meant for subclassing.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp`rv_continuous` is a base class to construct specific distribution classes
<br>&nbsp &nbsp &nbsp &nbsp &nbspand instances for continuous random variables. It cannot be used
<br>@@ -1351,12 +1564,15 @@ class rv_continuous(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThis string is used as the last part of the docstring returned when a
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsubclass has no docstring of its own. Note: `extradoc` exists for
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspbackwards compatibility, do not use for new subclasses.
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspseed : None or int or ``numpy.random.RandomState`` instance, optional</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThis parameter defines the RandomState object to use for drawing</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprandom variates.</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf None (or np.random), the global np.random state is used.</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf integer, it is used to seed the local RandomState instance.</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspDefault is None.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspseed : {None, int, `numpy.random.Generator`,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp`numpy.random.RandomState`}, optional</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf `seed` is None (or `np.random`), the `numpy.random.RandomState`</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsingleton is used.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf `seed` is an int, a new ``RandomState`` instance is used,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspseeded with `seed`.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf `seed` is already a ``Generator`` or ``RandomState`` instance then</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspthat instance is used.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspMethods
<br>&nbsp &nbsp &nbsp &nbsp &nbsp-------
<br>@@ -1382,13 +1598,14 @@ class rv_continuous(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbspfit
<br>&nbsp &nbsp &nbsp &nbsp &nbspfit_loc_scale
<br>&nbsp &nbsp &nbsp &nbsp &nbspnnlf
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspsupport</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspNotes
<br>&nbsp &nbsp &nbsp &nbsp &nbsp-----
<br>&nbsp &nbsp &nbsp &nbsp &nbspPublic methods of an instance of a distribution class (e.g., ``pdf``,
<br>&nbsp &nbsp &nbsp &nbsp &nbsp``cdf``) check their arguments and pass valid arguments to private,
<br>&nbsp &nbsp &nbsp &nbsp &nbspcomputational methods (``_pdf``, ``_cdf``). For ``pdf(x)``, ``x`` is valid
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspif it is within the support of a distribution, ``self.a <= x <= self.b``.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspif it is within the support of the distribution.</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspWhether a shape parameter is valid is decided by an ``_argcheck`` method
<br>&nbsp &nbsp &nbsp &nbsp &nbsp(which defaults to checking that its arguments are strictly positive.)
<br>&nbsp
<br>@@ -1401,12 +1618,29 @@ class rv_continuous(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbspIf positive argument checking is not correct for your RV
<br>&nbsp &nbsp &nbsp &nbsp &nbspthen you will also need to re-define the ``_argcheck`` method.
<br>&nbsp
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspFor most of the scipy.stats distributions, the support interval doesn't</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdepend on the shape parameters. ``x`` being in the support interval is</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspequivalent to ``self.a <= x <= self.b``.  If either of the endpoints of</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspthe support do depend on the shape parameters, then</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspi) the distribution must implement the ``_get_support`` method; and</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspii) those dependent endpoints must be omitted from the distribution's</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspcall to the ``rv_continuous`` initializer.</span>
<br><span style="color:green">+</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspCorrect, but potentially slow defaults exist for the remaining
<br>&nbsp &nbsp &nbsp &nbsp &nbspmethods but for speed and/or accuracy you can over-ride::
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp_logpdf, _cdf, _logcdf, _ppf, _rvs, _isf, _sf, _logsf
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspRarely would you override ``_isf``, ``_sf`` or ``_logsf``, but you could.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspThe default method ``_rvs`` relies on the inverse of the cdf, ``_ppf``,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspapplied to a uniform random variate. In order to generate random variates</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspefficiently, either the default ``_ppf`` needs to be overwritten (e.g.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspif the inverse cdf can expressed in an explicit form) or a sampling</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspmethod needs to be implemented in a custom ``_rvs`` method.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspIf possible, you should override ``_isf``, ``_sf`` or ``_logsf``.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspThe main reason would be to improve numerical accuracy: for example,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspthe survival function ``_sf`` is computed as ``1 - _cdf`` which can</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspresult in loss of precision if ``_cdf(x)`` is close to one.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp**Methods that can be overwritten by subclasses**
<br>&nbsp &nbsp &nbsp &nbsp &nbsp::
<br>@@ -1421,6 +1655,7 @@ class rv_continuous(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp_munp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp_entropy
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp_argcheck
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp_get_support</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspThere are additional (internal and private) generic methods that can
<br>&nbsp &nbsp &nbsp &nbsp &nbspbe useful for cross-checking and for debugging, but might work in all
<br>@@ -1442,7 +1677,7 @@ class rv_continuous(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsplocation, and scale parameters returning a "frozen" continuous RV object:
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsprv = generic(<shape(s)>, loc=0, scale=1)
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspfrozen RV object with the same methods but holding the given shape,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp`rv_frozen` object with the same methods but holding the given shape,</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsplocation, and scale fixed
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp**Statistics**
<br>@@ -1488,7 +1723,7 @@ class rv_continuous(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspbadvalue=None, name=None, longname=None,
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspshapes=None, extradoc=None, seed=None):
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsuper(rv_continuous, self).__init__(seed)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsuper().__init__(seed)</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# save the ctor parameters, cf generic freeze
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._ctor_param = dict(
<br>@@ -1511,25 +1746,12 @@ class rv_continuous(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.xtol = xtol
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.moment_type = momtype
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.shapes = shapes
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.extradoc = extradoc</span>
<br><span style="color:green">+</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._construct_argparser(meths_to_inspect=[self._pdf, self._cdf],
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsplocscale_in='loc=0, scale=1',
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsplocscale_out='loc, scale')
<br><span style="color:red">- </span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# nin correction</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._ppfvec = vectorize(self._ppf_single, otypes='d')</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._ppfvec.nin = self.numargs + 1</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.vecentropy = vectorize(self._entropy, otypes='d')</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._cdfvec = vectorize(self._cdf_single, otypes='d')</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._cdfvec.nin = self.numargs + 1</span>
<br><span style="color:red">- </span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.extradoc = extradoc</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif momtype == 0:</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.generic_moment = vectorize(self._mom0_sc, otypes='d')</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelse:</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.generic_moment = vectorize(self._mom1_sc, otypes='d')</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# Because of the *args argument of _mom0_sc, vectorize cannot count the</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# number of arguments correctly.</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.generic_moment.nin = self.numargs + 1</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._attach_methods()</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif longname is None:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif name[0] in ['aeiouAEIOU']:
<br>@@ -1549,11 +1771,43 @@ class rv_continuous(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdct = dict(distcont)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._construct_doc(docdict, dct.get(self.name))
<br>&nbsp
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdef __getstate__(self):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdct = self.__dict__.copy()</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# these methods will be remade in __setstate__</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# _random_state attribute is taken care of by rv_generic</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspattrs = ["_parse_args", "_parse_args_stats", "_parse_args_rvs",</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"_cdfvec", "_ppfvec", "vecentropy", "generic_moment"]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[dct.pop(attr, None) for attr in attrs]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn dct</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdef _attach_methods(self):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspAttaches dynamically created methods to the rv_continuous instance.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# _attach_methods is responsible for calling _attach_argparser_methods</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._attach_argparser_methods()</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# nin correction</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._ppfvec = vectorize(self._ppf_single, otypes='d')</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._ppfvec.nin = self.numargs + 1</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.vecentropy = vectorize(self._entropy, otypes='d')</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._cdfvec = vectorize(self._cdf_single, otypes='d')</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._cdfvec.nin = self.numargs + 1</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif self.moment_type == 0:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.generic_moment = vectorize(self._mom0_sc, otypes='d')</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelse:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.generic_moment = vectorize(self._mom1_sc, otypes='d')</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# Because of the *args argument of _mom0_sc, vectorize cannot count the</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# number of arguments correctly.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.generic_moment.nin = self.numargs + 1</span>
<br><span style="color:green">+</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef _updated_ctor_param(self):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp""" Return the current version of _ctor_param, possibly updated by user.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Return the current version of _ctor_param, possibly updated by user.</span>
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspUsed by freezing and pickling.</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspKeep this in sync with the signature of __init__.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspUsed by freezing.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspKeep this in sync with the signature of __init__.</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdct = self._ctor_param.copy()
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdct['a'] = self.a
<br>@@ -1569,25 +1823,21 @@ class rv_continuous(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn self.cdf(*(x, )+args)-q
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef _ppf_single(self, q, *args):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspleft = right = None</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif self.a > -np.inf:</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspleft = self.a</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif self.b < np.inf:</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspright = self.b</span>
<br><span style="color:red">- </span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspfactor = 10.
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif not left:  # i.e. self.a = -inf</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspleft = -1.*factor</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspleft, right = self._get_support(*args)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif np.isinf(left):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspleft = min(-factor, right)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspwhile self._ppf_to_solve(left, q, *args) > 0.:
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspright = left</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspleft *= factor</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# left is now such that cdf(left) < q</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif not right:  # i.e. self.b = inf</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspright = factor</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspleft, right = left * factor, left</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# left is now such that cdf(left) <= q</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# if right has changed, then cdf(right) > q</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif np.isinf(right):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspright = max(factor, left)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspwhile self._ppf_to_solve(right, q, *args) < 0.:
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspleft = right</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspright *= factor</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# right is now such that cdf(right) > q</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspleft, right = right, right * factor</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# right is now such that cdf(right) >= q</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn optimize.brentq(self._ppf_to_solve,
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspleft, right, args=(q,)+args, xtol=self.xtol)
<br>@@ -1597,7 +1847,8 @@ class rv_continuous(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn x**m * self.pdf(x, *args)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef _mom0_sc(self, m, *args):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn integrate.quad(self._mom_integ0, self.a, self.b,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp_a, _b = self._get_support(*args)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn integrate.quad(self._mom_integ0, _a, _b,</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspargs=(m,)+args)[0]
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp# moment calculated using ppf
<br>@@ -1610,22 +1861,22 @@ class rv_continuous(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef _pdf(self, x, *args):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn derivative(self._cdf, x, dx=1e-5, args=args, order=5)
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp## Could also define any of these</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp# Could also define any of these</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef _logpdf(self, x, *args):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn log(self._pdf(x, *args))
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef _cdf_single(self, x, *args):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn integrate.quad(self._pdf, self.a, x, args=args)[0]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp_a, _b = self._get_support(*args)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn integrate.quad(self._pdf, _a, x, args=args)[0]</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef _cdf(self, x, *args):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn self._cdfvec(x, *args)
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp## generic _argcheck, _logcdf, _sf, _logsf, _ppf, _isf, _rvs are defined</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp## in rv_generic</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp# generic _argcheck, _logcdf, _sf, _logsf, _ppf, _isf, _rvs are defined</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp# in rv_generic</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef pdf(self, x, *args, **kwds):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspProbability density function at x of the given RV.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Probability density function at x of the given RV.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -1651,7 +1902,7 @@ class rv_continuous(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdtyp = np.find_common_type([x.dtype, np.float64], [])
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspx = np.asarray((x - loc)/scale, dtype=dtyp)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond0 = self._argcheck(*args) & (scale > 0)
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond1 = self._support_mask(x) & (scale > 0)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond1 = self._support_mask(x, *args) & (scale > 0)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond = cond0 & cond1
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoutput = zeros(shape(cond), dtyp)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspputmask(output, (1-cond0)+np.isnan(x), self.badvalue)
<br>@@ -1664,8 +1915,7 @@ class rv_continuous(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn output
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef logpdf(self, x, *args, **kwds):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspLog of the probability density function at x of the given RV.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Log of the probability density function at x of the given RV.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThis uses a more numerically accurate calculation if available.
<br>&nbsp
<br>@@ -1693,7 +1943,7 @@ class rv_continuous(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdtyp = np.find_common_type([x.dtype, np.float64], [])
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspx = np.asarray((x - loc)/scale, dtype=dtyp)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond0 = self._argcheck(*args) & (scale > 0)
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond1 = self._support_mask(x) & (scale > 0)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond1 = self._support_mask(x, *args) & (scale > 0)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond = cond0 & cond1
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoutput = empty(shape(cond), dtyp)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoutput.fill(NINF)
<br>@@ -1731,11 +1981,12 @@ class rv_continuous(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspargs, loc, scale = self._parse_args(*args, **kwds)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspx, loc, scale = map(asarray, (x, loc, scale))
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspargs = tuple(map(asarray, args))
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp_a, _b = self._get_support(*args)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdtyp = np.find_common_type([x.dtype, np.float64], [])
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspx = np.asarray((x - loc)/scale, dtype=dtyp)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond0 = self._argcheck(*args) & (scale > 0)
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond1 = self._open_support_mask(x) & (scale > 0)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond2 = (x >= self.b) & cond0</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond1 = self._open_support_mask(x, *args) & (scale > 0)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond2 = (x >= np.asarray(_b)) & cond0</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond = cond0 & cond1
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoutput = zeros(shape(cond), dtyp)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspplace(output, (1-cond0)+np.isnan(x), self.badvalue)
<br>@@ -1748,8 +1999,7 @@ class rv_continuous(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn output
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef logcdf(self, x, *args, **kwds):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspLog of the cumulative distribution function at x of the given RV.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Log of the cumulative distribution function at x of the given RV.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -1772,11 +2022,12 @@ class rv_continuous(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspargs, loc, scale = self._parse_args(*args, **kwds)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspx, loc, scale = map(asarray, (x, loc, scale))
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspargs = tuple(map(asarray, args))
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp_a, _b = self._get_support(*args)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdtyp = np.find_common_type([x.dtype, np.float64], [])
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspx = np.asarray((x - loc)/scale, dtype=dtyp)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond0 = self._argcheck(*args) & (scale > 0)
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond1 = self._open_support_mask(x) & (scale > 0)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond2 = (x >= self.b) & cond0</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond1 = self._open_support_mask(x, *args) & (scale > 0)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond2 = (x >= _b) & cond0</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond = cond0 & cond1
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoutput = empty(shape(cond), dtyp)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoutput.fill(NINF)
<br>@@ -1790,8 +2041,7 @@ class rv_continuous(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn output
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef sf(self, x, *args, **kwds):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspSurvival function (1 - `cdf`) at x of the given RV.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Survival function (1 - `cdf`) at x of the given RV.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -1814,11 +2064,12 @@ class rv_continuous(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspargs, loc, scale = self._parse_args(*args, **kwds)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspx, loc, scale = map(asarray, (x, loc, scale))
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspargs = tuple(map(asarray, args))
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp_a, _b = self._get_support(*args)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdtyp = np.find_common_type([x.dtype, np.float64], [])
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspx = np.asarray((x - loc)/scale, dtype=dtyp)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond0 = self._argcheck(*args) & (scale > 0)
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond1 = self._open_support_mask(x) & (scale > 0)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond2 = cond0 & (x <= self.a)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond1 = self._open_support_mask(x, *args) & (scale > 0)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond2 = cond0 & (x <= _a)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond = cond0 & cond1
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoutput = zeros(shape(cond), dtyp)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspplace(output, (1-cond0)+np.isnan(x), self.badvalue)
<br>@@ -1831,8 +2082,7 @@ class rv_continuous(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn output
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef logsf(self, x, *args, **kwds):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspLog of the survival function of the given RV.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Log of the survival function of the given RV.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspReturns the log of the "survival function," defined as (1 - `cdf`),
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspevaluated at `x`.
<br>@@ -1858,11 +2108,12 @@ class rv_continuous(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspargs, loc, scale = self._parse_args(*args, **kwds)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspx, loc, scale = map(asarray, (x, loc, scale))
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspargs = tuple(map(asarray, args))
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp_a, _b = self._get_support(*args)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdtyp = np.find_common_type([x.dtype, np.float64], [])
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspx = np.asarray((x - loc)/scale, dtype=dtyp)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond0 = self._argcheck(*args) & (scale > 0)
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond1 = self._open_support_mask(x) & (scale > 0)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond2 = cond0 & (x <= self.a)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond1 = self._open_support_mask(x, *args) & (scale > 0)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond2 = cond0 & (x <= _a)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond = cond0 & cond1
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoutput = empty(shape(cond), dtyp)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoutput.fill(NINF)
<br>@@ -1876,8 +2127,7 @@ class rv_continuous(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn output
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef ppf(self, q, *args, **kwds):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspPercent point function (inverse of `cdf`) at q of the given RV.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Percent point function (inverse of `cdf`) at q of the given RV.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -1900,15 +2150,16 @@ class rv_continuous(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspargs, loc, scale = self._parse_args(*args, **kwds)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspq, loc, scale = map(asarray, (q, loc, scale))
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspargs = tuple(map(asarray, args))
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp_a, _b = self._get_support(*args)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond0 = self._argcheck(*args) & (scale > 0) & (loc == loc)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond1 = (0 < q) & (q < 1)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond2 = cond0 & (q == 0)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond3 = cond0 & (q == 1)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond = cond0 & cond1
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoutput = valarray(shape(cond), value=self.badvalue)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoutput = np.full(shape(cond), fill_value=self.badvalue)</span>
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsplower_bound = self.a * scale + loc</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspupper_bound = self.b * scale + loc</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsplower_bound = _a * scale + loc</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspupper_bound = _b * scale + loc</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspplace(output, cond2, argsreduce(cond2, lower_bound)[0])
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspplace(output, cond3, argsreduce(cond3, upper_bound)[0])
<br>&nbsp
<br>@@ -1921,8 +2172,7 @@ class rv_continuous(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn output
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef isf(self, q, *args, **kwds):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspInverse survival function (inverse of `sf`) at q of the given RV.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Inverse survival function (inverse of `sf`) at q of the given RV.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -1945,15 +2195,16 @@ class rv_continuous(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspargs, loc, scale = self._parse_args(*args, **kwds)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspq, loc, scale = map(asarray, (q, loc, scale))
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspargs = tuple(map(asarray, args))
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp_a, _b = self._get_support(*args)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond0 = self._argcheck(*args) & (scale > 0) & (loc == loc)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond1 = (0 < q) & (q < 1)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond2 = cond0 & (q == 1)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond3 = cond0 & (q == 0)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond = cond0 & cond1
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoutput = valarray(shape(cond), value=self.badvalue)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoutput = np.full(shape(cond), fill_value=self.badvalue)</span>
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsplower_bound = self.a * scale + loc</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspupper_bound = self.b * scale + loc</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsplower_bound = _a * scale + loc</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspupper_bound = _b * scale + loc</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspplace(output, cond2, argsreduce(cond2, lower_bound)[0])
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspplace(output, cond3, argsreduce(cond3, upper_bound)[0])
<br>&nbsp
<br>@@ -1973,29 +2224,29 @@ class rv_continuous(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsploc = theta[-2]
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspscale = theta[-1]
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspargs = tuple(theta[:-2])
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspexcept IndexError:</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("Not enough input arguments.")</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspexcept IndexError as e:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("Not enough input arguments.") from e</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn loc, scale, args
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef nnlf(self, theta, x):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp'''Return negative loglikelihood function.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Negative loglikelihood function.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspNotes
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp-----
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThis is ``-sum(log pdf(x, theta), axis=0)`` where `theta` are the
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspparameters (including loc and scale).
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp'''</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsploc, scale, args = self._unpack_loc_scale(theta)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif not self._argcheck(*args) or scale <= 0:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn inf
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspx = asarray((x-loc) / scale)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspn_log_scale = len(x) * log(scale)
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif np.any(~self._support_mask(x)):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif np.any(~self._support_mask(x, *args)):</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn inf
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn self._nnlf(x, *args) + n_log_scale
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef _nnlf_and_penalty(self, x, args):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond0 = ~self._support_mask(x)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond0 = ~self._support_mask(x, *args)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspn_bad = np.count_nonzero(cond0, axis=0)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif n_bad > 0:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspx = argsreduce(~cond0, x)[0]
<br>@@ -2008,10 +2259,11 @@ class rv_continuous(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn -np.sum(logpdf, axis=0)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef _penalized_nnlf(self, theta, x):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp''' Return penalized negative loglikelihood function,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Penalized negative loglikelihood function.</span>
<br><span style="color:green">+</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspi.e., - sum (log pdf(x, theta), axis=0) + penalty
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspwhere theta are the parameters (including loc and scale)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp'''</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspwhere theta are the parameters (including loc and scale)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsploc, scale, args = self._unpack_loc_scale(theta)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif not self._argcheck(*args) or scale <= 0:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn inf
<br>@@ -2019,29 +2271,31 @@ class rv_continuous(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspn_log_scale = len(x) * log(scale)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn self._nnlf_and_penalty(x, args) + n_log_scale
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp# return starting point for fit (shape arguments + loc + scale)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef _fitstart(self, data, args=None):
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Starting point for fit (shape arguments + loc + scale)."""</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif args is None:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspargs = (1.0,)*self.numargs
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsploc, scale = self._fit_loc_scale_support(data, *args)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn args + (loc, scale)
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp# Return the (possibly reduced) function to optimize in order to find MLE</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp#  estimates for the .fit method</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspdef _reduce_func(self, args, kwds):</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# First of all, convert fshapes params to fnum: eg for stats.beta,</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# shapes='a, b'. To fix `a`, can specify either `f1` or `fa`.</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# Convert the latter into the former.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdef _reduce_func(self, args, kwds, data=None):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspReturn the (possibly reduced) function to optimize in order to find MLE</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspestimates for the .fit method.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# Convert fixed shape parameters to the standard numeric form: e.g. for</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# stats.beta, shapes='a, b'. To fix `a`, the caller can give a value</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# for `f0`, `fa` or 'fix_a'.  The following converts the latter two</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# into the first (numeric) form.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspshapes = []</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif self.shapes:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspshapes = self.shapes.replace(',', ' ').split()
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspfor j, s in enumerate(shapes):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspval = kwds.pop('f' + s, None) or kwds.pop('fix_' + s, None)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspkey = 'f' + str(j)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspnames = [key, 'f' + s, 'fix_' + s]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspval = _get_fixed_fit_value(kwds, names)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif val is not None:
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspkey = 'f%d' % j</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif key in kwds:</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("Duplicate entry for %s." % key)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelse:</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspkwds[key] = val</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspkwds[key] = val</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspargs = list(args)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspNargs = len(args)
<br>@@ -2055,8 +2309,23 @@ class rv_continuous(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelse:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspx0.append(args[n])
<br>&nbsp
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmethods = {"mle", "mm"}</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmethod = kwds.pop('method', "mle").lower()</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif method == "mm":</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspn_params = len(shapes) + 2 - len(fixedn)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspexponents = (np.arange(1, n_params+1))[:, np.newaxis]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdata_moments = np.sum(data[None, :]**exponents/len(data), axis=1)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdef objective(theta, x):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn self._moment_error(theta, x, data_moments)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelif method == "mle":</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspobjective = self._penalized_nnlf</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelse:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("Method '{0}' not available; must be one of {1}"</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp.format(method, methods))</span>
<br><span style="color:green">+</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif len(fixedn) == 0:
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspfunc = self._penalized_nnlf</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspfunc = objective</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprestore = None
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelse:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif len(fixedn) == Nargs:
<br>@@ -2076,16 +2345,33 @@ class rv_continuous(rv_generic):
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdef func(theta, x):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspnewtheta = restore(args[:], theta)
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn self._penalized_nnlf(newtheta, x)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn objective(newtheta, x)</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn x0, func, restore, args
<br>&nbsp
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdef _moment_error(self, theta, x, data_moments):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsploc, scale, args = self._unpack_loc_scale(theta)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif not self._argcheck(*args) or scale <= 0:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn inf</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdist_moments = np.array([self.moment(i+1, *args, loc=loc, scale=scale)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspfor i in range(len(data_moments))])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif np.any(np.isnan(dist_moments)):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("Method of moments encountered a non-finite "</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"distribution moment and cannot continue. "</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"Consider trying method='MLE'.")</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn (((data_moments - dist_moments) /</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspnp.maximum(np.abs(data_moments), 1e-8))**2).sum()</span>
<br><span style="color:green">+</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef fit(self, data, *args, **kwds):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspReturn MLEs for shape (if applicable), location, and scale</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspparameters from data.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspReturn estimates of shape (if applicable), location, and scale</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspparameters from data. The default estimation method is Maximum</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspLikelihood Estimation (MLE), but Method of Moments (MM)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspis also available.</span>
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspMLE stands for Maximum Likelihood Estimate.  Starting estimates for</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspStarting estimates for</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspthe fit are given by input arguments; for any arguments not provided
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspwith starting estimates, ``self._fitstart(data)`` is called to generate
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsuch.
<br>@@ -2098,19 +2384,21 @@ class rv_continuous(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdata : array_like
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspData to use in calculating the MLEs.</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspargs : floats, optional</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspData to use in estimating the distribution parameters.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsparg1, arg2, arg3,... : floats, optional</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspStarting value(s) for any shape-characterizing arguments (those not
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspprovided will be determined by a call to ``_fitstart(data)``).
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspNo default value.
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspkwds : floats, optional
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspStarting values for the location and scale parameters; no default.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp- `loc`: initial guess of the distribution's location parameter.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp- `scale`: initial guess of the distribution's scale parameter.</span>
<br><span style="color:green">+</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspSpecial keyword arguments are recognized as holding certain
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspparameters fixed:
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp- f0...fn : hold respective shape parameters fixed.
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspAlternatively, shape parameters to fix can be specified by name.
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspFor example, if ``self.shapes == "a, b"``, ``fa``and ``fix_a``</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspFor example, if ``self.shapes == "a, b"``, ``fa`` and ``fix_a``</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspare equivalent to ``f0``, and ``fb`` and ``fix_b`` are
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspequivalent to ``f1``.
<br>&nbsp
<br>@@ -2118,26 +2406,54 @@ class rv_continuous(rv_generic):
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp- fscale : hold scale parameter fixed to specified value.
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp- optimizer : The optimizer to use.  The optimizer must take ``func``,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp- optimizer : The optimizer to use.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThe optimizer must take ``func``,</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspand starting position as the first two arguments,
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspplus ``args`` (for extra arguments to pass to the
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspfunction to be optimized) and ``disp=0`` to suppress
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoutput as keyword arguments.
<br>&nbsp
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp- method : The method to use. The default is "MLE" (Maximum</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspLikelihood Estimate); "MM" (Method of Moments)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspis also available.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspReturns
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp-------
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmle_tuple : tuple of floats</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspMLEs for any shape parameters (if applicable), followed by those</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspfor location and scale. For most random variables, shape statistics</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspparameter_tuple : tuple of floats</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspEstimates for any shape parameters (if applicable),</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspfollowed by those for location and scale.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspFor most random variables, shape statistics</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspwill be returned, but there are exceptions (e.g. ``norm``).
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspNotes
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp-----
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThis fit is computed by maximizing a log-likelihood function, with</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsppenalty applied for samples outside of range of the distribution. The</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturned answer is not guaranteed to be the globally optimal MLE, it</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspWith ``method="MLE"`` (default), the fit is computed by minimizing</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspthe negative log-likelihood function. A large, finite penalty</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp(rather than infinite negative log-likelihood) is applied for</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspobservations beyond the support of the distribution.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspWith ``method="MM"``, the fit is computed by minimizing the L2 norm</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspof the relative errors between the first *k* raw (about zero) data</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmoments and the corresponding distribution moments, where *k* is the</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspnumber of non-fixed parameters.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspMore precisely, the objective function is::</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp(((data_moments - dist_moments)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp/ np.maximum(np.abs(data_moments), 1e-8))**2).sum()</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspwhere the constant ``1e-8`` avoids division by zero in case of</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspvanishing data moments. Typically, this error norm can be reduced to</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspzero.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspNote that the standard method of moments can produce parameters for</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspwhich some data are outside the support of the fitted distribution;</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspthis implementation does nothing to prevent this.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspFor either method,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspthe returned answer is not guaranteed to be globally optimal; it</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmay only be locally optimal, or the optimization may fail altogether.
<br><span style="color:red">- </span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf the data contain any of ``np.nan``, ``np.inf``, or ``-np.inf``,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspthe `fit` method will raise a ``RuntimeError``.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspExamples
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp--------
<br>@@ -2149,7 +2465,8 @@ class rv_continuous(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp>>> a, b = 1., 2.
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp>>> x = beta.rvs(a, b, size=1000)
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspNow we can fit all four parameters (``a``, ``b``, ``loc`` and ``scale``):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspNow we can fit all four parameters (``a``, ``b``, ``loc``</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspand ``scale``):</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp>>> a1, b1, loc1, scale1 = beta.fit(x)
<br>&nbsp
<br>@@ -2177,10 +2494,17 @@ class rv_continuous(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp>>> loc1, scale1
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp(0.92087172783841631, 2.0015750750324668)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdata = np.asarray(data)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmethod = kwds.get('method', "mle").lower()</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# memory for method of moments</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspNarg = len(args)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif Narg > self.numargs:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise TypeError("Too many input arguments.")
<br>&nbsp
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif not np.isfinite(data).all():</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise RuntimeError("The data contains non-finite values.")</span>
<br><span style="color:green">+</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspstart = [None]*2
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif (Narg < self.numargs) or not ('loc' in kwds and
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp'scale' in kwds):
<br>@@ -2190,33 +2514,40 @@ class rv_continuous(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsploc = kwds.pop('loc', start[-2])
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspscale = kwds.pop('scale', start[-1])
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspargs += (loc, scale)
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspx0, func, restore, args = self._reduce_func(args, kwds)</span>
<br><span style="color:red">- </span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspx0, func, restore, args = self._reduce_func(args, kwds, data=data)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoptimizer = kwds.pop('optimizer', optimize.fmin)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# convert string to function in scipy.optimize
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif not callable(optimizer) and isinstance(optimizer, string_types):</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif not optimizer.startswith('fmin_'):</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoptimizer = "fmin_"+optimizer</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif optimizer == 'fmin_':</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoptimizer = 'fmin'</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsptry:</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoptimizer = getattr(optimize, optimizer)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspexcept AttributeError:</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("%s is not a valid optimizer" % optimizer)</span>
<br><span style="color:red">- </span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoptimizer = _fit_determine_optimizer(optimizer)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# by now kwds must be empty, since everybody took what they needed
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif kwds:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise TypeError("Unknown arguments: %s." % kwds)
<br>&nbsp
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# In some cases, method of moments can be done with fsolve/root</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# instead of an optimizer, but sometimes no solution exists,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# especially when the user fixes parameters. Minimizing the sum</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# of squares of the error generalizes to these cases.</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspvals = optimizer(func, x0, args=(ravel(data),), disp=0)
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspobj = func(vals, data)</span>
<br><span style="color:green">+</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif restore is not None:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspvals = restore(args, vals)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspvals = tuple(vals)
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsploc, scale, shapes = self._unpack_loc_scale(vals)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif not (np.all(self._argcheck(*shapes)) and scale > 0):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise Exception("Optimization converged to parameters that are "</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"outside the range allowed by the distribution.")</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif method == 'mm':</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif not np.isfinite(obj):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise Exception("Optimization failed: either a data moment "</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"or fitted distribution moment is "</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"non-finite.")</span>
<br><span style="color:green">+</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn vals
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef _fit_loc_scale_support(self, data, *args):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspEstimate loc and scale parameters from data accounting for support.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Estimate loc and scale parameters from data accounting for support.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -2241,14 +2572,16 @@ class rv_continuous(rv_generic):
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# Compute the support according to the shape parameters.
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._argcheck(*args)
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspa, b = self.a, self.b</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp_a, _b = self._get_support(*args)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspa, b = _a, _b</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsupport_width = b - a
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# If the support is empty then return the moment-based estimates.
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif support_width <= 0:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn loc_hat, scale_hat
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# Compute the proposed support according to the loc and scale estimates.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# Compute the proposed support according to the loc and scale</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# estimates.</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspa_hat = loc_hat + a * scale_hat
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspb_hat = loc_hat + b * scale_hat
<br>&nbsp
<br>@@ -2316,36 +2649,44 @@ class rv_continuous(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn entr(val)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# upper limit is often inf, so suppress warnings when integrating
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspolderr = np.seterr(over='ignore')</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsph = integrate.quad(integ, self.a, self.b)[0]</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspnp.seterr(**olderr)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp_a, _b = self._get_support(*args)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspwith np.errstate(over='ignore'):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsph = integrate.quad(integ, _a, _b)[0]</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif not np.isnan(h):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn h
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelse:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# try with different limits if integration problems
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsplow, upp = self.ppf([1e-10, 1. - 1e-10], *args)
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif np.isinf(self.b):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif np.isinf(_b):</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspupper = upp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelse:
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspupper = self.b</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif np.isinf(self.a):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspupper = _b</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif np.isinf(_a):</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsplower = low
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelse:
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsplower = self.a</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsplower = _a</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn integrate.quad(integ, lower, upper)[0]
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef expect(self, func=None, args=(), loc=0, scale=1, lb=None, ub=None,
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspconditional=False, **kwds):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Calculate expected value of a function with respect to the
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdistribution.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdistribution by numerical integration.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThe expected value of a function ``f(x)`` with respect to a
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdistribution ``dist`` is defined as::
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspubound</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspE[x] = Integral(f(x) * dist.pdf(x))</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsplbound</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspub</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspE[f(x)] = Integral(f(x) * dist.pdf(x)),</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsplb</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspwhere ``ub`` and ``lb`` are arguments and ``x`` has the ``dist.pdf(x)``</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdistribution. If the bounds ``lb`` and ``ub`` correspond to the</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsupport of the distribution, e.g. ``[-inf, inf]`` in the default</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcase, then the integral is the unrestricted expectation of ``f(x)``.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspAlso, the function ``f(x)`` may be defined such that ``f(x)`` is ``0``</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoutside a finite interval in which case the expectation is</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcalculated within the finite range ``[lb, ub]``.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -2377,12 +2718,38 @@ class rv_continuous(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspNotes
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp-----
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThe integration behavior of this function is inherited from
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp`integrate.quad`.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp`scipy.integrate.quad`. Neither this function nor</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp`scipy.integrate.quad` can verify whether the integral exists or is</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspfinite. For example ``cauchy(0).mean()`` returns ``np.nan`` and</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp``cauchy(0).expect()`` returns ``0.0``.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThe function is not vectorized.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspExamples</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp--------</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspTo understand the effect of the bounds of integration consider</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp>>> from scipy.stats import expon</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp>>> expon(1).expect(lambda x: 1, lb=0.0, ub=2.0)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp0.6321205588285578</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThis is close to</span>
<br>&nbsp
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp>>> expon(1).cdf(2.0) - expon(1).cdf(0.0)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp0.6321205588285577</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf ``conditional=True``</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp>>> expon(1).expect(lambda x: 1, lb=0.0, ub=2.0, conditional=True)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp1.0000000000000002</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThe slight deviation from 1 is due to numerical integration.</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsplockwds = {'loc': loc,
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp'scale': scale}
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._argcheck(*args)
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp_a, _b = self._get_support(*args)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif func is None:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdef fun(x, *args):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn x * self.pdf(x, *args, **lockwds)
<br>@@ -2390,9 +2757,9 @@ class rv_continuous(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdef fun(x, *args):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn func(x) * self.pdf(x, *args, **lockwds)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif lb is None:
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsplb = loc + self.a * scale</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsplb = loc + _a * scale</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif ub is None:
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspub = loc + self.b * scale</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspub = loc + _b * scale</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif conditional:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspinvfac = (self.sf(lb, *args, **lockwds)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp- self.sf(ub, *args, **lockwds))
<br>@@ -2400,9 +2767,8 @@ class rv_continuous(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspinvfac = 1.0
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspkwds['args'] = args
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# Silence floating point warnings from integration.
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspolderr = np.seterr(all='ignore')</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspvals = integrate.quad(fun, lb, ub, **kwds)[0] / invfac</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspnp.seterr(**olderr)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspwith np.errstate(all='ignore'):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspvals = integrate.quad(fun, lb, ub, **kwds)[0] / invfac</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn vals
<br>&nbsp
<br>&nbsp
<br>@@ -2411,16 +2777,19 @@ def _drv2_moment(self, n, *args):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""Non-central moment of discrete distribution."""
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef fun(x):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn np.power(x, n) * self._pmf(x, *args)
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspreturn _expect(fun, self.a, self.b, self.ppf(0.5, *args), self.inc)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp_a, _b = self._get_support(*args)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspreturn _expect(fun, _a, _b, self.ppf(0.5, *args), self.inc)</span>
<br>&nbsp
<br>&nbsp
<br>&nbspdef _drv2_ppfsingle(self, q, *args):  # Use basic bisection algorithm
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspb = self.b</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspa = self.a</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp_a, _b = self._get_support(*args)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspb = _b</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspa = _a</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspif isinf(b):            # Be sure ending point is > q
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspb = int(max(100*q, 10))
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspwhile 1:
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif b >= self.b:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif b >= _b:</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspqb = 1.0
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspbreak
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspqb = self._cdf(b, *args)
<br>@@ -2433,7 +2802,7 @@ def _drv2_ppfsingle(self, q, *args):  # Use basic bisection algorithm
<br>&nbsp &nbsp &nbsp &nbsp &nbspif isinf(a):    # be sure starting point < q
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspa = int(min(-100*q, -10))
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspwhile 1:
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif a <= self.a:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif a <= _a:</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspqb = 0.0
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspbreak
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspqa = self._cdf(a, *args)
<br>@@ -2450,10 +2819,6 @@ def _drv2_ppfsingle(self, q, *args):  # Use basic bisection algorithm
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif (qb == q):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn b
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif b <= a+1:
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# testcase: return wrong number at lower index</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# python -c "from scipy.stats import zipf;print zipf.ppf(0.01, 2)" wrong</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# python -c "from scipy.stats import zipf;print zipf.ppf([0.01, 0.61, 0.77, 0.83], 2)"</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# python -c "from scipy.stats import logser;print logser.ppf([0.1, 0.66, 0.86, 0.93], 0.6)"</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif qa > q:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn a
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelse:
<br>@@ -2476,56 +2841,12 @@ def _drv2_ppfsingle(self, q, *args):  # Use basic bisection algorithm
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn c
<br>&nbsp
<br>&nbsp
<br><span style="color:red">- def entropy(pk, qk=None, base=None):</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp"""Calculate the entropy of a distribution for given probability values.</span>
<br><span style="color:red">- </span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspIf only probabilities `pk` are given, the entropy is calculated as</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp``S = -sum(pk * log(pk), axis=0)``.</span>
<br><span style="color:red">- </span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspIf `qk` is not None, then compute the Kullback-Leibler divergence</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp``S = sum(pk * log(pk / qk), axis=0)``.</span>
<br><span style="color:red">- </span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspThis routine will normalize `pk` and `qk` if they don't sum to 1.</span>
<br><span style="color:red">- </span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspParameters</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp----------</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsppk : sequence</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspDefines the (discrete) distribution. ``pk[i]`` is the (possibly</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspunnormalized) probability of event ``i``.</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspqk : sequence, optional</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspSequence against which the relative entropy is computed. Should be in</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspthe same format as `pk`.</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspbase : float, optional</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThe logarithmic base to use, defaults to ``e`` (natural logarithm).</span>
<br><span style="color:red">- </span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspReturns</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp-------</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspS : float</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThe calculated entropy.</span>
<br><span style="color:red">- </span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsppk = asarray(pk)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsppk = 1.0*pk / np.sum(pk, axis=0)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspif qk is None:</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspvec = entr(pk)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspelse:</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspqk = asarray(qk)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif len(qk) != len(pk):</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("qk and pk must have same length.")</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspqk = 1.0*qk / np.sum(qk, axis=0)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspvec = rel_entr(pk, qk)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspS = np.sum(vec, axis=0)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspif base is not None:</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspS /= log(base)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspreturn S</span>
<br><span style="color:red">- </span>
<br><span style="color:red">- </span>
<br>&nbsp# Must over-ride one of _pmf or _cdf or pass in
<br>&nbsp#  x_k, p(x_k) lists in initialization
<br>&nbsp
<br><span style="color:green">+</span>
<br>&nbspclass rv_discrete(rv_generic):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspA generic discrete random variable class meant for subclassing.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp"""A generic discrete random variable class meant for subclassing.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp`rv_discrete` is a base class to construct specific distribution classes
<br>&nbsp &nbsp &nbsp &nbsp &nbspand instances for discrete random variables. It can also be used
<br>@@ -2541,8 +2862,9 @@ class rv_discrete(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbspmoment_tol : float, optional
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThe tolerance for the generic calculation of moments.
<br>&nbsp &nbsp &nbsp &nbsp &nbspvalues : tuple of two array_like, optional
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp``(xk, pk)`` where ``xk`` are integers with non-zero</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspprobabilities ``pk``  with ``sum(pk) = 1``.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp``(xk, pk)`` where ``xk`` are integers and ``pk`` are the non-zero</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspprobabilities between 0 and 1 with ``sum(pk) = 1``. ``xk``</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspand ``pk`` must have the same shape.</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspinc : integer, optional
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIncrement for the support of the distribution.
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspDefault is 1. (other values have not been tested)
<br>@@ -2566,12 +2888,15 @@ class rv_discrete(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThis string is used as the last part of the docstring returned when a
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsubclass has no docstring of its own. Note: `extradoc` exists for
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspbackwards compatibility, do not use for new subclasses.
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspseed : None or int or ``numpy.random.RandomState`` instance, optional</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThis parameter defines the RandomState object to use for drawing</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprandom variates.</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf None, the global np.random state is used.</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf integer, it is used to seed the local RandomState instance.</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspDefault is None.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspseed : {None, int, `numpy.random.Generator`,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp`numpy.random.RandomState`}, optional</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf `seed` is None (or `np.random`), the `numpy.random.RandomState`</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsingleton is used.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf `seed` is an int, a new ``RandomState`` instance is used,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspseeded with `seed`.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf `seed` is already a ``Generator`` or ``RandomState`` instance then</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspthat instance is used.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspMethods
<br>&nbsp &nbsp &nbsp &nbsp &nbsp-------
<br>@@ -2594,11 +2919,10 @@ class rv_discrete(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbspvar
<br>&nbsp &nbsp &nbsp &nbsp &nbspinterval
<br>&nbsp &nbsp &nbsp &nbsp &nbsp__call__
<br><span style="color:red">- </span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspsupport</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspNotes
<br>&nbsp &nbsp &nbsp &nbsp &nbsp-----
<br><span style="color:red">- </span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspThis class is similar to `rv_continuous`. Whether a shape parameter is
<br>&nbsp &nbsp &nbsp &nbsp &nbspvalid is decided by an ``_argcheck`` method (which defaults to checking
<br>&nbsp &nbsp &nbsp &nbsp &nbspthat its arguments are strictly positive.)
<br>@@ -2636,7 +2960,6 @@ class rv_discrete(rv_generic):
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspExamples
<br>&nbsp &nbsp &nbsp &nbsp &nbsp--------
<br><span style="color:red">- </span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspCustom made discrete distribution:
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp>>> from scipy import stats
<br>@@ -2656,8 +2979,8 @@ class rv_discrete(rv_generic):
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef __new__(cls, a=0, b=inf, name=None, badvalue=None,
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmoment_tol=1e-8, values=None, inc=1, longname=None,</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspshapes=None, extradoc=None, seed=None):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmoment_tol=1e-8, values=None, inc=1, longname=None,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspshapes=None, extradoc=None, seed=None):</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif values is not None:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# dispatch to a subclass
<br>@@ -2670,7 +2993,7 @@ class rv_discrete(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmoment_tol=1e-8, values=None, inc=1, longname=None,
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspshapes=None, extradoc=None, seed=None):
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsuper(rv_discrete, self).__init__(seed)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsuper().__init__(seed)</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# cf generic freeze
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._ctor_param = dict(
<br>@@ -2685,8 +3008,6 @@ class rv_discrete(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.b = b
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.moment_tol = moment_tol
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.inc = inc
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._cdfvec = vectorize(self._cdf_single, otypes='d')</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.vecentropy = vectorize(self._entropy)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.shapes = shapes
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif values is not None:
<br>@@ -2696,25 +3017,39 @@ class rv_discrete(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsplocscale_in='loc=0',
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# scale=1 for discrete RVs
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsplocscale_out='loc, 1')
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._attach_methods()</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._construct_docstrings(name, longname, extradoc)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdef __getstate__(self):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdct = self.__dict__.copy()</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# these methods will be remade in __setstate__</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspattrs = ["_parse_args", "_parse_args_stats", "_parse_args_rvs",</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"_cdfvec", "_ppfvec", "generic_moment"]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[dct.pop(attr, None) for attr in attrs]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn dct</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdef _attach_methods(self):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Attaches dynamically created methods to the rv_discrete instance."""</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._cdfvec = vectorize(self._cdf_single, otypes='d')</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.vecentropy = vectorize(self._entropy)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# _attach_methods is responsible for calling _attach_argparser_methods</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._attach_argparser_methods()</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# nin correction needs to be after we know numargs
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# correct nin for generic moment vectorization
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp_vec_generic_moment = vectorize(_drv2_moment, otypes='d')
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp_vec_generic_moment.nin = self.numargs + 2
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.generic_moment = instancemethod(_vec_generic_moment,</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself, rv_discrete)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.generic_moment = types.MethodType(_vec_generic_moment, self)</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# correct nin for ppf vectorization
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp_vppf = vectorize(_drv2_ppfsingle, otypes='d')
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp_vppf.nin = self.numargs + 2
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._ppfvec = instancemethod(_vppf,</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself, rv_discrete)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._ppfvec = types.MethodType(_vppf, self)</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# now that self.numargs is defined, we can adjust nin
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._cdfvec.nin = self.numargs + 1
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._construct_docstrings(name, longname, extradoc)</span>
<br><span style="color:red">- </span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef _construct_docstrings(self, name, longname, extradoc):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif name is None:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspname = 'Distribution'
<br>@@ -2746,10 +3081,10 @@ class rv_discrete(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp'optional\n        scale parameter (default=1)', '')
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef _updated_ctor_param(self):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp""" Return the current version of _ctor_param, possibly updated by user.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Return the current version of _ctor_param, possibly updated by user.</span>
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspUsed by freezing and pickling.</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspKeep this in sync with the signature of __init__.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspUsed by freezing.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspKeep this in sync with the signature of __init__.</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdct = self._ctor_param.copy()
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdct['a'] = self.a
<br>@@ -2772,7 +3107,8 @@ class rv_discrete(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn log(self._pmf(k, *args))
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef _cdf_single(self, k, *args):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspm = arange(int(self.a), k+1)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp_a, _b = self._get_support(*args)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspm = arange(int(_a), k+1)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn np.sum(self._pmf(m, *args), axis=0)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef _cdf(self, x, *args):
<br>@@ -2782,8 +3118,7 @@ class rv_discrete(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp# generic _logcdf, _sf, _logsf, _ppf, _isf, _rvs defined in rv_generic
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef rvs(self, *args, **kwargs):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspRandom variates of given type.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Random variates of given type.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -2793,12 +3128,17 @@ class rv_discrete(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsploc : array_like, optional
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspLocation parameter (default=0).
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsize : int or tuple of ints, optional
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspDefining number of random variates (Default is 1).  Note that `size`</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspDefining number of random variates (Default is 1). Note that `size`</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsphas to be given as keyword, not as positional argument.
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprandom_state : None or int or ``np.random.RandomState`` instance, optional</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf int or RandomState, use it for drawing the random variates.</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf None, rely on ``self.random_state``.</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspDefault is None.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprandom_state : {None, int, `numpy.random.Generator`,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp`numpy.random.RandomState`}, optional</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf `seed` is None (or `np.random`), the `numpy.random.RandomState`</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsingleton is used.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf `seed` is an int, a new ``RandomState`` instance is used,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspseeded with `seed`.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf `seed` is already a ``Generator`` or ``RandomState`` instance</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspthen that instance is used.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspReturns
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp-------
<br>@@ -2807,11 +3147,10 @@ class rv_discrete(rv_generic):
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspkwargs['discrete'] = True
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn super(rv_discrete, self).rvs(*args, **kwargs)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn super().rvs(*args, **kwargs)</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef pmf(self, k, *args, **kwds):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspProbability mass function at k of the given RV.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Probability mass function at k of the given RV.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -2832,9 +3171,10 @@ class rv_discrete(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspargs, loc, _ = self._parse_args(*args, **kwds)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspk, loc = map(asarray, (k, loc))
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspargs = tuple(map(asarray, args))
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp_a, _b = self._get_support(*args)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspk = asarray((k-loc))
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond0 = self._argcheck(*args)
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond1 = (k >= self.a) & (k <= self.b) & self._nonzero(k, *args)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond1 = (k >= _a) & (k <= _b) & self._nonzero(k, *args)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond = cond0 & cond1
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoutput = zeros(shape(cond), 'd')
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspplace(output, (1-cond0) + np.isnan(k), self.badvalue)
<br>@@ -2846,8 +3186,7 @@ class rv_discrete(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn output
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef logpmf(self, k, *args, **kwds):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspLog of the probability mass function at k of the given RV.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Log of the probability mass function at k of the given RV.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -2868,9 +3207,10 @@ class rv_discrete(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspargs, loc, _ = self._parse_args(*args, **kwds)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspk, loc = map(asarray, (k, loc))
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspargs = tuple(map(asarray, args))
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp_a, _b = self._get_support(*args)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspk = asarray((k-loc))
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond0 = self._argcheck(*args)
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond1 = (k >= self.a) & (k <= self.b) & self._nonzero(k, *args)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond1 = (k >= _a) & (k <= _b) & self._nonzero(k, *args)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond = cond0 & cond1
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoutput = empty(shape(cond), 'd')
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoutput.fill(NINF)
<br>@@ -2883,8 +3223,7 @@ class rv_discrete(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn output
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef cdf(self, k, *args, **kwds):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspCumulative distribution function of the given RV.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Cumulative distribution function of the given RV.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -2905,14 +3244,15 @@ class rv_discrete(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspargs, loc, _ = self._parse_args(*args, **kwds)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspk, loc = map(asarray, (k, loc))
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspargs = tuple(map(asarray, args))
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp_a, _b = self._get_support(*args)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspk = asarray((k-loc))
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond0 = self._argcheck(*args)
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond1 = (k >= self.a) & (k < self.b)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond2 = (k >= self.b)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond1 = (k >= _a) & (k < _b)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond2 = (k >= _b)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond = cond0 & cond1
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoutput = zeros(shape(cond), 'd')
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspplace(output, (1-cond0) + np.isnan(k), self.badvalue)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspplace(output, cond2*(cond0 == cond0), 1.0)
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspplace(output, (1-cond0) + np.isnan(k), self.badvalue)</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif np.any(cond):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspgoodargs = argsreduce(cond, *((k,)+args))
<br>@@ -2922,8 +3262,7 @@ class rv_discrete(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn output
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef logcdf(self, k, *args, **kwds):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspLog of the cumulative distribution function at k of the given RV.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Log of the cumulative distribution function at k of the given RV.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -2944,10 +3283,11 @@ class rv_discrete(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspargs, loc, _ = self._parse_args(*args, **kwds)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspk, loc = map(asarray, (k, loc))
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspargs = tuple(map(asarray, args))
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp_a, _b = self._get_support(*args)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspk = asarray((k-loc))
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond0 = self._argcheck(*args)
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond1 = (k >= self.a) & (k < self.b)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond2 = (k >= self.b)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond1 = (k >= _a) & (k < _b)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond2 = (k >= _b)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond = cond0 & cond1
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoutput = empty(shape(cond), 'd')
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoutput.fill(NINF)
<br>@@ -2962,8 +3302,7 @@ class rv_discrete(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn output
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef sf(self, k, *args, **kwds):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspSurvival function (1 - `cdf`) at k of the given RV.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Survival function (1 - `cdf`) at k of the given RV.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -2984,10 +3323,11 @@ class rv_discrete(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspargs, loc, _ = self._parse_args(*args, **kwds)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspk, loc = map(asarray, (k, loc))
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspargs = tuple(map(asarray, args))
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp_a, _b = self._get_support(*args)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspk = asarray(k-loc)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond0 = self._argcheck(*args)
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond1 = (k >= self.a) & (k < self.b)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond2 = (k < self.a) & cond0</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond1 = (k >= _a) & (k < _b)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond2 = (k < _a) & cond0</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond = cond0 & cond1
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoutput = zeros(shape(cond), 'd')
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspplace(output, (1-cond0) + np.isnan(k), self.badvalue)
<br>@@ -3000,8 +3340,7 @@ class rv_discrete(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn output
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef logsf(self, k, *args, **kwds):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspLog of the survival function of the given RV.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Log of the survival function of the given RV.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspReturns the log of the "survival function," defined as 1 - `cdf`,
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspevaluated at `k`.
<br>@@ -3025,10 +3364,11 @@ class rv_discrete(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspargs, loc, _ = self._parse_args(*args, **kwds)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspk, loc = map(asarray, (k, loc))
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspargs = tuple(map(asarray, args))
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp_a, _b = self._get_support(*args)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspk = asarray(k-loc)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond0 = self._argcheck(*args)
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond1 = (k >= self.a) & (k < self.b)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond2 = (k < self.a) & cond0</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond1 = (k >= _a) & (k < _b)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond2 = (k < _a) & cond0</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond = cond0 & cond1
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoutput = empty(shape(cond), 'd')
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoutput.fill(NINF)
<br>@@ -3042,8 +3382,7 @@ class rv_discrete(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn output
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef ppf(self, q, *args, **kwds):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspPercent point function (inverse of `cdf`) at q of the given RV.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Percent point function (inverse of `cdf`) at q of the given RV.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -3064,14 +3403,15 @@ class rv_discrete(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspargs, loc, _ = self._parse_args(*args, **kwds)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspq, loc = map(asarray, (q, loc))
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspargs = tuple(map(asarray, args))
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp_a, _b = self._get_support(*args)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond0 = self._argcheck(*args) & (loc == loc)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond1 = (q > 0) & (q < 1)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond2 = (q == 1) & cond0
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond = cond0 & cond1
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoutput = valarray(shape(cond), value=self.badvalue, typecode='d')</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoutput = np.full(shape(cond), fill_value=self.badvalue, dtype='d')</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# output type 'd' to handle nin and inf
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspplace(output, (q == 0)*(cond == cond), self.a-1)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspplace(output, cond2, self.b)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspplace(output, (q == 0)*(cond == cond), _a-1 + loc)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspplace(output, cond2, _b + loc)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif np.any(cond):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspgoodargs = argsreduce(cond, *((q,)+args+(loc,)))
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsploc, goodargs = goodargs[-1], goodargs[:-1]
<br>@@ -3082,8 +3422,7 @@ class rv_discrete(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn output
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef isf(self, q, *args, **kwds):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspInverse survival function (inverse of `sf`) at q of the given RV.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Inverse survival function (inverse of `sf`) at q of the given RV.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -3104,16 +3443,20 @@ class rv_discrete(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspargs, loc, _ = self._parse_args(*args, **kwds)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspq, loc = map(asarray, (q, loc))
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspargs = tuple(map(asarray, args))
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp_a, _b = self._get_support(*args)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond0 = self._argcheck(*args) & (loc == loc)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond1 = (q > 0) & (q < 1)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond2 = (q == 1) & cond0
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond3 = (q == 0) & cond0</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond = cond0 & cond1
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# same problem as with ppf; copied from ppf and changed
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoutput = valarray(shape(cond), value=self.badvalue, typecode='d')</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoutput = np.full(shape(cond), fill_value=self.badvalue, dtype='d')</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# output type 'd' to handle nin and inf
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspplace(output, (q == 0)*(cond == cond), self.b)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspplace(output, cond2, self.a-1)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsplower_bound = _a - 1 + loc</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspupper_bound = _b + loc</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspplace(output, cond2*(cond == cond), lower_bound)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspplace(output, cond3*(cond == cond), upper_bound)</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# call place only if at least 1 valid argument
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif np.any(cond):
<br>@@ -3128,16 +3471,17 @@ class rv_discrete(rv_generic):
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef _entropy(self, *args):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif hasattr(self, 'pk'):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn entropy(self.pk)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn stats.entropy(self.pk)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelse:
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp_a, _b = self._get_support(*args)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn _expect(lambda x: entr(self.pmf(x, *args)),
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.a, self.b, self.ppf(0.5, *args), self.inc)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp_a, _b, self.ppf(0.5, *args), self.inc)</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef expect(self, func=None, args=(), loc=0, lb=None, ub=None,
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspconditional=False, maxcount=1000, tolerance=1e-10, chunksize=32):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspCalculate expected value of a function with respect to the distribution
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspfor discrete distribution.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspfor discrete distribution by numerical summation.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -3152,12 +3496,12 @@ class rv_discrete(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspDefault is 0.
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsplb, ub : int, optional
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspLower and upper bound for the summation, default is set to the
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsupport of the distribution, inclusive (``ul <= k <= ub``).</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsupport of the distribution, inclusive (``lb <= k <= ub``).</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspconditional : bool, optional
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf true then the expectation is corrected by the conditional
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspprobability of the summation interval. The return value is the
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspexpectation of the function, `func`, conditional on being in
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspthe given interval (k such that ``ul <= k <= ub``).</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspthe given interval (k such that ``lb <= k <= ub``).</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspDefault is False.
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmaxcount : int, optional
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspMaximal number of terms to evaluate (to avoid an endless loop for
<br>@@ -3175,12 +3519,14 @@ class rv_discrete(rv_generic):
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspNotes
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp-----
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspFor heavy-tailed distributions, the expected value may or may not exist,</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdepending on the function, `func`. If it does exist, but the sum converges</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspFor heavy-tailed distributions, the expected value may or</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmay not exist,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdepending on the function, `func`. If it does exist, but the</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsum converges</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspslowly, the accuracy of the result may be rather low. For instance, for
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp``zipf(4)``, accuracy for mean, variance in example is only 1e-5.
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspincreasing `maxcount` and/or `chunksize` may improve the result, but may also</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmake zipf very slow.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspincreasing `maxcount` and/or `chunksize` may improve the result,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspbut may also make zipf very slow.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThe function is not vectorized.
<br>&nbsp
<br>@@ -3197,13 +3543,13 @@ class rv_discrete(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# might be problems(?) with correct self.a, self.b at this stage maybe
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# not anymore, seems to work now with _pmf
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._argcheck(*args)  # (re)generate scalar self.a and self.b</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp_a, _b = self._get_support(*args)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif lb is None:
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsplb = self.a</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsplb = _a</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelse:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsplb = lb - loc   # convert bound for standardized distribution
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif ub is None:
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspub = self.b</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspub = _b</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelse:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspub = ub - loc   # convert bound for standardized distribution
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif conditional:
<br>@@ -3211,6 +3557,10 @@ class rv_discrete(rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelse:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspinvfac = 1.0
<br>&nbsp
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif isinstance(self, rv_sample):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspres = self._expect(fun, lb, ub)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn res / invfac</span>
<br><span style="color:green">+</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# iterate over the support, starting from the median
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspx0 = self.ppf(0.5, *args)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspres = _expect(fun, lb, ub, x0, self.inc, maxcount, tolerance, chunksize)
<br>@@ -3220,7 +3570,6 @@ class rv_discrete(rv_generic):
<br>&nbspdef _expect(fun, lb, ub, x0, inc, maxcount=1000, tolerance=1e-10,
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspchunksize=32):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""Helper for computing the expectation value of `fun`."""
<br><span style="color:red">- </span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp# short-circuit if the support size is small enough
<br>&nbsp &nbsp &nbsp &nbsp &nbspif (ub - lb) <= chunksize:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsupp = np.arange(lb, ub+1, inc)
<br>@@ -3262,7 +3611,8 @@ def _expect(fun, lb, ub, x0, inc, maxcount=1000, tolerance=1e-10,
<br>&nbspdef _iter_chunked(x0, x1, chunksize=4, inc=1):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""Iterate from x0 to x1 in chunks of chunksize and steps inc.
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspx0 must be finite, x1 need not be. In the latter case, the iterator is infinite.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspx0 must be finite, x1 need not be. In the latter case, the iterator is</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspinfinite.</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspHandles both x0 < x1 and x0 > x1. In the latter case, iterates downwards
<br>&nbsp &nbsp &nbsp &nbsp &nbsp(make sure to set inc < 0.)
<br>&nbsp
<br>@@ -3296,7 +3646,7 @@ def _iter_chunked(x0, x1, chunksize=4, inc=1):
<br>&nbspclass rv_sample(rv_discrete):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""A 'sample' discrete distribution defined by the support and values.
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThe ctor ignores most of the arguments, only needs the `values` argument.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspThe ctor ignores most of the arguments, only needs the `values` argument.</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef __init__(self, a=0, b=inf, name=None, badvalue=None,
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmoment_tol=1e-8, values=None, inc=1, longname=None,
<br>@@ -3323,8 +3673,10 @@ class rv_sample(rv_discrete):
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspxk, pk = values
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif len(xk) != len(pk):</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("xk and pk need to have the same length.")</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif np.shape(xk) != np.shape(pk):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("xk and pk must have the same shape.")</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif np.less(pk, 0.0).any():</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("All elements of pk must be non-negative.")</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif not np.allclose(np.sum(pk), 1):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("The sum of provided pk is not 1.")
<br>&nbsp
<br>@@ -3333,16 +3685,50 @@ class rv_sample(rv_discrete):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.pk = np.take(np.ravel(pk), indx, 0)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.a = self.xk[0]
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.b = self.xk[-1]
<br><span style="color:green">+</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.qvals = np.cumsum(self.pk, axis=0)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.shapes = ' '   # bypass inspection
<br><span style="color:green">+</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._construct_argparser(meths_to_inspect=[self._pmf],
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsplocscale_in='loc=0',
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# scale=1 for discrete RVs
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsplocscale_out='loc, 1')
<br>&nbsp
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._attach_methods()</span>
<br><span style="color:green">+</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._construct_docstrings(name, longname, extradoc)
<br>&nbsp
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdef __getstate__(self):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdct = self.__dict__.copy()</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# these methods will be remade in rv_generic.__setstate__,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# which calls rv_generic._attach_methods</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspattrs = ["_parse_args", "_parse_args_stats", "_parse_args_rvs"]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[dct.pop(attr, None) for attr in attrs]</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn dct</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdef _attach_methods(self):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Attaches dynamically created argparser methods."""</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._attach_argparser_methods()</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdef _get_support(self, *args):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Return the support of the (unscaled, unshifted) distribution.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsparg1, arg2, ... : array_like</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThe shape parameter(s) for the distribution (see docstring of the</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspinstance object for more information).</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspReturns</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp-------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspa, b : numeric (float, or int or +/-np.inf)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspend-points of the distribution's support.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn self.a, self.b</span>
<br><span style="color:green">+</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef _pmf(self, x):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn np.select([x == k for k in self.xk],
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[np.broadcast_arrays(p, x)[0] for p in self.pk], 0)
<br>@@ -3357,11 +3743,11 @@ class rv_sample(rv_discrete):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspindx = argmax(sqq >= qq, axis=-1)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn self.xk[indx]
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspdef _rvs(self):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdef _rvs(self, size=None, random_state=None):</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# Need to define it explicitly, otherwise .rvs() with size=None
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# fails due to explicit broadcasting in _ppf
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspU = self._random_state.random_sample(self._size)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif self._size is None:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspU = random_state.uniform(size=size)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif size is None:</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspU = np.array(U, ndmin=1)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspY = self._ppf(U)[0]
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelse:
<br>@@ -3369,16 +3755,59 @@ class rv_sample(rv_discrete):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn Y
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef _entropy(self):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn entropy(self.pk)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn stats.entropy(self.pk)</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef generic_moment(self, n):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspn = asarray(n)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn np.sum(self.xk**n[np.newaxis, ...] * self.pk, axis=0)
<br>&nbsp
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdef _expect(self, fun, lb, ub, *args, **kwds):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# ignore all args, just do a brute force summation</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsupp = self.xk[(lb <= self.xk) & (self.xk <= ub)]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspvals = fun(supp)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn np.sum(vals)</span>
<br><span style="color:green">+</span>
<br>&nbsp
<br><span style="color:red">- def get_distribution_names(namespace_pairs, rv_base_class):</span>
<br><span style="color:green">+def _check_shape(argshape, size):</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspCollect names of statistical distributions and their generators.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspThis is a utility function used by `_rvs()` in the class geninvgauss_gen.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspIt compares the tuple argshape to the tuple size.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspParameters</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp----------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspargshape : tuple of integers</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspShape of the arguments.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspsize : tuple of integers or integer</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspSize argument of rvs().</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspReturns</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp-------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspThe function returns two tuples, scalar_shape and bc.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspscalar_shape : tuple</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspShape to which the 1-d array of random variates returned by</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp_rvs_scalar() is converted when it is copied into the</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoutput array of _rvs().</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspbc : tuple of booleans</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspbc is an tuple the same length as size. bc[j] is True if the data</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspassociated with that index is generated in one call of _rvs_scalar().</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspscalar_shape = []</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspbc = []</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspfor argdim, sizedim in zip_longest(argshape[::-1], size[::-1],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspfillvalue=1):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif sizedim > argdim or (argdim == sizedim == 1):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspscalar_shape.append(sizedim)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspbc.append(True)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelse:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspbc.append(False)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspreturn tuple(scalar_shape[::-1]), tuple(bc[::-1])</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+def get_distribution_names(namespace_pairs, rv_base_class):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp"""Collect names of statistical distributions and their generators.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp----------
<br></p>
</div>
<br><br><br>_____________________________________scipy/stats/_multivariate.py_________________________________________
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>File_Path</th>
      <th>Line_Number</th>
      <th>Found_in_Function</th>
      <th>Function_Definition_Line_Number</th>
      <th>Assert_Statement_Type</th>
      <th>Oracle_Argument_ Position</th>
      <th>Differential_Function_Line_Number</th>
      <th>Differential_Test_Function</th>
      <th>Extracted_Function_File_Location</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>33344</th>
      <td>kernel_tests\distributions\dirichlet_test.py</td>
      <td>164</td>
      <td>testMean</td>
      <td>157</td>
      <td>assertAllClose</td>
      <td>2</td>
      <td>163</td>
      <td>stats.dirichlet.mean</td>
      <td>scipy/stats/_multivariate.py</td>
    </tr>
    <tr>
      <th>33353</th>
      <td>kernel_tests\distributions\dirichlet_test.py</td>
      <td>248</td>
      <td>testEntropy</td>
      <td>241</td>
      <td>assertAllClose</td>
      <td>2</td>
      <td>247</td>
      <td>stats.dirichlet.entropy</td>
      <td>scipy/stats/_multivariate.py</td>
    </tr>
  </tbody>
</table>
<br><button type="button" class="collapsible">Git Diff</button>
<div class="content">
<p>diff --git a/scipy/stats/_multivariate.py b/scipy/stats/_multivariate.py
<br>index 41dd35830..5bdf66be7 100644
<br><span style="color:red">- -- a/scipy/stats/_multivariate.py</span>
<br><span style="color:green">+++ b/scipy/stats/_multivariate.py</span>
<br>@@ -1,15 +1,16 @@
<br>&nbsp#
<br>&nbsp# Author: Joris Vankerschaver 2013
<br>&nbsp#
<br><span style="color:red">- from __future__ import division, print_function, absolute_import</span>
<br><span style="color:red">- </span>
<br>&nbspimport math
<br>&nbspimport numpy as np
<br><span style="color:green">+from numpy import asarray_chkfinite, asarray</span>
<br>&nbspimport scipy.linalg
<br><span style="color:red">- from scipy.misc import doccer</span>
<br><span style="color:red">- from scipy.special import gammaln, psi, multigammaln, xlogy, entr</span>
<br><span style="color:green">+from scipy._lib import doccer</span>
<br><span style="color:green">+from scipy.special import gammaln, psi, multigammaln, xlogy, entr, betaln</span>
<br>&nbspfrom scipy._lib._util import check_random_state
<br>&nbspfrom scipy.linalg.blas import drot
<br><span style="color:green">+from scipy.linalg.misc import LinAlgError</span>
<br><span style="color:green">+from scipy.linalg.lapack import get_lapack_funcs</span>
<br>&nbsp
<br>&nbspfrom ._discrete_distns import binom
<br>&nbspfrom . import mvn
<br>@@ -23,7 +24,9 @@ __all__ = ['multivariate_normal',
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp'special_ortho_group',
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp'ortho_group',
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp'random_correlation',
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp'unitary_group']</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp'unitary_group',</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp'multivariate_t',</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp'multivariate_hypergeom']</span>
<br>&nbsp
<br>&nbsp_LOG_2PI = np.log(2 * np.pi)
<br>&nbsp_LOG_2 = np.log(2)
<br>@@ -31,17 +34,22 @@ _LOG_PI = np.log(np.pi)
<br>&nbsp
<br>&nbsp
<br>&nbsp_doc_random_state = """\
<br><span style="color:red">- random_state : None or int or np.random.RandomState instance, optional</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspIf int or RandomState, use it for drawing the random variates.</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspIf None (or np.random), the global np.random state is used.</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspDefault is None.</span>
<br><span style="color:green">+random_state : {None, int, `numpy.random.Generator`,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp`numpy.random.RandomState`}, optional</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspIf `seed` is None (or `np.random`), the `numpy.random.RandomState`</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspsingleton is used.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspIf `seed` is an int, a new ``RandomState`` instance is used,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspseeded with `seed`.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspIf `seed` is already a ``Generator`` or ``RandomState`` instance then</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspthat instance is used.</span>
<br>&nbsp"""
<br>&nbsp
<br><span style="color:green">+</span>
<br>&nbspdef _squeeze_output(out):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp &nbsp &nbsp &nbsp &nbspRemove single-dimensional entries from array and convert to scalar,
<br>&nbsp &nbsp &nbsp &nbsp &nbspif necessary.
<br><span style="color:red">- </span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp &nbsp &nbsp &nbsp &nbspout = out.squeeze()
<br>&nbsp &nbsp &nbsp &nbsp &nbspif out.ndim == 0:
<br>@@ -50,8 +58,7 @@ def _squeeze_output(out):
<br>&nbsp
<br>&nbsp
<br>&nbspdef _eigvalsh_to_eps(spectrum, cond=None, rcond=None):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspDetermine which eigenvalues are "small" given the spectrum.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp"""Determine which eigenvalues are "small" given the spectrum.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspThis is for compatibility across various linear algebra functions
<br>&nbsp &nbsp &nbsp &nbsp &nbspthat should agree about whether or not a Hermitian matrix is numerically
<br>@@ -85,8 +92,7 @@ def _eigvalsh_to_eps(spectrum, cond=None, rcond=None):
<br>&nbsp
<br>&nbsp
<br>&nbspdef _pinv_1d(v, eps=1e-5):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspA helper function for computing the pseudoinverse.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp"""A helper function for computing the pseudoinverse.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -104,7 +110,7 @@ def _pinv_1d(v, eps=1e-5):
<br>&nbsp &nbsp &nbsp &nbsp &nbspreturn np.array([0 if abs(x) <= eps else 1/x for x in v], dtype=float)
<br>&nbsp
<br>&nbsp
<br><span style="color:red">- class _PSD(object):</span>
<br><span style="color:green">+class _PSD:</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp &nbsp &nbsp &nbsp &nbspCompute coordinated functions of a symmetric positive semidefinite matrix.
<br>&nbsp
<br>@@ -175,25 +181,25 @@ class _PSD(object):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn self._pinv
<br>&nbsp
<br>&nbsp
<br><span style="color:red">- class multi_rv_generic(object):</span>
<br><span style="color:green">+class multi_rv_generic:</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp &nbsp &nbsp &nbsp &nbspClass which encapsulates common functionality between all multivariate
<br>&nbsp &nbsp &nbsp &nbsp &nbspdistributions.
<br><span style="color:red">- </span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef __init__(self, seed=None):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsuper(multi_rv_generic, self).__init__()</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsuper().__init__()</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._random_state = check_random_state(seed)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp@property
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef random_state(self):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp""" Get or set the RandomState object for generating random variates.</span>
<br><span style="color:red">- </span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThis can be either None or an existing RandomState object.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp""" Get or set the Generator object for generating random variates.</span>
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf None (or np.random), use the RandomState singleton used by np.random.</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf already a RandomState instance, use it.</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf an int, use a new RandomState instance seeded with seed.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf `seed` is None (or `np.random`), the `numpy.random.RandomState`</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsingleton is used.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf `seed` is an int, a new ``RandomState`` instance is used,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspseeded with `seed`.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf `seed` is already a ``Generator`` or ``RandomState`` instance then</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspthat instance is used.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn self._random_state
<br>@@ -209,7 +215,7 @@ class multi_rv_generic(object):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn self._random_state
<br>&nbsp
<br>&nbsp
<br><span style="color:red">- class multi_rv_frozen(object):</span>
<br><span style="color:green">+class multi_rv_frozen:</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp &nbsp &nbsp &nbsp &nbspClass which encapsulates common functionality between all frozen
<br>&nbsp &nbsp &nbsp &nbsp &nbspmultivariate distributions.
<br>@@ -222,6 +228,7 @@ class multi_rv_frozen(object):
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef random_state(self, seed):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._dist._random_state = check_random_state(seed)
<br>&nbsp
<br><span style="color:green">+</span>
<br>&nbsp_mvn_doc_default_callparams = """\
<br>&nbspmean : array_like, optional
<br>&nbsp &nbsp &nbsp &nbsp &nbspMean of the distribution (default zero)
<br>@@ -256,9 +263,9 @@ mvn_docdict_noparams = {
<br>&nbsp &nbsp &nbsp &nbsp &nbsp'_doc_random_state': _doc_random_state
<br>&nbsp}
<br>&nbsp
<br><span style="color:green">+</span>
<br>&nbspclass multivariate_normal_gen(multi_rv_generic):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspr"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspA multivariate normal random variable.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspr"""A multivariate normal random variable.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspThe `mean` keyword specifies the mean. The `cov` keyword specifies the
<br>&nbsp &nbsp &nbsp &nbsp &nbspcovariance matrix.
<br>@@ -342,15 +349,13 @@ class multivariate_normal_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef __init__(self, seed=None):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsuper(multivariate_normal_gen, self).__init__(seed)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsuper().__init__(seed)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.__doc__ = doccer.docformat(self.__doc__, mvn_docdict_params)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef __call__(self, mean=None, cov=1, allow_singular=False, seed=None):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspCreate a frozen multivariate normal distribution.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Create a frozen multivariate normal distribution.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspSee `multivariate_normal_frozen` for more information.
<br><span style="color:red">- </span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn multivariate_normal_frozen(mean, cov,
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspallow_singular=allow_singular,
<br>@@ -360,9 +365,7 @@ class multivariate_normal_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspInfer dimensionality from mean or covariance matrix, ensure that
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmean and covariance are full vector resp. matrix.
<br><span style="color:red">- </span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""
<br><span style="color:red">- </span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# Try to infer dimensionality
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif dim is None:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif mean is None:
<br>@@ -379,9 +382,11 @@ class multivariate_normal_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdim = mean.size
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelse:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif not np.isscalar(dim):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("Dimension of random variable must be a scalar.")</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("Dimension of random variable must be "</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"a scalar.")</span>
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# Check input sizes and return full arrays for mean and cov if necessary</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# Check input sizes and return full arrays for mean and cov if</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# necessary</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif mean is None:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmean = np.zeros(dim)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmean = np.asarray(mean, dtype=float)
<br>@@ -395,7 +400,8 @@ class multivariate_normal_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcov.shape = (1, 1)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif mean.ndim != 1 or mean.shape[0] != dim:
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("Array 'mean' must be a vector of length %d." % dim)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("Array 'mean' must be a vector of length %d." %</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdim)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif cov.ndim == 0:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcov = cov * np.eye(dim)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelif cov.ndim == 1:
<br>@@ -420,7 +426,6 @@ class multivariate_normal_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspAdjust quantiles array so that last axis labels the components of
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspeach data point.
<br><span style="color:red">- </span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspx = np.asarray(x, dtype=float)
<br>&nbsp
<br>@@ -435,7 +440,8 @@ class multivariate_normal_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn x
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef _logpdf(self, x, mean, prec_U, log_det_cov, rank):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Log of the multivariate normal probability density function.</span>
<br><span style="color:green">+</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspx : ndarray
<br>@@ -462,8 +468,7 @@ class multivariate_normal_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn -0.5 * (rank * _LOG_2PI + log_det_cov + maha)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef logpdf(self, x, mean=None, cov=1, allow_singular=False):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspLog of the multivariate normal probability density function.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Log of the multivariate normal probability density function.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -488,8 +493,7 @@ class multivariate_normal_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn _squeeze_output(out)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef pdf(self, x, mean=None, cov=1, allow_singular=False):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspMultivariate normal probability density function.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Multivariate normal probability density function.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -514,7 +518,8 @@ class multivariate_normal_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn _squeeze_output(out)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef _cdf(self, x, mean, cov, maxpts, abseps, releps):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Log of the multivariate normal cumulative distribution function.</span>
<br><span style="color:green">+</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspx : ndarray
<br>@@ -523,11 +528,11 @@ class multivariate_normal_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspMean of the distribution
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcov : array_like
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspCovariance matrix of the distribution
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmaxpts: integer</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmaxpts : integer</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThe maximum number of points to use for integration
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspabseps: float</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspabseps : float</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspAbsolute error tolerance
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreleps: float</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreleps : float</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspRelative error tolerance
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspNotes
<br>@@ -547,20 +552,19 @@ class multivariate_normal_gen(multi_rv_generic):
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef logcdf(self, x, mean=None, cov=1, allow_singular=False, maxpts=None,
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspabseps=1e-5, releps=1e-5):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspLog of the multivariate normal cumulative distribution function.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Log of the multivariate normal cumulative distribution function.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspx : array_like
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspQuantiles, with the last axis of `x` denoting the components.
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp%(_mvn_doc_default_callparams)s
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmaxpts: integer, optional</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmaxpts : integer, optional</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThe maximum number of points to use for integration
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp(default `1000000*dim`)
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspabseps: float, optional</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspabseps : float, optional</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspAbsolute error tolerance (default 1e-5)
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreleps: float, optional</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreleps : float, optional</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspRelative error tolerance (default 1e-5)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspReturns
<br>@@ -586,20 +590,19 @@ class multivariate_normal_gen(multi_rv_generic):
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef cdf(self, x, mean=None, cov=1, allow_singular=False, maxpts=None,
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspabseps=1e-5, releps=1e-5):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspMultivariate normal cumulative distribution function.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Multivariate normal cumulative distribution function.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspx : array_like
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspQuantiles, with the last axis of `x` denoting the components.
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp%(_mvn_doc_default_callparams)s
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmaxpts: integer, optional</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmaxpts : integer, optional</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThe maximum number of points to use for integration
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp(default `1000000*dim`)
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspabseps: float, optional</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspabseps : float, optional</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspAbsolute error tolerance (default 1e-5)
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreleps: float, optional</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreleps : float, optional</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspRelative error tolerance (default 1e-5)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspReturns
<br>@@ -624,8 +627,7 @@ class multivariate_normal_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn out
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef rvs(self, mean=None, cov=1, size=1, random_state=None):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspDraw random samples from a multivariate normal distribution.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Draw random samples from a multivariate normal distribution.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -652,8 +654,7 @@ class multivariate_normal_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn _squeeze_output(out)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef entropy(self, mean=None, cov=1):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspCompute the differential entropy of the multivariate normal.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Compute the differential entropy of the multivariate normal.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -680,8 +681,7 @@ multivariate_normal = multivariate_normal_gen()
<br>&nbspclass multivariate_normal_frozen(multi_rv_frozen):
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef __init__(self, mean=None, cov=1, allow_singular=False, seed=None,
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmaxpts=None, abseps=1e-5, releps=1e-5):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspCreate a frozen multivariate normal distribution.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Create a frozen multivariate normal distribution.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -692,19 +692,22 @@ class multivariate_normal_frozen(multi_rv_frozen):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspallow_singular : bool, optional
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf this flag is True then tolerate a singular
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcovariance matrix (default False).
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspseed : None or int or np.random.RandomState instance, optional</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThis parameter defines the RandomState object to use for drawing</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprandom variates.</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf None (or np.random), the global np.random state is used.</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf integer, it is used to seed the local RandomState instance</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspDefault is None.</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmaxpts: integer, optional</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspseed : {None, int, `numpy.random.Generator`,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp`numpy.random.RandomState`}, optional</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf `seed` is None (or `np.random`), the `numpy.random.RandomState`</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsingleton is used.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf `seed` is an int, a new ``RandomState`` instance is used,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspseeded with `seed`.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf `seed` is already a ``Generator`` or ``RandomState`` instance</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspthen that instance is used.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmaxpts : integer, optional</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThe maximum number of points to use for integration of the
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcumulative distribution function (default `1000000*dim`)
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspabseps: float, optional</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspabseps : float, optional</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspAbsolute error tolerance for the cumulative distribution function
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp(default 1e-5)
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreleps: float, optional</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreleps : float, optional</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspRelative error tolerance for the cumulative distribution function
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp(default 1e-5)
<br>&nbsp
<br>@@ -753,8 +756,7 @@ class multivariate_normal_frozen(multi_rv_frozen):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn self._dist.rvs(self.mean, self.cov, size, random_state)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef entropy(self):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspComputes the differential entropy of the multivariate normal.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Computes the differential entropy of the multivariate normal.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspReturns
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp-------
<br>@@ -766,12 +768,14 @@ class multivariate_normal_frozen(multi_rv_frozen):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprank = self.cov_info.rank
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn 0.5 * (rank * (_LOG_2PI + 1) + log_pdet)
<br>&nbsp
<br><span style="color:green">+</span>
<br>&nbsp# Set frozen generator docstrings from corresponding docstrings in
<br>&nbsp# multivariate_normal_gen and fill in default strings in class docstrings
<br>&nbspfor name in ['logpdf', 'pdf', 'logcdf', 'cdf', 'rvs']:
<br>&nbsp &nbsp &nbsp &nbsp &nbspmethod = multivariate_normal_gen.__dict__[name]
<br>&nbsp &nbsp &nbsp &nbsp &nbspmethod_frozen = multivariate_normal_frozen.__dict__[name]
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspmethod_frozen.__doc__ = doccer.docformat(method.__doc__, mvn_docdict_noparams)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspmethod_frozen.__doc__ = doccer.docformat(method.__doc__,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmvn_docdict_noparams)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspmethod.__doc__ = doccer.docformat(method.__doc__, mvn_docdict_params)
<br>&nbsp
<br>&nbsp_matnorm_doc_default_callparams = """\
<br>@@ -811,9 +815,10 @@ matnorm_docdict_noparams = {
<br>&nbsp &nbsp &nbsp &nbsp &nbsp'_matnorm_doc_callparams_note': _matnorm_doc_frozen_callparams_note,
<br>&nbsp &nbsp &nbsp &nbsp &nbsp'_doc_random_state': _doc_random_state
<br>&nbsp}
<br><span style="color:green">+</span>
<br><span style="color:green">+</span>
<br>&nbspclass matrix_normal_gen(multi_rv_generic):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspr"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspA matrix normal random variable.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspr"""A matrix normal random variable.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspThe `mean` keyword specifies the mean. The `rowcov` keyword specifies the
<br>&nbsp &nbsp &nbsp &nbsp &nbspamong-row covariance matrix. The 'colcov' keyword specifies the
<br>@@ -909,15 +914,15 @@ class matrix_normal_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp>>> equiv_cov = np.kron(V,U)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp>>> multivariate_normal.pdf(vectorised_X, mean=equiv_mean, cov=equiv_cov)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp0.023410202050005054
<br><span style="color:green">+</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef __init__(self, seed=None):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsuper(matrix_normal_gen, self).__init__(seed)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsuper().__init__(seed)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.__doc__ = doccer.docformat(self.__doc__, matnorm_docdict_params)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef __call__(self, mean=None, rowcov=1, colcov=1, seed=None):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspCreate a frozen matrix normal distribution.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Create a frozen matrix normal distribution.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspSee `matrix_normal_frozen` for more information.
<br>&nbsp
<br>@@ -928,7 +933,6 @@ class matrix_normal_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspInfer dimensionality from mean or covariance matrices. Handle
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdefaults. Ensure compatible dimensions.
<br><span style="color:red">- </span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# Process mean
<br>@@ -979,13 +983,13 @@ class matrix_normal_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# Ensure mean and covariances compatible
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif mean is not None:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif meanshape[0] != numrows:
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("Arrays `mean` and `rowcov` must have the"</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"same number of rows.")</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("Arrays `mean` and `rowcov` must have the "</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"same number of rows.")</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif meanshape[1] != numcols:
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("Arrays `mean` and `colcov` must have the"</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"same number of columns.")</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("Arrays `mean` and `colcov` must have the "</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"same number of columns.")</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelse:
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmean = np.zeros((numrows,numcols))</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmean = np.zeros((numrows, numcols))</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdims = (numrows, numcols)
<br>&nbsp
<br>@@ -995,19 +999,19 @@ class matrix_normal_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspAdjust quantiles array so that last two axes labels the components of
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspeach data point.
<br><span style="color:red">- </span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspX = np.asarray(X, dtype=float)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif X.ndim == 2:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspX = X[np.newaxis, :]
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif X.shape[-2:] != dims:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("The shape of array `X` is not compatible "
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"with the distribution parameters.")</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"with the distribution parameters.")</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn X
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef _logpdf(self, dims, X, mean, row_prec_rt, log_det_rowcov,
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcol_prec_rt, log_det_colcov):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Log of the matrix normal probability density function.</span>
<br><span style="color:green">+</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdims : tuple
<br>@@ -1043,8 +1047,7 @@ class matrix_normal_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp+ numrows*log_det_colcov + maha)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef logpdf(self, X, mean=None, rowcov=1, colcov=1):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspLog of the matrix normal probability density function.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Log of the matrix normal probability density function.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -1072,8 +1075,7 @@ class matrix_normal_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn _squeeze_output(out)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef pdf(self, X, mean=None, rowcov=1, colcov=1):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspMatrix normal probability density function.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Matrix normal probability density function.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -1094,8 +1096,7 @@ class matrix_normal_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn np.exp(self.logpdf(X, mean, rowcov, colcov))
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef rvs(self, mean=None, rowcov=1, colcov=1, size=1, random_state=None):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspDraw random samples from a matrix normal distribution.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Draw random samples from a matrix normal distribution.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -1121,44 +1122,50 @@ class matrix_normal_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprowchol = scipy.linalg.cholesky(rowcov, lower=True)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcolchol = scipy.linalg.cholesky(colcov, lower=True)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprandom_state = self._get_random_state(random_state)
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspstd_norm = random_state.standard_normal(size=(dims[1],size,dims[0]))</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspstd_norm = random_state.standard_normal(size=(dims[1], size, dims[0]))</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsproll_rvs = np.tensordot(colchol, np.dot(std_norm, rowchol.T), 1)
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspout = np.rollaxis(roll_rvs.T, axis=1, start=0) + mean[np.newaxis,:,:]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspout = np.rollaxis(roll_rvs.T, axis=1, start=0) + mean[np.newaxis, :, :]</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif size == 1:
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp#out = np.squeeze(out, axis=0)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspout = out.reshape(mean.shape)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn out
<br>&nbsp
<br><span style="color:green">+</span>
<br>&nbspmatrix_normal = matrix_normal_gen()
<br>&nbsp
<br>&nbsp
<br>&nbspclass matrix_normal_frozen(multi_rv_frozen):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspdef __init__(self, mean=None, rowcov=1, colcov=1, seed=None):</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspCreate a frozen matrix normal distribution.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp"""Create a frozen matrix normal distribution.</span>
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp%(_matnorm_doc_default_callparams)s</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspseed : None or int or np.random.RandomState instance, optional</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf int or RandomState, use it for drawing the random variates.</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf None (or np.random), the global np.random state is used.</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspDefault is None.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspParameters</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp----------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp%(_matnorm_doc_default_callparams)s</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspseed : {None, int, `numpy.random.Generator`,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp`numpy.random.RandomState`}, optional</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf `seed` is None (or `np.random`), the `numpy.random.RandomState`</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsingleton is used.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf `seed` is an int, a new ``RandomState`` instance is used,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspseeded with `seed`.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf `seed` is already a ``Generator`` or ``RandomState`` instance</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspthen that instance is used.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspExamples</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp--------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> from scipy.stats import matrix_normal</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> distn = matrix_normal(mean=np.zeros((3,3)))</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> X = distn.rvs(); X</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsparray([[-0.02976962,  0.93339138, -0.09663178],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[ 0.67405524,  0.28250467, -0.93308929],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[-0.31144782,  0.74535536,  1.30412916]])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> distn.pdf(X)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp2.5160642368346784e-05</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> distn.logpdf(X)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp-10.590229595124615</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdef __init__(self, mean=None, rowcov=1, colcov=1, seed=None):</span>
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspExamples</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp--------</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp>>> from scipy.stats import matrix_normal</span>
<br><span style="color:red">- </span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp>>> distn = matrix_normal(mean=np.zeros((3,3)))</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp>>> X = distn.rvs(); X</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsparray([[-0.02976962,  0.93339138, -0.09663178],</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[ 0.67405524,  0.28250467, -0.93308929],</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[-0.31144782,  0.74535536,  1.30412916]])</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp>>> distn.pdf(X)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp2.5160642368346784e-05</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp>>> distn.logpdf(X)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp-10.590229595124615</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._dist = matrix_normal_gen(seed)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.dims, self.mean, self.rowcov, self.colcov = \
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._dist._process_parameters(mean, rowcov, colcov)
<br>@@ -1185,7 +1192,8 @@ class matrix_normal_frozen(multi_rv_frozen):
<br>&nbspfor name in ['logpdf', 'pdf', 'rvs']:
<br>&nbsp &nbsp &nbsp &nbsp &nbspmethod = matrix_normal_gen.__dict__[name]
<br>&nbsp &nbsp &nbsp &nbsp &nbspmethod_frozen = matrix_normal_frozen.__dict__[name]
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspmethod_frozen.__doc__ = doccer.docformat(method.__doc__, matnorm_docdict_noparams)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspmethod_frozen.__doc__ = doccer.docformat(method.__doc__,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmatnorm_docdict_noparams)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspmethod.__doc__ = doccer.docformat(method.__doc__, matnorm_docdict_params)
<br>&nbsp
<br>&nbsp_dirichlet_doc_default_callparams = """\
<br>@@ -1208,13 +1216,14 @@ dirichlet_docdict_noparams = {
<br>&nbsp &nbsp &nbsp &nbsp &nbsp'_doc_random_state': _doc_random_state
<br>&nbsp}
<br>&nbsp
<br><span style="color:green">+</span>
<br>&nbspdef _dirichlet_check_parameters(alpha):
<br>&nbsp &nbsp &nbsp &nbsp &nbspalpha = np.asarray(alpha)
<br>&nbsp &nbsp &nbsp &nbsp &nbspif np.min(alpha) <= 0:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("All parameters must be greater than 0")
<br>&nbsp &nbsp &nbsp &nbsp &nbspelif alpha.ndim != 1:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("Parameter vector 'a' must be one dimensional, "
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"but a.shape = %s." % (alpha.shape, ))</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"but a.shape = %s." % (alpha.shape, ))</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspreturn alpha
<br>&nbsp
<br>&nbsp
<br>@@ -1237,26 +1246,38 @@ def _dirichlet_check_input(alpha, x):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("The input must be one dimensional or a two "
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"dimensional matrix containing the entries.")
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspif np.min(x) <= 0:</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("Each entry in 'x' must be greater than zero.")</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspif np.min(x) < 0:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("Each entry in 'x' must be greater than or equal "</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"to zero.")</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspif np.max(x) > 1:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("Each entry in 'x' must be smaller or equal one.")
<br>&nbsp
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp# Check x_i > 0 or alpha_i > 1</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspxeq0 = (x == 0)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspalphalt1 = (alpha < 1)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspif x.shape != alpha.shape:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspalphalt1 = np.repeat(alphalt1, x.shape[-1], axis=-1).reshape(x.shape)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspchk = np.logical_and(xeq0, alphalt1)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspif np.sum(chk):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("Each entry in 'x' must be greater than zero if its "</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"alpha is less than one.")</span>
<br><span style="color:green">+</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspif (np.abs(np.sum(x, 0) - 1.0) > 10e-10).any():
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("The input vector 'x' must lie within the normal "
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"simplex. but np.sum(x, 0) = %s." % np.sum(x, 0))</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"simplex. but np.sum(x, 0) = %s." % np.sum(x, 0))</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspreturn x
<br>&nbsp
<br>&nbsp
<br>&nbspdef _lnB(alpha):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspr"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspInternal helper function to compute the log of the useful quotient</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspr"""Internal helper function to compute the log of the useful quotient.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp.. math::
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspB(\alpha) = \frac{\prod_{i=1}{K}\Gamma(\alpha_i)}{\Gamma\left(\sum_{i=1}^{K}\alpha_i\right)}</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspB(\alpha) = \frac{\prod_{i=1}{K}\Gamma(\alpha_i)}</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp{\Gamma\left(\sum_{i=1}^{K} \alpha_i \right)}</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -1272,10 +1293,9 @@ def _lnB(alpha):
<br>&nbsp
<br>&nbsp
<br>&nbspclass dirichlet_gen(multi_rv_generic):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspr"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspA Dirichlet random variable.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspr"""A Dirichlet random variable.</span>
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspThe `alpha` keyword specifies the concentration parameters of the</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspThe ``alpha`` keyword specifies the concentration parameters of the</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspdistribution.
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp.. versionadded:: 0.15.0
<br>@@ -1316,8 +1336,11 @@ class dirichlet_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbspsupport on the simplex defined by
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp.. math::
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp\sum_{i=1}^{K} x_i \le 1</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp\sum_{i=1}^{K} x_i = 1</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspwhere :math:`0 < x_i < 1`.</span>
<br>&nbsp
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspIf the quantiles don't lie within the simplex, a ValueError is raised.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspThe probability density function for `dirichlet` is
<br>&nbsp
<br>@@ -1340,17 +1363,52 @@ class dirichlet_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbspThe array returned by the rvs function is transposed
<br>&nbsp &nbsp &nbsp &nbsp &nbspwith respect to the format expected by the pdf and logpdf.
<br>&nbsp
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspExamples</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp--------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> from scipy.stats import dirichlet</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspGenerate a dirichlet random variable</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> quantiles = np.array([0.2, 0.2, 0.6])  # specify quantiles</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> alpha = np.array([0.4, 5, 15])  # specify concentration parameters</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> dirichlet.pdf(quantiles, alpha)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp0.2843831684937255</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspThe same PDF but following a log scale</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> dirichlet.logpdf(quantiles, alpha)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp-1.2574327653159187</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspOnce we specify the dirichlet distribution</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspwe can then calculate quantities of interest</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> dirichlet.mean(alpha)  # get the mean of the distribution</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsparray([0.01960784, 0.24509804, 0.73529412])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> dirichlet.var(alpha) # get variance</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsparray([0.00089829, 0.00864603, 0.00909517])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> dirichlet.entropy(alpha)  # calculate the differential entropy</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp-4.3280162474082715</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspWe can also return random samples from the distribution</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> dirichlet.rvs(alpha, size=1, random_state=1)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsparray([[0.00766178, 0.24670518, 0.74563305]])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> dirichlet.rvs(alpha, size=2, random_state=2)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsparray([[0.01639427, 0.1292273 , 0.85437844],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[0.00156917, 0.19033695, 0.80809388]])</span>
<br><span style="color:green">+</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef __init__(self, seed=None):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsuper(dirichlet_gen, self).__init__(seed)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsuper().__init__(seed)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.__doc__ = doccer.docformat(self.__doc__, dirichlet_docdict_params)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef __call__(self, alpha, seed=None):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn dirichlet_frozen(alpha, seed=seed)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef _logpdf(self, x, alpha):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Log of the Dirichlet probability density function.</span>
<br><span style="color:green">+</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspx : ndarray
<br>@@ -1365,11 +1423,10 @@ class dirichlet_gen(multi_rv_generic):
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsplnB = _lnB(alpha)
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn - lnB + np.sum((np.log(x.T) * (alpha - 1)).T, 0)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn - lnB + np.sum((xlogy(alpha - 1, x.T)).T, 0)</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef logpdf(self, x, alpha):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspLog of the Dirichlet probability density function.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Log of the Dirichlet probability density function.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -1390,8 +1447,7 @@ class dirichlet_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn _squeeze_output(out)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef pdf(self, x, alpha):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThe Dirichlet probability density function.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""The Dirichlet probability density function.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -1412,8 +1468,7 @@ class dirichlet_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn _squeeze_output(out)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef mean(self, alpha):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspCompute the mean of the dirichlet distribution.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Compute the mean of the dirichlet distribution.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -1431,8 +1486,7 @@ class dirichlet_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn _squeeze_output(out)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef var(self, alpha):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspCompute the variance of the dirichlet distribution.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Compute the variance of the dirichlet distribution.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -1452,8 +1506,7 @@ class dirichlet_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn _squeeze_output(out)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef entropy(self, alpha):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspCompute the differential entropy of the dirichlet distribution.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Compute the differential entropy of the dirichlet distribution.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -1477,8 +1530,7 @@ class dirichlet_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn _squeeze_output(out)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef rvs(self, alpha, size=1, random_state=None):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspDraw random samples from a Dirichlet distribution.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Draw random samples from a Dirichlet distribution.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -1565,14 +1617,15 @@ wishart_docdict_noparams = {
<br>&nbsp
<br>&nbsp
<br>&nbspclass wishart_gen(multi_rv_generic):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspr"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspA Wishart random variable.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspr"""A Wishart random variable.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspThe `df` keyword specifies the degrees of freedom. The `scale` keyword
<br>&nbsp &nbsp &nbsp &nbsp &nbspspecifies the scale matrix, which must be symmetric and positive definite.
<br>&nbsp &nbsp &nbsp &nbsp &nbspIn this context, the scale matrix is often interpreted in terms of a
<br>&nbsp &nbsp &nbsp &nbsp &nbspmultivariate normal precision matrix (the inverse of the covariance
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspmatrix).</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspmatrix). These arguments must satisfy the relationship</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp``df > scale.ndim - 1``, but see notes on using the `rvs` method with</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp``df < scale.ndim``.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspMethods
<br>&nbsp &nbsp &nbsp &nbsp &nbsp-------
<br>@@ -1638,6 +1691,12 @@ class wishart_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbspdistribution :math:`W_1(\nu, 1)` collapses to the :math:`\chi^2(\nu)`
<br>&nbsp &nbsp &nbsp &nbsp &nbspdistribution.
<br>&nbsp
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspThe algorithm [2]_ implemented by the `rvs` method may</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspproduce numerically singular matrices with :math:`p - 1 < \nu < p`; the</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspuser may wish to check for this condition and generate replacement samples</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspas necessary.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp.. versionadded:: 0.16.0
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspReferences
<br>@@ -1664,15 +1723,13 @@ class wishart_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef __init__(self, seed=None):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsuper(wishart_gen, self).__init__(seed)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsuper().__init__(seed)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.__doc__ = doccer.docformat(self.__doc__, wishart_docdict_params)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef __call__(self, df=None, scale=None, seed=None):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspCreate a frozen Wishart distribution.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Create a frozen Wishart distribution.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspSee `wishart_frozen` for more information.
<br><span style="color:red">- </span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn wishart_frozen(df, scale, seed)
<br>&nbsp
<br>@@ -1682,7 +1739,7 @@ class wishart_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspscale = np.asarray(scale, dtype=float)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif scale.ndim == 0:
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspscale = scale[np.newaxis,np.newaxis]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspscale = scale[np.newaxis, np.newaxis]</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelif scale.ndim == 1:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspscale = np.diag(scale)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelif scale.ndim == 2 and not scale.shape[0] == scale.shape[1]:
<br>@@ -1699,9 +1756,9 @@ class wishart_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdf = dim
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelif not np.isscalar(df):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("Degrees of freedom must be a scalar.")
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelif df < dim:</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("Degrees of freedom cannot be less than dimension"</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp" of scale matrix, but df = %d" % df)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelif df <= dim - 1:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("Degrees of freedom must be greater than the "</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"dimension of scale matrix minus 1.")</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn dim, df, scale
<br>&nbsp
<br>@@ -1757,7 +1814,8 @@ class wishart_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn n, shape
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef _logpdf(self, x, dim, df, scale, log_det_scale, C):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Log of the Wishart probability density function.</span>
<br><span style="color:green">+</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspx : ndarray
<br>@@ -1786,13 +1844,13 @@ class wishart_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# gives us a 1-dim vector of determinants
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# Retrieve tr(scale^{-1} x)
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsplog_det_x = np.zeros(x.shape[-1])</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspscale_inv_x = np.zeros(x.shape)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsptr_scale_inv_x = np.zeros(x.shape[-1])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsplog_det_x = np.empty(x.shape[-1])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspscale_inv_x = np.empty(x.shape)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsptr_scale_inv_x = np.empty(x.shape[-1])</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspfor i in range(x.shape[-1]):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp_, log_det_x[i] = self._cholesky_logdet(x[:,:,i])</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspscale_inv_x[:,:,i] = scipy.linalg.cho_solve((C, True), x[:,:,i])</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsptr_scale_inv_x[i] = scale_inv_x[:,:,i].trace()</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp_, log_det_x[i] = self._cholesky_logdet(x[:, :, i])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspscale_inv_x[:, :, i] = scipy.linalg.cho_solve((C, True), x[:, :, i])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsptr_scale_inv_x[i] = scale_inv_x[:, :, i].trace()</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# Log PDF
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspout = ((0.5 * (df - dim - 1) * log_det_x - 0.5 * tr_scale_inv_x) -
<br>@@ -1802,8 +1860,7 @@ class wishart_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn out
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef logpdf(self, x, df, scale):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspLog of the Wishart probability density function.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Log of the Wishart probability density function.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -1832,8 +1889,7 @@ class wishart_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn _squeeze_output(out)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef pdf(self, x, df, scale):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspWishart probability density function.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Wishart probability density function.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -1855,7 +1911,8 @@ class wishart_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn np.exp(self.logpdf(x, df, scale))
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef _mean(self, dim, df, scale):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Mean of the Wishart distribution.</span>
<br><span style="color:green">+</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdim : int
<br>@@ -1871,8 +1928,7 @@ class wishart_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn df * scale
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef mean(self, df, scale):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspMean of the Wishart distribution</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Mean of the Wishart distribution.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -1888,7 +1944,8 @@ class wishart_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn _squeeze_output(out)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef _mode(self, dim, df, scale):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Mode of the Wishart distribution.</span>
<br><span style="color:green">+</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdim : int
<br>@@ -1908,8 +1965,7 @@ class wishart_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn out
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef mode(self, df, scale):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspMode of the Wishart distribution</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Mode of the Wishart distribution</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspOnly valid if the degrees of freedom are greater than the dimension of
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspthe scale matrix.
<br>@@ -1928,7 +1984,8 @@ class wishart_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn _squeeze_output(out) if out is not None else out
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef _var(self, dim, df, scale):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Variance of the Wishart distribution.</span>
<br><span style="color:green">+</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdim : int
<br>@@ -1948,8 +2005,7 @@ class wishart_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn var
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef var(self, df, scale):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspVariance of the Wishart distribution</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Variance of the Wishart distribution.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -1976,8 +2032,15 @@ class wishart_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspDimension of the scale matrix
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdf : int
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspDegrees of freedom
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprandom_state : np.random.RandomState instance</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspRandomState used for drawing the random variates.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprandom_state : {None, int, `numpy.random.Generator`,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp`numpy.random.RandomState`}, optional</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf `seed` is None (or `np.random`), the `numpy.random.RandomState`</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsingleton is used.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf `seed` is an int, a new ``RandomState`` instance is used,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspseeded with `seed`.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf `seed` is already a ``Generator`` or ``RandomState`` instance</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspthen that instance is used.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspNotes
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp-----
<br>@@ -1991,14 +2054,15 @@ class wishart_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsize=n*n_tril).reshape(shape+(n_tril,))
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# Random chi-square variates for diagonal elements
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspvariances = np.r_[[random_state.chisquare(df-(i+1)+1, size=n)**0.5</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspfor i in range(dim)]].reshape((dim,) + shape[::-1]).T</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspvariances = (np.r_[[random_state.chisquare(df-(i+1)+1, size=n)**0.5</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspfor i in range(dim)]].reshape((dim,) +</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspshape[::-1]).T)</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# Create the A matri(ces) - lower triangular
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspA = np.zeros(shape + (dim, dim))
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# Input the covariances
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsize_idx = tuple([slice(None,None,None)]*len(shape))</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsize_idx = tuple([slice(None, None, None)]*len(shape))</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsptril_idx = np.tril_indices(dim, k=-1)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspA[size_idx + tril_idx] = covariances
<br>&nbsp
<br>@@ -2009,7 +2073,8 @@ class wishart_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn A
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef _rvs(self, n, shape, dim, df, C, random_state):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Draw random samples from a Wishart distribution.</span>
<br><span style="color:green">+</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspn : integer
<br>@@ -2020,8 +2085,6 @@ class wishart_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspDimension of the scale matrix
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdf : int
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspDegrees of freedom
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspscale : ndarray</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspScale matrix</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspC : ndarray
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspCholesky factorization of the scale matrix, lower triangular.
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp%(_doc_random_state)s
<br>@@ -2055,8 +2118,7 @@ class wishart_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn A
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef rvs(self, df, scale, size=1, random_state=None):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspDraw random samples from a Wishart distribution.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Draw random samples from a Wishart distribution.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -2087,7 +2149,8 @@ class wishart_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn _squeeze_output(out)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef _entropy(self, dim, df, log_det_scale):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Compute the differential entropy of the Wishart.</span>
<br><span style="color:green">+</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdim : int
<br>@@ -2114,8 +2177,7 @@ class wishart_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef entropy(self, df, scale):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspCompute the differential entropy of the Wishart.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Compute the differential entropy of the Wishart.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -2136,8 +2198,7 @@ class wishart_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn self._entropy(dim, df, log_det_scale)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef _cholesky_logdet(self, scale):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspCompute Cholesky decomposition and determine (log(det(scale)).</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Compute Cholesky decomposition and determine (log(det(scale)).</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -2160,12 +2221,13 @@ class wishart_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspc_decomp = scipy.linalg.cholesky(scale, lower=True)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsplogdet = 2 * np.sum(np.log(c_decomp.diagonal()))
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn c_decomp, logdet
<br><span style="color:green">+</span>
<br><span style="color:green">+</span>
<br>&nbspwishart = wishart_gen()
<br>&nbsp
<br>&nbsp
<br>&nbspclass wishart_frozen(multi_rv_frozen):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspCreate a frozen Wishart distribution.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp"""Create a frozen Wishart distribution.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -2173,12 +2235,15 @@ class wishart_frozen(multi_rv_frozen):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspDegrees of freedom of the distribution
<br>&nbsp &nbsp &nbsp &nbsp &nbspscale : array_like
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspScale matrix of the distribution
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspseed : None or int or np.random.RandomState instance, optional</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThis parameter defines the RandomState object to use for drawing</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprandom variates.</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf None (or np.random), the global np.random state is used.</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf integer, it is used to seed the local RandomState instance</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspDefault is None.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspseed : {None, int, `numpy.random.Generator`,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp`numpy.random.RandomState`}, optional</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf `seed` is None (or `np.random`), the `numpy.random.RandomState`</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsingleton is used.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf `seed` is an int, a new ``RandomState`` instance is used,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspseeded with `seed`.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf `seed` is already a ``Generator`` or ``RandomState`` instance then</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspthat instance is used.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef __init__(self, df, scale, seed=None):
<br>@@ -2218,6 +2283,7 @@ class wishart_frozen(multi_rv_frozen):
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef entropy(self):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn self._dist._entropy(self.dim, self.df, self.log_det_scale)
<br>&nbsp
<br><span style="color:green">+</span>
<br>&nbsp# Set frozen generator docstrings from corresponding docstrings in
<br>&nbsp# Wishart and fill in default strings in class docstrings
<br>&nbspfor name in ['logpdf', 'pdf', 'mean', 'mode', 'var', 'rvs', 'entropy']:
<br>@@ -2228,9 +2294,6 @@ for name in ['logpdf', 'pdf', 'mean', 'mode', 'var', 'rvs', 'entropy']:
<br>&nbsp &nbsp &nbsp &nbsp &nbspmethod.__doc__ = doccer.docformat(method.__doc__, wishart_docdict_params)
<br>&nbsp
<br>&nbsp
<br><span style="color:red">- from numpy import asarray_chkfinite, asarray</span>
<br><span style="color:red">- from scipy.linalg.misc import LinAlgError</span>
<br><span style="color:red">- from scipy.linalg.lapack import get_lapack_funcs</span>
<br>&nbspdef _cho_inv_batch(a, check_finite=True):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp &nbsp &nbsp &nbsp &nbspInvert the matrices a_i, using a Cholesky factorization of A, where
<br>@@ -2254,7 +2317,7 @@ def _cho_inv_batch(a, check_finite=True):
<br>&nbsp &nbsp &nbsp &nbsp &nbspx : array
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspArray of inverses of the matrices ``a_i``.
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspSee also</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspSee Also</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp--------
<br>&nbsp &nbsp &nbsp &nbsp &nbspscipy.linalg.cholesky : Cholesky factorization of a matrix
<br>&nbsp
<br>@@ -2266,10 +2329,9 @@ def _cho_inv_batch(a, check_finite=True):
<br>&nbsp &nbsp &nbsp &nbsp &nbspif len(a1.shape) < 2 or a1.shape[-2] != a1.shape[-1]:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError('expected square matrix in last two dimensions')
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsppotrf, potri = get_lapack_funcs(('potrf','potri'), (a1,))</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsppotrf, potri = get_lapack_funcs(('potrf', 'potri'), (a1,))</span>
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsptril_idx = np.tril_indices(a.shape[-2], k=-1)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsptriu_idx = np.triu_indices(a.shape[-2], k=1)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsptriu_rows, triu_cols = np.triu_indices(a.shape[-2], k=1)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspfor index in np.ndindex(a1.shape[:-2]):
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# Cholesky decomposition
<br>@@ -2290,14 +2352,13 @@ def _cho_inv_batch(a, check_finite=True):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp' potrf' % -info)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# Make symmetric (dpotri only fills in the lower triangle)
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspa1[index][triu_idx] = a1[index][tril_idx]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspa1[index][triu_rows, triu_cols] = a1[index][triu_cols, triu_rows]</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspreturn a1
<br>&nbsp
<br>&nbsp
<br>&nbspclass invwishart_gen(wishart_gen):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspr"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspAn inverse Wishart random variable.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspr"""An inverse Wishart random variable.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspThe `df` keyword specifies the degrees of freedom. The `scale` keyword
<br>&nbsp &nbsp &nbsp &nbsp &nbspspecifies the scale matrix, which must be symmetric and positive definite.
<br>@@ -2373,8 +2434,9 @@ class invwishart_gen(wishart_gen):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>&nbsp &nbsp &nbsp &nbsp &nbsp.. [1] M.L. Eaton, "Multivariate Statistics: A Vector Space Approach",
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspWiley, 1983.
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp.. [2] M.C. Jones, "Generating Inverse Wishart Matrices", Communications in</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspStatistics - Simulation and Computation, vol. 14.2, pp.511-514, 1985.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp.. [2] M.C. Jones, "Generating Inverse Wishart Matrices", Communications</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspin Statistics - Simulation and Computation, vol. 14.2, pp.511-514,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp1985.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspExamples
<br>&nbsp &nbsp &nbsp &nbsp &nbsp--------
<br>@@ -2395,12 +2457,11 @@ class invwishart_gen(wishart_gen):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef __init__(self, seed=None):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsuper(invwishart_gen, self).__init__(seed)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsuper().__init__(seed)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.__doc__ = doccer.docformat(self.__doc__, wishart_docdict_params)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef __call__(self, df=None, scale=None, seed=None):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspCreate a frozen inverse Wishart distribution.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Create a frozen inverse Wishart distribution.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspSee `invwishart_frozen` for more information.
<br>&nbsp
<br>@@ -2408,7 +2469,8 @@ class invwishart_gen(wishart_gen):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn invwishart_frozen(df, scale, seed)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef _logpdf(self, x, dim, df, scale, log_det_scale):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Log of the inverse Wishart probability density function.</span>
<br><span style="color:green">+</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspx : ndarray
<br>@@ -2429,21 +2491,19 @@ class invwishart_gen(wishart_gen):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcalled directly; use 'logpdf' instead.
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsplog_det_x = np.zeros(x.shape[-1])</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp#scale_x_inv = np.zeros(x.shape)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsplog_det_x = np.empty(x.shape[-1])</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspx_inv = np.copy(x).T
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif dim > 1:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp_cho_inv_batch(x_inv)  # works in-place
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelse:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspx_inv = 1./x_inv
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsptr_scale_x_inv = np.zeros(x.shape[-1])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsptr_scale_x_inv = np.empty(x.shape[-1])</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspfor i in range(x.shape[-1]):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspC, lower = scipy.linalg.cho_factor(x[:,:,i], lower=True)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspC, lower = scipy.linalg.cho_factor(x[:, :, i], lower=True)</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsplog_det_x[i] = 2 * np.sum(np.log(C.diagonal()))
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp#scale_x_inv[:,:,i] = scipy.linalg.cho_solve((C, True), scale).T</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsptr_scale_x_inv[i] = np.dot(scale, x_inv[i]).trace()
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# Log PDF
<br>@@ -2454,8 +2514,7 @@ class invwishart_gen(wishart_gen):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn out
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef logpdf(self, x, df, scale):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspLog of the inverse Wishart probability density function.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Log of the inverse Wishart probability density function.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -2481,15 +2540,13 @@ class invwishart_gen(wishart_gen):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn _squeeze_output(out)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef pdf(self, x, df, scale):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspInverse Wishart probability density function.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Inverse Wishart probability density function.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspx : array_like
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspQuantiles, with the last axis of `x` denoting the components.
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspEach quantile must be a symmetric positive definite matrix.
<br><span style="color:red">- </span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp%(_doc_default_callparams)s
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspReturns
<br>@@ -2505,7 +2562,8 @@ class invwishart_gen(wishart_gen):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn np.exp(self.logpdf(x, df, scale))
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef _mean(self, dim, df, scale):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Mean of the inverse Wishart distribution.</span>
<br><span style="color:green">+</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdim : int
<br>@@ -2525,8 +2583,7 @@ class invwishart_gen(wishart_gen):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn out
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef mean(self, df, scale):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspMean of the inverse Wishart distribution</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Mean of the inverse Wishart distribution.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspOnly valid if the degrees of freedom are greater than the dimension of
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspthe scale matrix plus one.
<br>@@ -2546,7 +2603,8 @@ class invwishart_gen(wishart_gen):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn _squeeze_output(out) if out is not None else out
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef _mode(self, dim, df, scale):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Mode of the inverse Wishart distribution.</span>
<br><span style="color:green">+</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdim : int
<br>@@ -2562,8 +2620,7 @@ class invwishart_gen(wishart_gen):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn scale / (df + dim + 1)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef mode(self, df, scale):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspMode of the inverse Wishart distribution</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Mode of the inverse Wishart distribution.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -2580,7 +2637,8 @@ class invwishart_gen(wishart_gen):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn _squeeze_output(out)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef _var(self, dim, df, scale):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Variance of the inverse Wishart distribution.</span>
<br><span style="color:green">+</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdim : int
<br>@@ -2603,8 +2661,7 @@ class invwishart_gen(wishart_gen):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn var
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef var(self, df, scale):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspVariance of the inverse Wishart distribution</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Variance of the inverse Wishart distribution.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspOnly valid if the degrees of freedom are greater than the dimension of
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspthe scale matrix plus three.
<br>@@ -2623,7 +2680,8 @@ class invwishart_gen(wishart_gen):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn _squeeze_output(out) if out is not None else out
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef _rvs(self, n, shape, dim, df, C, random_state):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Draw random samples from an inverse Wishart distribution.</span>
<br><span style="color:green">+</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspn : integer
<br>@@ -2646,8 +2704,7 @@ class invwishart_gen(wishart_gen):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprandom_state = self._get_random_state(random_state)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# Get random draws A such that A ~ W(df, I)
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspA = super(invwishart_gen, self)._standard_rvs(n, shape, dim,</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdf, random_state)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspA = super()._standard_rvs(n, shape, dim, df, random_state)</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# Calculate SA = (CA)'^{-1} (CA)^{-1} ~ iW(df, scale)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspeye = np.eye(dim)
<br>@@ -2672,8 +2729,7 @@ class invwishart_gen(wishart_gen):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn A
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef rvs(self, df, scale, size=1, random_state=None):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspDraw random samples from an inverse Wishart distribution.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Draw random samples from an inverse Wishart distribution.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -2711,12 +2767,13 @@ class invwishart_gen(wishart_gen):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# Need to find reference for inverse Wishart entropy
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise AttributeError
<br>&nbsp
<br><span style="color:green">+</span>
<br>&nbspinvwishart = invwishart_gen()
<br>&nbsp
<br><span style="color:green">+</span>
<br>&nbspclass invwishart_frozen(multi_rv_frozen):
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef __init__(self, df, scale, seed=None):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspCreate a frozen inverse Wishart distribution.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Create a frozen inverse Wishart distribution.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -2724,12 +2781,12 @@ class invwishart_frozen(multi_rv_frozen):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspDegrees of freedom of the distribution
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspscale : array_like
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspScale matrix of the distribution
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspseed : None or int or np.random.RandomState instance, optional</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThis parameter defines the RandomState object to use for drawing</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprandom variates.</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf None (or np.random), the global np.random state is used.</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf integer, it is used to seed the local RandomState instance</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspDefault is None.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspseed : {None, int, `numpy.random.Generator`}, optional</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf `seed` is None the `numpy.random.Generator` singleton is used.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf `seed` is an int, a new ``Generator`` instance is used,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspseeded with `seed`.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf `seed` is already a ``Generator`` instance then that instance is</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspused.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._dist = invwishart_gen(seed)
<br>@@ -2781,6 +2838,7 @@ class invwishart_frozen(multi_rv_frozen):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# Need to find reference for inverse Wishart entropy
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise AttributeError
<br>&nbsp
<br><span style="color:green">+</span>
<br>&nbsp# Set frozen generator docstrings from corresponding docstrings in
<br>&nbsp# inverse Wishart and fill in default strings in class docstrings
<br>&nbspfor name in ['logpdf', 'pdf', 'mean', 'mode', 'var', 'rvs']:
<br>@@ -2821,9 +2879,9 @@ multinomial_docdict_noparams = {
<br>&nbsp &nbsp &nbsp &nbsp &nbsp'_doc_random_state': _doc_random_state
<br>&nbsp}
<br>&nbsp
<br><span style="color:green">+</span>
<br>&nbspclass multinomial_gen(multi_rv_generic):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspr"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspA multinomial random variable.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspr"""A multinomial random variable.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspMethods
<br>&nbsp &nbsp &nbsp &nbsp &nbsp-------
<br>@@ -2920,37 +2978,37 @@ class multinomial_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbspSee also
<br>&nbsp &nbsp &nbsp &nbsp &nbsp--------
<br>&nbsp &nbsp &nbsp &nbsp &nbspscipy.stats.binom : The binomial distribution.
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspnumpy.random.multinomial : Sampling from the multinomial distribution.</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspnumpy.random.Generator.multinomial : Sampling from the multinomial distribution.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspscipy.stats.multivariate_hypergeom :</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThe multivariate hypergeometric distribution.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp"""  # noqa: E501</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef __init__(self, seed=None):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsuper(multinomial_gen, self).__init__(seed)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsuper().__init__(seed)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.__doc__ = \
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdoccer.docformat(self.__doc__, multinomial_docdict_params)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef __call__(self, n, p, seed=None):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspCreate a frozen multinomial distribution.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Create a frozen multinomial distribution.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspSee `multinomial_frozen` for more information.
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn multinomial_frozen(n, p, seed)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef _process_parameters(self, n, p):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspReturn: n_, p_, npcond.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Returns: n_, p_, npcond.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspn_ and p_ are arrays of the correct shape; npcond is a boolean array
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspflagging values out of the domain.
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspp = np.array(p, dtype=np.float64, copy=True)
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspp[...,-1] = 1. - p[...,:-1].sum(axis=-1)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspp[..., -1] = 1. - p[..., :-1].sum(axis=-1)</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# true for bad p
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsppcond = np.any(p < 0, axis=-1)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsppcond |= np.any(p > 1, axis=-1)
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspn = np.array(n, dtype=np.int, copy=True)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspn = np.array(n, dtype=np.int_, copy=True)</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# true for bad n
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspncond = n <= 0
<br>@@ -2958,20 +3016,20 @@ class multinomial_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn n, p, ncond | pcond
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef _process_quantiles(self, x, n, p):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspReturn: x_, xcond.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Returns: x_, xcond.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspx_ is an int array; xcond is a boolean array flagging values out of the
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdomain.
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspxx = np.asarray(x, dtype=np.int)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspxx = np.asarray(x, dtype=np.int_)</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif xx.ndim == 0:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("x must be an array.")
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif xx.size != 0 and not xx.shape[-1] == p.shape[-1]:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("Size of each quantile should be size of p: "
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"received %d, but expected %d." % (xx.shape[-1], p.shape[-1]))</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"received %d, but expected %d." %</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp(xx.shape[-1], p.shape[-1]))</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# true for x out of the domain
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond = np.any(xx != x, axis=-1)
<br>@@ -2995,14 +3053,12 @@ class multinomial_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn gammaln(n+1) + np.sum(xlogy(x, p) - gammaln(x+1), axis=-1)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef logpmf(self, x, n, p):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspLog of the Multinomial probability mass function.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Log of the Multinomial probability mass function.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspx : array_like
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspQuantiles, with the last axis of `x` denoting the components.
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspEach quantile must be a symmetric positive definite matrix.</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp%(_doc_default_callparams)s
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspReturns
<br>@@ -3029,14 +3085,12 @@ class multinomial_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn self._checkresult(result, npcond_, np.NAN)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef pmf(self, x, n, p):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspMultinomial probability mass function.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Multinomial probability mass function.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspx : array_like
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspQuantiles, with the last axis of `x` denoting the components.
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspEach quantile must be a symmetric positive definite matrix.</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp%(_doc_default_callparams)s
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspReturns
<br>@@ -3051,8 +3105,7 @@ class multinomial_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn np.exp(self.logpmf(x, n, p))
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef mean(self, n, p):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspMean of the Multinomial distribution</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Mean of the Multinomial distribution.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -3068,8 +3121,7 @@ class multinomial_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn self._checkresult(result, npcond, np.NAN)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef cov(self, n, p):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspCovariance matrix of the multinomial distribution.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Covariance matrix of the multinomial distribution.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -3087,13 +3139,12 @@ class multinomial_gen(multi_rv_generic):
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# change the diagonal
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspfor i in range(p.shape[-1]):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspresult[...,i, i] += n*p[..., i]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspresult[..., i, i] += n*p[..., i]</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn self._checkresult(result, npcond, np.nan)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef entropy(self, n, p):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspr"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspCompute the entropy of the multinomial distribution.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspr"""Compute the entropy of the multinomial distribution.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThe entropy is computed using this expression:
<br>&nbsp
<br>@@ -3127,13 +3178,12 @@ class multinomial_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspx.shape += (1,)*new_axes_needed
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspterm2 = np.sum(binom.pmf(x, n, p)*gammaln(x+1),
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspaxis=(-1, -1-new_axes_needed))</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspaxis=(-1, -1-new_axes_needed))</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn self._checkresult(term1 + term2, npcond, np.nan)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef rvs(self, n, p, size=None, random_state=None):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspDraw random samples from a Multinomial distribution.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Draw random samples from a Multinomial distribution.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -3158,9 +3208,9 @@ class multinomial_gen(multi_rv_generic):
<br>&nbsp
<br>&nbspmultinomial = multinomial_gen()
<br>&nbsp
<br><span style="color:green">+</span>
<br>&nbspclass multinomial_frozen(multi_rv_frozen):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspr"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspCreate a frozen Multinomial distribution.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspr"""Create a frozen Multinomial distribution.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -3168,12 +3218,15 @@ class multinomial_frozen(multi_rv_frozen):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspnumber of trials
<br>&nbsp &nbsp &nbsp &nbsp &nbspp: array_like
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspprobability of a trial falling into each category; should sum to 1
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspseed : None or int or np.random.RandomState instance, optional</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThis parameter defines the RandomState object to use for drawing</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprandom variates.</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf None (or np.random), the global np.random state is used.</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf integer, it is used to seed the local RandomState instance</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspDefault is None.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspseed : {None, int, `numpy.random.Generator`,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp`numpy.random.RandomState`}, optional</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf `seed` is None (or `np.random`), the `numpy.random.RandomState`</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsingleton is used.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf `seed` is an int, a new ``RandomState`` instance is used,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspseeded with `seed`.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf `seed` is already a ``Generator`` or ``RandomState`` instance then</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspthat instance is used.</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef __init__(self, n, p, seed=None):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._dist = multinomial_gen(seed)
<br>@@ -3203,6 +3256,7 @@ class multinomial_frozen(multi_rv_frozen):
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef rvs(self, size=1, random_state=None):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn self._dist.rvs(self.n, self.p, size, random_state)
<br>&nbsp
<br><span style="color:green">+</span>
<br>&nbsp# Set frozen generator docstrings from corresponding docstrings in
<br>&nbsp# multinomial and fill in default strings in class docstrings
<br>&nbspfor name in ['logpmf', 'pmf', 'mean', 'cov', 'rvs']:
<br>@@ -3211,11 +3265,11 @@ for name in ['logpmf', 'pmf', 'mean', 'cov', 'rvs']:
<br>&nbsp &nbsp &nbsp &nbsp &nbspmethod_frozen.__doc__ = doccer.docformat(
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmethod.__doc__, multinomial_docdict_noparams)
<br>&nbsp &nbsp &nbsp &nbsp &nbspmethod.__doc__ = doccer.docformat(method.__doc__,
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmultinomial_docdict_params)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmultinomial_docdict_params)</span>
<br><span style="color:green">+</span>
<br>&nbsp
<br>&nbspclass special_ortho_group_gen(multi_rv_generic):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspr"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspA matrix-valued SO(N) random variable.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspr"""A matrix-valued SO(N) random variable.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspReturn a random rotation matrix, drawn from the Haar distribution
<br>&nbsp &nbsp &nbsp &nbsp &nbsp(the only uniform distribution on SO(n)).
<br>@@ -3233,7 +3287,7 @@ class special_ortho_group_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspDimension of matrices
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspNotes
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp----------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp-----</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspThis class is wrapping the random_rot code from the MDP Toolkit,
<br>&nbsp &nbsp &nbsp &nbsp &nbsphttps://github.com/mdp-toolkit/mdp-toolkit
<br>&nbsp
<br>@@ -3244,9 +3298,10 @@ class special_ortho_group_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbspmatrices with an application to condition estimators", SIAM Journal
<br>&nbsp &nbsp &nbsp &nbsp &nbspon Numerical Analysis, 17(3), pp. 403-409, 1980.
<br>&nbsp &nbsp &nbsp &nbsp &nbspFor more information see
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsphttp://en.wikipedia.org/wiki/Orthogonal_matrix#Randomization</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsphttps://en.wikipedia.org/wiki/Orthogonal_matrix#Randomization</span>
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspSee also the similar `ortho_group`.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspSee also the similar `ortho_group`. For a random rotation in three</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdimensions, see `scipy.spatial.transform.Rotation.random`.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspExamples
<br>&nbsp &nbsp &nbsp &nbsp &nbsp--------
<br>@@ -3265,26 +3320,25 @@ class special_ortho_group_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbspThis generates one random matrix from SO(3). It is orthogonal and
<br>&nbsp &nbsp &nbsp &nbsp &nbsphas a determinant of 1.
<br>&nbsp
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspSee Also</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp--------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsportho_group, scipy.spatial.transform.Rotation.random</span>
<br><span style="color:green">+</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef __init__(self, seed=None):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsuper(special_ortho_group_gen, self).__init__(seed)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsuper().__init__(seed)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.__doc__ = doccer.docformat(self.__doc__)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef __call__(self, dim=None, seed=None):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspCreate a frozen SO(N) distribution.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Create a frozen SO(N) distribution.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspSee `special_ortho_group_frozen` for more information.
<br><span style="color:red">- </span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn special_ortho_group_frozen(dim, seed=seed)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef _process_parameters(self, dim):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspDimension N must be specified; it cannot be inferred.</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- </span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Dimension N must be specified; it cannot be inferred."""</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif dim is None or not np.isscalar(dim) or dim <= 1 or dim != int(dim):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("""Dimension of rotation must be specified,
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspand must be a scalar greater than 1.""")
<br>@@ -3292,8 +3346,7 @@ class special_ortho_group_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn dim
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef rvs(self, dim, size=1, random_state=None):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspDraw random samples from SO(N).</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Draw random samples from SO(N).</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -3308,6 +3361,8 @@ class special_ortho_group_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspRandom size N-dimensional matrices, dimension (size, dim, dim)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprandom_state = self._get_random_state(random_state)</span>
<br><span style="color:green">+</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsize = int(size)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif size > 1:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn np.array([self.rvs(dim, size=1, random_state=random_state)
<br>@@ -3315,44 +3370,43 @@ class special_ortho_group_gen(multi_rv_generic):
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdim = self._process_parameters(dim)
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprandom_state = self._get_random_state(random_state)</span>
<br><span style="color:red">- </span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspH = np.eye(dim)
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspD = np.ones((dim,))</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspfor n in range(1, dim):</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspx = random_state.normal(size=(dim-n+1,))</span>
<br><span style="color:red">- </span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspD[n-1] = np.sign(x[0])</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspx[0] -= D[n-1]*np.sqrt((x*x).sum())</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspD = np.empty((dim,))</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspfor n in range(dim-1):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspx = random_state.normal(size=(dim-n,))</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspnorm2 = np.dot(x, x)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspx0 = x[0].item()</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspD[n] = np.sign(x[0]) if x[0] != 0 else 1</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspx[0] += D[n]*np.sqrt(norm2)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspx /= np.sqrt((norm2 - x0**2 + x[0]**2) / 2.)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# Householder transformation
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspHx = (np.eye(dim-n+1)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp- 2.*np.outer(x, x)/(x*x).sum())</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmat = np.eye(dim)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmat[n-1:, n-1:] = Hx</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspH = np.dot(H, mat)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# Fix the last sign such that the determinant is 1</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspD[-1] = (-1)**(1-(dim % 2))*D.prod()</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspH[:, n:] -= np.outer(np.dot(H[:, n:], x), x)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspD[-1] = (-1)**(dim-1)*D[:-1].prod()</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# Equivalent to np.dot(np.diag(D), H) but faster, apparently
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspH = (D*H.T).T
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn H
<br>&nbsp
<br><span style="color:green">+</span>
<br>&nbspspecial_ortho_group = special_ortho_group_gen()
<br>&nbsp
<br><span style="color:green">+</span>
<br>&nbspclass special_ortho_group_frozen(multi_rv_frozen):
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef __init__(self, dim=None, seed=None):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspCreate a frozen SO(N) distribution.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Create a frozen SO(N) distribution.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdim : scalar
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspDimension of matrices
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspseed : None or int or np.random.RandomState instance, optional</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThis parameter defines the RandomState object to use for drawing</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprandom variates.</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf None (or np.random), the global np.random state is used.</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf integer, it is used to seed the local RandomState instance</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspDefault is None.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspseed : {None, int, `numpy.random.Generator`,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp`numpy.random.RandomState`}, optional</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf `seed` is None (or `np.random`), the `numpy.random.RandomState`</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsingleton is used.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf `seed` is an int, a new ``RandomState`` instance is used,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspseeded with `seed`.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspIf `seed` is already a ``Generator`` or ``RandomState`` instance</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspthen that instance is used.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspExamples
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp--------
<br>@@ -3367,9 +3421,9 @@ class special_ortho_group_frozen(multi_rv_frozen):
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef rvs(self, size=1, random_state=None):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn self._dist.rvs(self.dim, size, random_state)
<br>&nbsp
<br><span style="color:green">+</span>
<br>&nbspclass ortho_group_gen(multi_rv_generic):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspr"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspA matrix-valued O(N) random variable.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspr"""A matrix-valued O(N) random variable.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspReturn a random orthogonal matrix, drawn from the O(N) Haar
<br>&nbsp &nbsp &nbsp &nbsp &nbspdistribution (the only uniform distribution on O(N)).
<br>@@ -3387,7 +3441,7 @@ class ortho_group_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspDimension of matrices
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspNotes
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp----------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp-----</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspThis class is closely related to `special_ortho_group`.
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspSome care is taken to avoid numerical error, as per the paper by Mezzadri.
<br>@@ -3417,14 +3471,11 @@ class ortho_group_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef __init__(self, seed=None):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsuper(ortho_group_gen, self).__init__(seed)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsuper().__init__(seed)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.__doc__ = doccer.docformat(self.__doc__)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef _process_parameters(self, dim):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspDimension N must be specified; it cannot be inferred.</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- </span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Dimension N must be specified; it cannot be inferred."""</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif dim is None or not np.isscalar(dim) or dim <= 1 or dim != int(dim):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("Dimension of rotation must be specified,"
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"and must be a scalar greater than 1.")
<br>@@ -3432,8 +3483,7 @@ class ortho_group_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn dim
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef rvs(self, dim, size=1, random_state=None):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspDraw random samples from O(N).</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Draw random samples from O(N).</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -3448,6 +3498,8 @@ class ortho_group_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspRandom size N-dimensional matrices, dimension (size, dim, dim)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprandom_state = self._get_random_state(random_state)</span>
<br><span style="color:green">+</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsize = int(size)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif size > 1:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn np.array([self.rvs(dim, size=1, random_state=random_state)
<br>@@ -3455,27 +3507,25 @@ class ortho_group_gen(multi_rv_generic):
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdim = self._process_parameters(dim)
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprandom_state = self._get_random_state(random_state)</span>
<br><span style="color:red">- </span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspH = np.eye(dim)
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspfor n in range(1, dim):</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspx = random_state.normal(size=(dim-n+1,))</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspfor n in range(dim):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspx = random_state.normal(size=(dim-n,))</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspnorm2 = np.dot(x, x)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspx0 = x[0].item()</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# random sign, 50/50, but chosen carefully to avoid roundoff error
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspD = np.sign(x[0])</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspx[0] += D*np.sqrt((x*x).sum())</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspD = np.sign(x[0]) if x[0] != 0 else 1</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspx[0] += D * np.sqrt(norm2)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspx /= np.sqrt((norm2 - x0**2 + x[0]**2) / 2.)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# Householder transformation
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspHx = -D*(np.eye(dim-n+1)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp- 2.*np.outer(x, x)/(x*x).sum())</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmat = np.eye(dim)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmat[n-1:, n-1:] = Hx</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspH = np.dot(H, mat)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspH[:, n:] = -D * (H[:, n:] - np.outer(np.dot(H[:, n:], x), x))</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn H
<br>&nbsp
<br><span style="color:green">+</span>
<br>&nbsportho_group = ortho_group_gen()
<br>&nbsp
<br><span style="color:green">+</span>
<br>&nbspclass random_correlation_gen(multi_rv_generic):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspr"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspA random correlation matrix.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspr"""A random correlation matrix.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspReturn a random correlation matrix, given a vector of eigenvalues.
<br>&nbsp
<br>@@ -3493,7 +3543,7 @@ class random_correlation_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspEigenvalues of correlation matrix.
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspNotes
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp----------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp-----</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspGenerates a random correlation matrix following a numerically stable
<br>&nbsp &nbsp &nbsp &nbsp &nbspalgorithm spelled out by Davies & Higham. This algorithm uses a single O(N)
<br>@@ -3511,14 +3561,13 @@ class random_correlation_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbspExamples
<br>&nbsp &nbsp &nbsp &nbsp &nbsp--------
<br>&nbsp &nbsp &nbsp &nbsp &nbsp>>> from scipy.stats import random_correlation
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp>>> np.random.seed(514)</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp>>> x = random_correlation.rvs((.5, .8, 1.2, 1.5))</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> rng = np.random.default_rng()</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> x = random_correlation.rvs((.5, .8, 1.2, 1.5), random_state=rng)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp>>> x
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsparray([[ 1.        , -0.20387311,  0.18366501, -0.04953711],</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[-0.20387311,  1.        , -0.24351129,  0.06703474],</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[ 0.18366501, -0.24351129,  1.        ,  0.38530195],</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[-0.04953711,  0.06703474,  0.38530195,  1.        ]])</span>
<br><span style="color:red">- </span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsparray([[ 1.        , -0.07198934, -0.20411041, -0.24385796],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[-0.07198934,  1.        ,  0.12968613, -0.29471382],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[-0.20411041,  0.12968613,  1.        ,  0.2828693 ],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[-0.24385796, -0.29471382,  0.2828693 ,  1.        ]])</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp>>> import scipy.linalg
<br>&nbsp &nbsp &nbsp &nbsp &nbsp>>> e, v = scipy.linalg.eigh(x)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp>>> e
<br>@@ -3527,7 +3576,7 @@ class random_correlation_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef __init__(self, seed=None):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsuper(random_correlation_gen, self).__init__(seed)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsuper().__init__(seed)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.__doc__ = doccer.docformat(self.__doc__)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef _process_parameters(self, eigs, tol):
<br>@@ -3535,7 +3584,8 @@ class random_correlation_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdim = eigs.size
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif eigs.ndim != 1 or eigs.shape[0] != dim or dim <= 1:
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("Array 'eigs' must be a vector of length greater than 1.")</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("Array 'eigs' must be a vector of length "</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"greater than 1.")</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif np.fabs(np.sum(eigs) - dim) > tol:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("Sum of eigenvalues must equal dimensionality.")
<br>@@ -3547,12 +3597,12 @@ class random_correlation_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn dim, eigs
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef _givens_to_1(self, aii, ajj, aij):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Computes a 2x2 Givens matrix to put 1's on the diagonal for the input matrix.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Computes a 2x2 Givens matrix to put 1's on the diagonal.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThe input matrix is a 2x2 symmetric matrix M = [ aii aij ; aij ajj ].
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThe output matrix g is a 2x2 anti-symmetric matrix of the form [ c s ; -s c ];</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspthe elements c and s are returned.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThe output matrix g is a 2x2 anti-symmetric matrix of the form</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[ c s ; -s c ];  the elements c and s are returned.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspApplying the output matrix to the input matrix (as b=g.T M g)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspresults in a matrix with bii=1, provided tr(M) - det(M) >= 1
<br>@@ -3586,12 +3636,13 @@ class random_correlation_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdimensionality. Note: modifies input matrix
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# Check requirements for in-place Givens
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif not (m.flags.c_contiguous and m.dtype == np.float64 and m.shape[0] == m.shape[1]):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif not (m.flags.c_contiguous and m.dtype == np.float64 and</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspm.shape[0] == m.shape[1]):</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError()
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspd = m.shape[0]
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspfor i in range(d-1):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif m[i,i] == 1:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif m[i, i] == 1:</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcontinue
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelif m[i, i] > 1:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspfor j in range(i+1, d):
<br>@@ -3602,7 +3653,7 @@ class random_correlation_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif m[j, j] > 1:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspbreak
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspc, s = self._givens_to_1(m[i,i], m[j,j], m[i,j])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspc, s = self._givens_to_1(m[i, i], m[j, j], m[i, j])</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# Use BLAS to apply Givens rotations in-place. Equivalent to:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# g = np.eye(d)
<br>@@ -3620,8 +3671,7 @@ class random_correlation_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn m
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef rvs(self, eigs, random_state=None, tol=1e-13, diag_tol=1e-7):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspDraw random correlation matrices</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Draw random correlation matrices.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -3660,11 +3710,12 @@ class random_correlation_gen(multi_rv_generic):
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn m
<br>&nbsp
<br><span style="color:green">+</span>
<br>&nbsprandom_correlation = random_correlation_gen()
<br>&nbsp
<br><span style="color:green">+</span>
<br>&nbspclass unitary_group_gen(multi_rv_generic):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspr"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspA matrix-valued U(N) random variable.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspr"""A matrix-valued U(N) random variable.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspReturn a random unitary matrix.
<br>&nbsp
<br>@@ -3681,13 +3732,13 @@ class unitary_group_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspDimension of matrices
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspNotes
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp----------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp-----</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbspThis class is similar to `ortho_group`.
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspReferences
<br>&nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>&nbsp &nbsp &nbsp &nbsp &nbsp.. [1] F. Mezzadri, "How to generate random matrices from the classical
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcompact groups", arXiv:math-ph/0609050v2.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcompact groups", :arXiv:`math-ph/0609050v2`.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspExamples
<br>&nbsp &nbsp &nbsp &nbsp &nbsp--------
<br>@@ -3699,19 +3750,17 @@ class unitary_group_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[  1.13231364e-17,   1.00000000e+00,  -1.46845020e-16],
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[ -2.86852790e-16,  -1.46845020e-16,   1.00000000e+00]])
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbspThis generates one random matrix from U(3). The dot product confirms that it is unitary up to machine precision.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspThis generates one random matrix from U(3). The dot product confirms that</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspit is unitary up to machine precision.</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp"""
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef __init__(self, seed=None):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsuper(unitary_group_gen, self).__init__(seed)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsuper().__init__(seed)</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.__doc__ = doccer.docformat(self.__doc__)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef _process_parameters(self, dim):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspDimension N must be specified; it cannot be inferred.</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- </span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Dimension N must be specified; it cannot be inferred."""</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif dim is None or not np.isscalar(dim) or dim <= 1 or dim != int(dim):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("Dimension of rotation must be specified,"
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"and must be a scalar greater than 1.")
<br>@@ -3719,8 +3768,7 @@ class unitary_group_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn dim
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbspdef rvs(self, dim, size=1, random_state=None):
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspDraw random samples from U(N).</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Draw random samples from U(N).</span>
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------
<br>@@ -3735,6 +3783,8 @@ class unitary_group_gen(multi_rv_generic):
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspRandom size N-dimensional matrices, dimension (size, dim, dim)
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprandom_state = self._get_random_state(random_state)</span>
<br><span style="color:green">+</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsize = int(size)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif size > 1:
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn np.array([self.rvs(dim, size=1, random_state=random_state)
<br>@@ -3742,13 +3792,915 @@ class unitary_group_gen(multi_rv_generic):
<br>&nbsp
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdim = self._process_parameters(dim)
<br>&nbsp
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprandom_state = self._get_random_state(random_state)</span>
<br><span style="color:red">- </span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspz = 1/math.sqrt(2)*(random_state.normal(size=(dim,dim)) +</span>
<br><span style="color:red">- &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp1j*random_state.normal(size=(dim,dim)))</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspz = 1/math.sqrt(2)*(random_state.normal(size=(dim, dim)) +</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp1j*random_state.normal(size=(dim, dim)))</span>
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspq, r = scipy.linalg.qr(z)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspd = r.diagonal()
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspq *= d/abs(d)
<br>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn q
<br>&nbsp
<br><span style="color:green">+</span>
<br>&nbspunitary_group = unitary_group_gen()
<br><span style="color:green">+</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+_mvt_doc_default_callparams = \</span>
<br><span style="color:green">+"""</span>
<br><span style="color:green">+loc : array_like, optional</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspLocation of the distribution. (default ``0``)</span>
<br><span style="color:green">+shape : array_like, optional</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspPositive semidefinite matrix of the distribution. (default ``1``)</span>
<br><span style="color:green">+df : float, optional</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspDegrees of freedom of the distribution; must be greater than zero.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspIf ``np.inf`` then results are multivariate normal. The default is ``1``.</span>
<br><span style="color:green">+allow_singular : bool, optional</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspWhether to allow a singular matrix. (default ``False``)</span>
<br><span style="color:green">+"""</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+_mvt_doc_callparams_note = \</span>
<br><span style="color:green">+"""Setting the parameter `loc` to ``None`` is equivalent to having `loc`</span>
<br><span style="color:green">+be the zero-vector. The parameter `shape` can be a scalar, in which case</span>
<br><span style="color:green">+the shape matrix is the identity times that value, a vector of</span>
<br><span style="color:green">+diagonal entries for the shape matrix, or a two-dimensional array_like.</span>
<br><span style="color:green">+"""</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+_mvt_doc_frozen_callparams_note = \</span>
<br><span style="color:green">+"""See class definition for a detailed description of parameters."""</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+mvt_docdict_params = {</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp'_mvt_doc_default_callparams': _mvt_doc_default_callparams,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp'_mvt_doc_callparams_note': _mvt_doc_callparams_note,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp'_doc_random_state': _doc_random_state</span>
<br><span style="color:green">+}</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+mvt_docdict_noparams = {</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp'_mvt_doc_default_callparams': "",</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp'_mvt_doc_callparams_note': _mvt_doc_frozen_callparams_note,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp'_doc_random_state': _doc_random_state</span>
<br><span style="color:green">+}</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+class multivariate_t_gen(multi_rv_generic):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspr"""A multivariate t-distributed random variable.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspThe `loc` parameter specifies the location. The `shape` parameter specifies</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspthe positive semidefinite shape matrix. The `df` parameter specifies the</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdegrees of freedom.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspIn addition to calling the methods below, the object itself may be called</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspas a function to fix the location, shape matrix, and degrees of freedom</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspparameters, returning a "frozen" multivariate t-distribution random.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspMethods</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp-------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp``pdf(x, loc=None, shape=1, df=1, allow_singular=False)``</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspProbability density function.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp``logpdf(x, loc=None, shape=1, df=1, allow_singular=False)``</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspLog of the probability density function.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp``rvs(loc=None, shape=1, df=1, size=1, random_state=None)``</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspDraw random samples from a multivariate t-distribution.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspParameters</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp----------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspx : array_like</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspQuantiles, with the last axis of `x` denoting the components.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp%(_mvt_doc_default_callparams)s</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp%(_doc_random_state)s</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspNotes</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp-----</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp%(_mvt_doc_callparams_note)s</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspThe matrix `shape` must be a (symmetric) positive semidefinite matrix. The</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdeterminant and inverse of `shape` are computed as the pseudo-determinant</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspand pseudo-inverse, respectively, so that `shape` does not need to have</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspfull rank.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspThe probability density function for `multivariate_t` is</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp.. math::</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspf(x) = \frac{\Gamma(\nu + p)/2}{\Gamma(\nu/2)\nu^{p/2}\pi^{p/2}|\Sigma|^{1/2}}</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp\left[1 + \frac{1}{\nu} (\mathbf{x} - \boldsymbol{\mu})^{\top}</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp\boldsymbol{\Sigma}^{-1}</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp(\mathbf{x} - \boldsymbol{\mu}) \right]^{-(\nu + p)/2},</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspwhere :math:`p` is the dimension of :math:`\mathbf{x}`,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp:math:`\boldsymbol{\mu}` is the :math:`p`-dimensional location,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp:math:`\boldsymbol{\Sigma}` the :math:`p \times p`-dimensional shape</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspmatrix, and :math:`\nu` is the degrees of freedom.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp.. versionadded:: 1.6.0</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspExamples</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp--------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> import matplotlib.pyplot as plt</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> from scipy.stats import multivariate_t</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> x, y = np.mgrid[-1:3:.01, -2:1.5:.01]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> pos = np.dstack((x, y))</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> rv = multivariate_t([1.0, -0.5], [[2.1, 0.3], [0.3, 1.5]], df=2)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> fig, ax = plt.subplots(1, 1)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> ax.set_aspect('equal')</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> plt.contourf(x, y, rv.pdf(pos))</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdef __init__(self, seed=None):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Initialize a multivariate t-distributed random variable.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspseed : Random state.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsuper().__init__(seed)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.__doc__ = doccer.docformat(self.__doc__, mvt_docdict_params)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._random_state = check_random_state(seed)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdef __call__(self, loc=None, shape=1, df=1, allow_singular=False,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspseed=None):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Create a frozen multivariate t-distribution.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspSee `multivariate_t_frozen` for parameters.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif df == np.inf:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn multivariate_normal_frozen(mean=loc, cov=shape,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspallow_singular=allow_singular,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspseed=seed)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn multivariate_t_frozen(loc=loc, shape=shape, df=df,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspallow_singular=allow_singular, seed=seed)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdef pdf(self, x, loc=None, shape=1, df=1, allow_singular=False):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Multivariate t-distribution probability density function.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspx : array_like</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspPoints at which to evaluate the probability density function.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp%(_mvt_doc_default_callparams)s</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspReturns</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp-------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsppdf : Probability density function evaluated at `x`.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspExamples</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp--------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp>>> from scipy.stats import multivariate_t</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp>>> x = [0.4, 5]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp>>> loc = [0, 1]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp>>> shape = [[1, 0.1], [0.1, 1]]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp>>> df = 7</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp>>> multivariate_t.pdf(x, loc, shape, df)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsparray([0.00075713])</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdim, loc, shape, df = self._process_parameters(loc, shape, df)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspx = self._process_quantiles(x, dim)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspshape_info = _PSD(shape, allow_singular=allow_singular)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsplogpdf = self._logpdf(x, loc, shape_info.U, shape_info.log_pdet, df,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdim, shape_info.rank)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn np.exp(logpdf)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdef logpdf(self, x, loc=None, shape=1, df=1):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Log of the multivariate t-distribution probability density function.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspx : array_like</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspPoints at which to evaluate the log of the probability density</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspfunction.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp%(_mvt_doc_default_callparams)s</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspReturns</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp-------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsplogpdf : Log of the probability density function evaluated at `x`.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspExamples</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp--------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp>>> from scipy.stats import multivariate_t</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp>>> x = [0.4, 5]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp>>> loc = [0, 1]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp>>> shape = [[1, 0.1], [0.1, 1]]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp>>> df = 7</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp>>> multivariate_t.logpdf(x, loc, shape, df)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsparray([-7.1859802])</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspSee Also</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp--------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsppdf : Probability density function.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdim, loc, shape, df = self._process_parameters(loc, shape, df)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspx = self._process_quantiles(x, dim)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspshape_info = _PSD(shape)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn self._logpdf(x, loc, shape_info.U, shape_info.log_pdet, df, dim,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspshape_info.rank)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdef _logpdf(self, x, loc, prec_U, log_pdet, df, dim, rank):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Utility method `pdf`, `logpdf` for parameters.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspx : ndarray</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspPoints at which to evaluate the log of the probability density</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspfunction.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsploc : ndarray</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspLocation of the distribution.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspprec_U : ndarray</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspA decomposition such that `np.dot(prec_U, prec_U.T)` is the inverse</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspof the shape matrix.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsplog_pdet : float</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspLogarithm of the determinant of the shape matrix.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdf : float</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspDegrees of freedom of the distribution.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdim : int</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspDimension of the quantiles x.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprank : int</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspRank of the shape matrix.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspNotes</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp-----</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspAs this function does no argument checking, it should not be called</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdirectly; use 'logpdf' instead.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif df == np.inf:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn multivariate_normal._logpdf(x, loc, prec_U, log_pdet, rank)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdev = x - loc</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmaha = np.square(np.dot(dev, prec_U)).sum(axis=-1)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspt = 0.5 * (df + dim)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspA = gammaln(t)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspB = gammaln(0.5 * df)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspC = dim/2. * np.log(df * np.pi)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspD = 0.5 * log_pdet</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspE = -t * np.log(1 + (1./df) * maha)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn _squeeze_output(A - B - C - D + E)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdef rvs(self, loc=None, shape=1, df=1, size=1, random_state=None):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Draw random samples from a multivariate t-distribution.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp%(_mvt_doc_default_callparams)s</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsize : integer, optional</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspNumber of samples to draw (default 1).</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp%(_doc_random_state)s</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspReturns</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp-------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprvs : ndarray or scalar</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspRandom variates of size (`size`, `P`), where `P` is the</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdimension of the random variable.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspExamples</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp--------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp>>> from scipy.stats import multivariate_t</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp>>> x = [0.4, 5]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp>>> loc = [0, 1]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp>>> shape = [[1, 0.1], [0.1, 1]]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp>>> df = 7</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp>>> multivariate_t.rvs(loc, shape, df)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsparray([[0.93477495, 3.00408716]])</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# For implementation details, see equation (3):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp#</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp#    Hofert, "On Sampling from the Multivariatet Distribution", 2013</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp#     http://rjournal.github.io/archive/2013-2/hofert.pdf</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp#</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdim, loc, shape, df = self._process_parameters(loc, shape, df)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif random_state is not None:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprng = check_random_state(random_state)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelse:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprng = self._random_state</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif np.isinf(df):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspx = np.ones(size)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelse:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspx = rng.chisquare(df, size=size) / df</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspz = rng.multivariate_normal(np.zeros(dim), shape, size=size)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsamples = loc + z / np.sqrt(x)[..., None]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn _squeeze_output(samples)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdef _process_quantiles(self, x, dim):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspAdjust quantiles array so that last axis labels the components of</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspeach data point.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspx = np.asarray(x, dtype=float)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif x.ndim == 0:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspx = x[np.newaxis]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelif x.ndim == 1:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif dim == 1:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspx = x[:, np.newaxis]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelse:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspx = x[np.newaxis, :]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn x</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdef _process_parameters(self, loc, shape, df):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspInfer dimensionality from location array and shape matrix, handle</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdefaults, and ensure compatible dimensions.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif loc is None and shape is None:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsploc = np.asarray(0, dtype=float)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspshape = np.asarray(1, dtype=float)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdim = 1</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelif loc is None:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspshape = np.asarray(shape, dtype=float)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif shape.ndim < 2:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdim = 1</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelse:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdim = shape.shape[0]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsploc = np.zeros(dim)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelif shape is None:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsploc = np.asarray(loc, dtype=float)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdim = loc.size</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspshape = np.eye(dim)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelse:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspshape = np.asarray(shape, dtype=float)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsploc = np.asarray(loc, dtype=float)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdim = loc.size</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif dim == 1:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsploc.shape = (1,)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspshape.shape = (1, 1)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif loc.ndim != 1 or loc.shape[0] != dim:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("Array 'loc' must be a vector of length %d." %</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdim)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif shape.ndim == 0:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspshape = shape * np.eye(dim)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelif shape.ndim == 1:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspshape = np.diag(shape)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelif shape.ndim == 2 and shape.shape != (dim, dim):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprows, cols = shape.shape</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif rows != cols:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmsg = ("Array 'cov' must be square if it is two dimensional,"</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp" but cov.shape = %s." % str(shape.shape))</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelse:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmsg = ("Dimension mismatch: array 'cov' is of shape %s,"</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp" but 'loc' is a vector of length %d.")</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmsg = msg % (str(shape.shape), len(loc))</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError(msg)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelif shape.ndim > 2:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("Array 'cov' must be at most two-dimensional,"</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp" but cov.ndim = %d" % shape.ndim)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# Process degrees of freedom.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif df is None:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdf = 1</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelif df <= 0:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("'df' must be greater than zero.")</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelif np.isnan(df):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("'df' is 'nan' but must be greater than zero or 'np.inf'.")</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn dim, loc, shape, df</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+class multivariate_t_frozen(multi_rv_frozen):</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdef __init__(self, loc=None, shape=1, df=1, allow_singular=False,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspseed=None):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Create a frozen multivariate t distribution.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp%(_mvt_doc_default_callparams)s</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspExamples</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp--------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp>>> loc = np.zeros(3)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp>>> shape = np.eye(3)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp>>> df = 10</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp>>> dist = multivariate_t(loc, shape, df)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp>>> dist.rvs()</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsparray([[ 0.81412036, -1.53612361,  0.42199647]])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp>>> dist.pdf([1, 1, 1])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsparray([0.01237803])</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._dist = multivariate_t_gen(seed)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdim, loc, shape, df = self._dist._process_parameters(loc, shape, df)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.dim, self.loc, self.shape, self.df = dim, loc, shape, df</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.shape_info = _PSD(shape, allow_singular=allow_singular)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdef logpdf(self, x):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspx = self._dist._process_quantiles(x, self.dim)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspU = self.shape_info.U</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsplog_pdet = self.shape_info.log_pdet</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn self._dist._logpdf(x, self.loc, U, log_pdet, self.df, self.dim,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.shape_info.rank)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdef pdf(self, x):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn np.exp(self.logpdf(x))</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdef rvs(self, size=1, random_state=None):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn self._dist.rvs(loc=self.loc,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspshape=self.shape,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdf=self.df,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsize=size,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprandom_state=random_state)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+multivariate_t = multivariate_t_gen()</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+# Set frozen generator docstrings from corresponding docstrings in</span>
<br><span style="color:green">+# matrix_normal_gen and fill in default strings in class docstrings</span>
<br><span style="color:green">+for name in ['logpdf', 'pdf', 'rvs']:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspmethod = multivariate_t_gen.__dict__[name]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspmethod_frozen = multivariate_t_frozen.__dict__[name]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspmethod_frozen.__doc__ = doccer.docformat(method.__doc__,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmvt_docdict_noparams)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspmethod.__doc__ = doccer.docformat(method.__doc__, mvt_docdict_params)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+_mhg_doc_default_callparams = """\</span>
<br><span style="color:green">+m : array_like</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspThe number of each type of object in the population.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspThat is, :math:`m[i]` is the number of objects of</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsptype :math:`i`.</span>
<br><span style="color:green">+n : array_like</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspThe number of samples taken from the population.</span>
<br><span style="color:green">+"""</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+_mhg_doc_callparams_note = """\</span>
<br><span style="color:green">+`m` must be an array of positive integers. If the quantile</span>
<br><span style="color:green">+:math:`i` contains values out of the range :math:`[0, m_i]`</span>
<br><span style="color:green">+where :math:`m_i` is the number of objects of type :math:`i`</span>
<br><span style="color:green">+in the population or if the parameters are inconsistent with one</span>
<br><span style="color:green">+another (e.g. ``x.sum() != n``), methods return the appropriate</span>
<br><span style="color:green">+value (e.g. ``0`` for ``pmf``). If `m` or `n` contain negative</span>
<br><span style="color:green">+values, the result will contain ``nan`` there.</span>
<br><span style="color:green">+"""</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+_mhg_doc_frozen_callparams = ""</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+_mhg_doc_frozen_callparams_note = \</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp"""See class definition for a detailed description of parameters."""</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+mhg_docdict_params = {</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp'_doc_default_callparams': _mhg_doc_default_callparams,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp'_doc_callparams_note': _mhg_doc_callparams_note,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp'_doc_random_state': _doc_random_state</span>
<br><span style="color:green">+}</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+mhg_docdict_noparams = {</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp'_doc_default_callparams': _mhg_doc_frozen_callparams,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp'_doc_callparams_note': _mhg_doc_frozen_callparams_note,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp'_doc_random_state': _doc_random_state</span>
<br><span style="color:green">+}</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+class multivariate_hypergeom_gen(multi_rv_generic):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspr"""A multivariate hypergeometric random variable.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspMethods</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp-------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp``pmf(x, m, n)``</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspProbability mass function.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp``logpmf(x, m, n)``</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspLog of the probability mass function.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp``rvs(m, n, size=1, random_state=None)``</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspDraw random samples from a multivariate hypergeometric</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdistribution.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp``mean(m, n)``</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspMean of the multivariate hypergeometric distribution.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp``var(m, n)``</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspVariance of the multivariate hypergeometric distribution.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp``cov(m, n)``</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspCompute the covariance matrix of the multivariate</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsphypergeometric distribution.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspParameters</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp----------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp%(_doc_default_callparams)s</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp%(_doc_random_state)s</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspNotes</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp-----</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp%(_doc_callparams_note)s</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspThe probability mass function for `multivariate_hypergeom` is</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp.. math::</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspP(X_1 = x_1, X_2 = x_2, \ldots, X_k = x_k) = \frac{\binom{m_1}{x_1}</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp\binom{m_2}{x_2} \cdots \binom{m_k}{x_k}}{\binom{M}{n}}, \\ \quad</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp(x_1, x_2, \ldots, x_k) \in \mathbb{N}^k \text{ with }</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp\sum_{i=1}^k x_i = n</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspwhere :math:`m_i` are the number of objects of type :math:`i`, :math:`M`</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspis the total number of objects in the population (sum of all the</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp:math:`m_i`), and :math:`n` is the size of the sample to be taken</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspfrom the population.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp.. versionadded:: 1.6.0</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspExamples</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp--------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspTo evaluate the probability mass function of the multivariate</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsphypergeometric distribution, with a dichotomous population of size</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp:math:`10` and :math:`20`, at a sample of size :math:`12` with</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp:math:`8` objects of the first type and :math:`4` objects of the</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspsecond type, use:</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> from scipy.stats import multivariate_hypergeom</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> multivariate_hypergeom.pmf(x=[8, 4], m=[10, 20], n=12)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp0.0025207176631464523</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspThe `multivariate_hypergeom` distribution is identical to the</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspcorresponding `hypergeom` distribution (tiny numerical differences</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspnotwithstanding) when only two types (good and bad) of objects</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspare present in the population as in the example above. Consider</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspanother example for a comparison with the hypergeometric distribution:</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> from scipy.stats import hypergeom</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> multivariate_hypergeom.pmf(x=[3, 1], m=[10, 5], n=4)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp0.4395604395604395</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> hypergeom.pmf(k=3, M=15, n=4, N=10)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp0.43956043956044005</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspThe functions ``pmf``, ``logpmf``, ``mean``, ``var``, ``cov``, and ``rvs``</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspsupport broadcasting, under the convention that the vector parameters</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp(``x``, ``m``, and ``n``) are interpreted as if each row along the last</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspaxis is a single object. For instance, we can combine the previous two</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspcalls to `multivariate_hypergeom` as</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> multivariate_hypergeom.pmf(x=[[8, 4], [3, 1]], m=[[10, 20], [10, 5]],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp...                            n=[12, 4])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsparray([0.00252072, 0.43956044])</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspThis broadcasting also works for ``cov``, where the output objects are</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspsquare matrices of size ``m.shape[-1]``. For example:</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> multivariate_hypergeom.cov(m=[[7, 9], [10, 15]], n=[8, 12])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsparray([[[ 1.05, -1.05],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[-1.05,  1.05]],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[[ 1.56, -1.56],</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp[-1.56,  1.56]]])</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspThat is, ``result[0]`` is equal to</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp``multivariate_hypergeom.cov(m=[7, 9], n=8)`` and ``result[1]`` is equal</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspto ``multivariate_hypergeom.cov(m=[10, 15], n=12)``.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspAlternatively, the object may be called (as a function) to fix the `m`</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspand `n` parameters, returning a "frozen" multivariate hypergeometric</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsprandom variable.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> rv = multivariate_hypergeom(m=[10, 20], n=12)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp>>> rv.pmf(x=[8, 4])</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp0.0025207176631464523</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspSee Also</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp--------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspscipy.stats.hypergeom : The hypergeometric distribution.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspscipy.stats.multinomial : The multinomial distribution.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspReferences</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp----------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp.. [1] The Multivariate Hypergeometric Distribution,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsphttp://www.randomservices.org/random/urn/MultiHypergeometric.html</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp.. [2] Thomas J. Sargent and John Stachurski, 2020,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspMultivariate Hypergeometric Distribution</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsphttps://python.quantecon.org/_downloads/pdf/multi_hyper.pdf</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdef __init__(self, seed=None):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsuper().__init__(seed)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.__doc__ = doccer.docformat(self.__doc__, mhg_docdict_params)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdef __call__(self, m, n, seed=None):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Create a frozen multivariate_hypergeom distribution.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspSee `multivariate_hypergeom_frozen` for more information.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn multivariate_hypergeom_frozen(m, n, seed=seed)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdef _process_parameters(self, m, n):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspm = np.asarray(m)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspn = np.asarray(n)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif m.size == 0:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspm = m.astype(int)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif n.size == 0:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspn = n.astype(int)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif not np.issubdtype(m.dtype, np.integer):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise TypeError("'m' must an array of integers.")</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif not np.issubdtype(n.dtype, np.integer):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise TypeError("'n' must an array of integers.")</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif m.ndim == 0:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("'m' must be an array with"</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp" at least one dimension.")</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# check for empty arrays</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif m.size != 0:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspn = n[..., np.newaxis]</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspm, n = np.broadcast_arrays(m, n)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# check for empty arrays</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif m.size != 0:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspn = n[..., 0]</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmcond = m < 0</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspM = m.sum(axis=-1)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspncond = (n < 0) | (n > M)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn M, m, n, mcond, ncond, np.any(mcond, axis=-1) | ncond</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdef _process_quantiles(self, x, M, m, n):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspx = np.asarray(x)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif not np.issubdtype(x.dtype, np.integer):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise TypeError("'x' must an array of integers.")</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif x.ndim == 0:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError("'x' must be an array with"</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp" at least one dimension.")</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif not x.shape[-1] == m.shape[-1]:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspraise ValueError(f"Size of each quantile must be size of 'm': "</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspf"received {x.shape[-1]}, "</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspf"but expected {m.shape[-1]}.")</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# check for empty arrays</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif m.size != 0:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspn = n[..., np.newaxis]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspM = M[..., np.newaxis]</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspx, m, n, M = np.broadcast_arrays(x, m, n, M)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# check for empty arrays</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif m.size != 0:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspn, M = n[..., 0], M[..., 0]</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspxcond = (x < 0) | (x > m)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn (x, M, m, n, xcond,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspnp.any(xcond, axis=-1) | (x.sum(axis=-1) != n))</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdef _checkresult(self, result, cond, bad_value):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspresult = np.asarray(result)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif cond.ndim != 0:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspresult[cond] = bad_value</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelif cond:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn bad_value</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif result.ndim == 0:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn result[()]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn result</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdef _logpmf(self, x, M, m, n, mxcond, ncond):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# This equation of the pmf comes from the relation,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# n combine r = beta(n+1, 1) / beta(r+1, n-r+1)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspnum = np.zeros_like(m, dtype=np.float_)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspden = np.zeros_like(n, dtype=np.float_)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspm, x = m[~mxcond], x[~mxcond]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspM, n = M[~ncond], n[~ncond]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspnum[~mxcond] = (betaln(m+1, 1) - betaln(x+1, m-x+1))</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspden[~ncond] = (betaln(M+1, 1) - betaln(n+1, M-n+1))</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspnum[mxcond] = np.nan</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspden[ncond] = np.nan</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspnum = num.sum(axis=-1)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn num - den</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdef logpmf(self, x, m, n):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Log of the multivariate hypergeometric probability mass function.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspx : array_like</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspQuantiles, with the last axis of `x` denoting the components.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp%(_doc_default_callparams)s</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspReturns</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp-------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsplogpmf : ndarray or scalar</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspLog of the probability mass function evaluated at `x`</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspNotes</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp-----</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp%(_doc_callparams_note)s</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspM, m, n, mcond, ncond, mncond = self._process_parameters(m, n)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp(x, M, m, n, xcond,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspxcond_reduced) = self._process_quantiles(x, M, m, n)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmxcond = mcond | xcond</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspncond = ncond | np.zeros(n.shape, dtype=np.bool_)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspresult = self._logpmf(x, M, m, n, mxcond, ncond)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# replace values for which x was out of the domain; broadcast</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# xcond to the right shape</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspxcond_ = xcond_reduced | np.zeros(mncond.shape, dtype=np.bool_)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspresult = self._checkresult(result, xcond_, np.NINF)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# replace values bad for n or m; broadcast</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# mncond to the right shape</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmncond_ = mncond | np.zeros(xcond_reduced.shape, dtype=np.bool_)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn self._checkresult(result, mncond_, np.nan)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdef pmf(self, x, m, n):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Multivariate hypergeometric probability mass function.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspx : array_like</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspQuantiles, with the last axis of `x` denoting the components.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp%(_doc_default_callparams)s</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspReturns</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp-------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsppmf : ndarray or scalar</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspProbability density function evaluated at `x`</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspNotes</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp-----</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp%(_doc_callparams_note)s</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspout = np.exp(self.logpmf(x, m, n))</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn out</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdef mean(self, m, n):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Mean of the multivariate hypergeometric distribution.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp%(_doc_default_callparams)s</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspReturns</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp-------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmean : array_like or scalar</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThe mean of the distribution</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspM, m, n, _, _, mncond = self._process_parameters(m, n)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# check for empty arrays</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif m.size != 0:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspM, n = M[..., np.newaxis], n[..., np.newaxis]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond = (M == 0)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspM = np.ma.masked_array(M, mask=cond)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmu = n*(m/M)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif m.size != 0:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmncond = (mncond[..., np.newaxis] |</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspnp.zeros(mu.shape, dtype=np.bool_))</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn self._checkresult(mu, mncond, np.nan)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdef var(self, m, n):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Variance of the multivariate hypergeometric distribution.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp%(_doc_default_callparams)s</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspReturns</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp-------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsparray_like</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThe variances of the components of the distribution.  This is</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspthe diagonal of the covariance matrix of the distribution</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspM, m, n, _, _, mncond = self._process_parameters(m, n)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# check for empty arrays</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif m.size != 0:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspM, n = M[..., np.newaxis], n[..., np.newaxis]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond = (M == 0) & (M-1 == 0)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspM = np.ma.masked_array(M, mask=cond)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoutput = n * m/M * (M-m)/M * (M-n)/(M-1)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif m.size != 0:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmncond = (mncond[..., np.newaxis] |</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspnp.zeros(output.shape, dtype=np.bool_))</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn self._checkresult(output, mncond, np.nan)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdef cov(self, m, n):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Covariance matrix of the multivariate hypergeometric distribution.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp%(_doc_default_callparams)s</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspReturns</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp-------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcov : array_like</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspThe covariance matrix of the distribution</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# see [1]_ for the formula and [2]_ for implementation</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# cov( x_i,x_j ) = -n * (M-n)/(M-1) * (K_i*K_j) / (M**2)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspM, m, n, _, _, mncond = self._process_parameters(m, n)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# check for empty arrays</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif m.size != 0:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspM = M[..., np.newaxis, np.newaxis]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspn = n[..., np.newaxis, np.newaxis]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond = (M == 0) & (M-1 == 0)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspM = np.ma.masked_array(M, mask=cond)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoutput = (-n * (M-n)/(M-1) *</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspnp.einsum("...i,...j->...ij", m, m) / (M**2))</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# check for empty arrays</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif m.size != 0:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspM, n = M[..., 0, 0], n[..., 0, 0]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspcond = cond[..., 0, 0]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdim = m.shape[-1]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# diagonal entries need to be computed differently</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspfor i in range(dim):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoutput[..., i, i] = (n * (M-n) * m[..., i]*(M-m[..., i]))</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoutput[..., i, i] = output[..., i, i] / (M-1)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspoutput[..., i, i] = output[..., i, i] / (M**2)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif m.size != 0:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmncond = (mncond[..., np.newaxis, np.newaxis] |</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspnp.zeros(output.shape, dtype=np.bool_))</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn self._checkresult(output, mncond, np.nan)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdef rvs(self, m, n, size=None, random_state=None):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""Draw random samples from a multivariate hypergeometric distribution.</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspParameters</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp----------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp%(_doc_default_callparams)s</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsize : integer or iterable of integers, optional</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspNumber of samples to draw. Default is ``None``, in which case a</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsingle variate is returned as an array with shape ``m.shape``.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp%(_doc_random_state)s</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspReturns</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp-------</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprvs : array_like</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspRandom variates of shape ``size`` or ``m.shape``</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp(if ``size=None``).</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspNotes</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp-----</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp%(_doc_callparams_note)s</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspAlso note that NumPy's `multivariate_hypergeometric` sampler is not</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspused as it doesn't support broadcasting.</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp"""</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspM, m, n, _, _, _ = self._process_parameters(m, n)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprandom_state = self._get_random_state(random_state)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif size is not None and isinstance(size, int):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsize = (size, )</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspif size is None:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprvs = np.empty(m.shape, dtype=m.dtype)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspelse:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprvs = np.empty(size + (m.shape[-1], ), dtype=m.dtype)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprem = M</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# This sampler has been taken from numpy gh-13794</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# https://github.com/numpy/numpy/pull/13794</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspfor c in range(m.shape[-1] - 1):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprem = rem - m[..., c]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprvs[..., c] = ((n != 0) *</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprandom_state.hypergeometric(m[..., c], rem,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspn + (n == 0),</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsize=size))</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspn = n - rvs[..., c]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprvs[..., m.shape[-1] - 1] = n</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn rvs</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+multivariate_hypergeom = multivariate_hypergeom_gen()</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+class multivariate_hypergeom_frozen(multi_rv_frozen):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdef __init__(self, m, n, seed=None):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._dist = multivariate_hypergeom_gen(seed)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp(self.M, self.m, self.n,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.mcond, self.ncond,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.mncond) = self._dist._process_parameters(m, n)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp# monkey patch self._dist</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspdef _process_parameters(m, n):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn (self.M, self.m, self.n,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.mcond, self.ncond,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself.mncond)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspself._dist._process_parameters = _process_parameters</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdef logpmf(self, x):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn self._dist.logpmf(x, self.m, self.n)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdef pmf(self, x):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn self._dist.pmf(x, self.m, self.n)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdef mean(self):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn self._dist.mean(self.m, self.n)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdef var(self):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn self._dist.var(self.m, self.n)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdef cov(self):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn self._dist.cov(self.m, self.n)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspdef rvs(self, size=1, random_state=None):</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspreturn self._dist.rvs(self.m, self.n,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspsize=size,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsprandom_state=random_state)</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+</span>
<br><span style="color:green">+# Set frozen generator docstrings from corresponding docstrings in</span>
<br><span style="color:green">+# multivariate_hypergeom and fill in default strings in class docstrings</span>
<br><span style="color:green">+for name in ['logpmf', 'pmf', 'mean', 'var', 'cov', 'rvs']:</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspmethod = multivariate_hypergeom_gen.__dict__[name]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspmethod_frozen = multivariate_hypergeom_frozen.__dict__[name]</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspmethod_frozen.__doc__ = doccer.docformat(</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmethod.__doc__, mhg_docdict_noparams)</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbspmethod.__doc__ = doccer.docformat(method.__doc__,</span>
<br><span style="color:green">+&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbspmhg_docdict_params)</span>
<br></p>
</div>
<br><br><br>_____________________________________ERROR_________________________________________
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>File_Path</th>
      <th>Line_Number</th>
      <th>Found_in_Function</th>
      <th>Function_Definition_Line_Number</th>
      <th>Assert_Statement_Type</th>
      <th>Oracle_Argument_ Position</th>
      <th>Differential_Function_Line_Number</th>
      <th>Differential_Test_Function</th>
      <th>Extracted_Function_File_Location</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>33763</th>
      <td>kernel_tests\distributions\special_math_test.py</td>
      <td>421</td>
      <td>_test_grid_log</td>
      <td>404</td>
      <td>assertAllClose</td>
      <td>1</td>
      <td>419</td>
      <td>stats.laplace</td>
      <td>ERROR</td>
    </tr>
    <tr>
      <th>33856</th>
      <td>kernel_tests\distributions\uniform_test.py</td>
      <td>210</td>
      <td>testUniformMean</td>
      <td>203</td>
      <td>assertAllClose</td>
      <td>2</td>
      <td>209</td>
      <td>stats.uniform</td>
      <td>ERROR</td>
    </tr>
    <tr>
      <th>33857</th>
      <td>kernel_tests\distributions\uniform_test.py</td>
      <td>220</td>
      <td>testUniformVariance</td>
      <td>213</td>
      <td>assertAllClose</td>
      <td>2</td>
      <td>219</td>
      <td>stats.uniform</td>
      <td>ERROR</td>
    </tr>
    <tr>
      <th>33858</th>
      <td>kernel_tests\distributions\uniform_test.py</td>
      <td>230</td>
      <td>testUniformStd</td>
      <td>223</td>
      <td>assertAllClose</td>
      <td>2</td>
      <td>229</td>
      <td>stats.uniform</td>
      <td>ERROR</td>
    </tr>
  </tbody>
</table>
<br><button type="button" class="collapsible">Git Diff</button>
<div class="content">
<p></p>
</div>
<br><br><br>
<br>
<script>
var coll = document.getElementsByClassName("collapsible");
var i;

for (i = 0; i < coll.length; i++) {
  coll[i].addEventListener("click", function() {
    this.classList.toggle("active");
    var content = this.nextElementSibling;
    if (content.style.display === "block") {
      content.style.display = "none";
    } else {
      content.style.display = "block";
    }
  });
}
</script>
</body>
</html>